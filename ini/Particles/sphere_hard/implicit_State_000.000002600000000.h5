{[( CMAKE )]}
OPTION(BOLTZPLATZ_BUILD_HDF5 "Compile and build hdf5 library" OFF)
OPTION(BOLTZPLATZ_CODE_ANALYZE "Code Analyze" ON)
OPTION(BOLTZPLATZ_CTAGS "Use Ctags" OFF)
SET(BOLTZPLATZ_EQNSYSNAME "maxwell" CACHE STRING "Used equation system")
OPTION(BOLTZPLATZ_HDF5F90 "enable old HDF5 interface" OFF)
OPTION(BOLTZPLATZ_MKL "Use MKL libraries instead of BLAS/LAPACK" OFF)
OPTION(BOLTZPLATZ_MPI "Compile SINGLE or MPI version" ON)
SET(BOLTZPLATZ_NODETYPE "GAUSS" CACHE STRING "Set of nodes used for representing the solution (GAUSS/GAUSS-LOBATTO).")
OPTION(BOLTZPLATZ_PAPI "Use PAPI library to perform performance measurements (e.g. flop counts)." OFF)
OPTION(BOLTZPLATZ_PARTICLES "Particles" ON)
SET(BOLTZPLATZ_POLYNOMIAL_DEGREE "N" CACHE STRING "N: compile with variable polynomial degree. 1,2,3,...: compile with fixed polynomial degree for performance (untested).")
SET(BOLTZPLATZ_TIMEDISCMETHOD "RK4" CACHE STRING "Time integration method")
{[( GIT REVISIONS )]}
tracing.dev
fed306f Merge branch 'tracing.dev' of gitlab.iag.uni-stuttgart.de:piclas/boltzplatz into tracing.dev
master: 
52dbd03 Merge branch 'Testcase-Semicircle' into 'master'
{[( GIT DIFF )]}
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2df98ef..3a25e13 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -117,7 +117,7 @@ ADD_DEFINITIONS(-DPP_nElems=NELEMZ)
 
 # code development
 OPTION(BOLTZPLATZ_CODE_ANALYZE "Code Analyze" OFF)
-OPTION(BOLTZPLATZ_CTAGS "Use Ctags" OFF)
+#OPTION(BOLTZPLATZ_CTAGS "Use Ctags" OFF)
 
 # =========================================================================
 # Equation system
@@ -323,8 +323,9 @@ IF (CMAKE_Fortran_COMPILER_ID MATCHES "GNU")
   # set Flags
   SET (CMAKE_Fortran_FLAGS         "${CMAKE_Fortran_FLAGS} -fdefault-real-8 -fdefault-double-8 -fbackslash -ffree-line-length-0 -DGNU")
   SET (CMAKE_Fortran_FLAGS_RELEASE "${CMAKE_Fortran_FLAGS} -O3 -march=native  -finline-functions")
-  SET (CMAKE_Fortran_FLAGS_PROFILE "${CMAKE_Fortran_FLAGS} -pg -O3 -march=native  -finline-functions")
-  SET (CMAKE_Fortran_FLAGS_DEBUG   "${CMAKE_Fortran_FLAGS} -g -O0 -ggdb3 -fbounds-check -finit-real=nan -fbacktrace  -Wall")
+  SET (CMAKE_Fortran_FLAGS_PROFILE "${CMAKE_Fortran_FLAGS} -g -pg ")
+  SET (CMAKE_Fortran_FLAGS_DEBUG   "${CMAKE_Fortran_FLAGS} -g -O0 -ggdb3 -fbounds-check -finit-real=snan -fbacktrace  -Wall")
+  SET (CMAKE_Fortran_FLAGS_SANI    "${CMAKE_Fortran_FLAGS} -g -O0 -ggdb3 -fbounds-check -finit-real=snan -fbacktrace  -Wall -fsanitize=address,undefined -fno-omit-frame-pointer -Wc-binding-type")
   # add flags only for compiling not linking!
   SET (BOLTZPLATZ_COMPILE_FLAGS "-xf95-cpp-input")
 
@@ -602,12 +603,16 @@ INSTALL(FILES    ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/configuration.cmake ${CMAKE_R
 # =========================================================================
 # Ctags
 # =========================================================================
-IF(BOLTZPLATZ_CTAGS)
-  ADD_CUSTOM_COMMAND(OUTPUT ctags.txt COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR} && ctags -R -f ctags.txt src)
-  ADD_CUSTOM_TARGET(tags DEPENDS ctags.txt)
-  FIND_PROGRAM(CTAGS_PATH ctags)
-  IF(CTAGS_PATH)
-      MESSAGE(STATUS "Found ctags: ${CTAGS_PATH}")
-      ADD_DEPENDENCIES(boltzplatz tags)
-  ENDIF(CTAGS_PATH)
-ENDIF(BOLTZPLATZ_CTAGS)
+SET(EQNS_WO_ACTUAL ${EQNSYSTEMS})
+LIST(REMOVE_ITEM EQNS_WO_ACTUAL ${BOLTZPLATZ_EQNSYSNAME})
+SET(EXLUDES "")
+FOREACH(item ${EQNS_WO_ACTUAL})
+   SET(EXLUDES "--exclude=src/equations/${item}/*" ${EXLUDES})
+ENDFOREACH()
+ADD_CUSTOM_COMMAND(OUTPUT ctags.txt COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR} && ctags -R -f ctags.txt ${EXLUDES} src)
+ADD_CUSTOM_TARGET(tags DEPENDS ctags.txt)
+FIND_PROGRAM(CTAGS_PATH ctags)
+IF(CTAGS_PATH)
+    MESSAGE(STATUS "Found ctags: ${CTAGS_PATH}")
+    ADD_DEPENDENCIES(boltzplatz tags)
+ENDIF(CTAGS_PATH)
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_lin.csv b/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_lin.csv
new file mode 100644
index 0000000..0954e3a
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_lin.csv
@@ -0,0 +1,8 @@
+-0.5 0.0
+-0.1 0.0 
+ 0.0 0.1
+ 0.1 0.0
+ 0.5 0.0
+ 0.0 0.5
+ 0.0 0.5
+-0.5 0.0
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_n2.csv b/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_n2.csv
new file mode 100644
index 0000000..2da29cc
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/geo/geo_n2.csv
@@ -0,0 +1,13 @@
+-0.5 0.
+-0.3 0.
+-0.1 0.
+-0.0706 0.0706
+ 0. 0.1
+ 0.0706 0.0706
+ 0.1 0.
+ 0.3 0.
+ 0.5 0.
+ 0.353 0.353
+ 0.0 0.5
+-0.353 0.353
+-0.5 0.
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/parameter_semicircle.ini b/ini/Particles/Semicircle_lin_RefMap_T/parameter_semicircle.ini
new file mode 100644
index 0000000..65ff198
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/parameter_semicircle.ini
@@ -0,0 +1,115 @@
+! =============================================================================== !
+! MAKEFILE PARAMETER (put a "#" in front, NO blanks!)
+! =============================================================================== !
+! eqn: navierstokes, linearscalaradvection, maxwell
+#EQNSYS=maxwell
+! enables particles, required for PIC, DSMC and LD
+#PARTICLES=T
+! explicit time discretization : 1...RK3, 2...RK4, 3...Taylor
+#TIMEDISCMETHOD=2
+! node type: 1...Gauss, 2...Gauss-Lobatto
+#NODETYPE=1
+! Riemann solver: 1...LF, 2...HLLC, 3...Roe
+#RIEMANN=1
+! Parallel execution: EMPTY...Off, T...On (MPI)
+#MPI=T
+! optional: fixed number of elements
+#NELEMS=
+! optional: fixed polynomial degree
+#N=
+! optimizations ignoring inner array bounds (EMPTY...Off, T...On)
+! (cause errors when using array bound checks, always switched of in debug mode)
+#OPTIMIZED=
+! additional potential solver 
+#POIS=
+! using old HDF5 with only F90 support
+#HDF5_F90=
+
+! =============================================================================== !
+! EQUATION (linearscalaradvection)
+! =============================================================================== !
+IniExactFunc  = 2
+
+! =============================================================================== !
+! DISCRETIZATION
+! =============================================================================== !
+N             = 4  ! Polynomial degree
+NAnalyze      = 10 ! Number of analyze points
+
+! =============================================================================== !
+! MESH
+! =============================================================================== !
+MeshFile      = semicircle_mesh.h5
+useCurveds    = F
+
+! =============================================================================== !
+! OUTPUT / VISUALIZATION
+! =============================================================================== !
+ProjectName     = SEMICIRCLE
+Logging         = F
+WriteErrorFiles = F
+
+! =============================================================================== !
+! CALCULATION
+! =============================================================================== !
+tend       =1200.0 ! End time
+Analyze_dt = 110.5 ! Timestep of analyze outputs
+CFLscale   = 5.5  ! Scaling of theoretical CFL number
+
+! =============================================================================== !
+! tracking
+! =============================================================================== !
+!BezierClipTolerance=1e-9  
+!BezierClipMaxIter  =100
+!BezierSplitLimit   =0.6
+!BezierClipHit      =1e-7
+!BezierElevation    =0
+
+!epsilontol         =1e-12
+DoRefMapping       =F
+!RefMappingEps      =1e-12
+!RefMappingGuess    =1
+Static-LoadBalance =F
+MeassureTrackTime  =T
+Part-LorentzType   =3
+
+! =============================================================================== !
+! PARTICLES
+! =============================================================================== !
+Part-maxParticleNumber=10 !110000
+Part-nSpecies=1
+PIC-DoInterpolation=F
+!Part-Species1-SpaceIC=line_with_equidistant_distribution
+Part-Species1-SpaceIC=point
+Part-Species1-initialParticleNumber=1
+!Part-Species1-BasePointIC=(/-5.55112e-17,0.3,0./)
+Part-Species1-BasePointIC=(/-0.199999,0.28,0.00001/)
+Part-Species1-BaseVector2IC=(/0.,0.,0./)
+Part-Species1-NormalIC=(/0.1,0.,0.0/)
+Part-Species1-velocityDistribution=constant
+Part-Species1-VeloIC=0.7
+!Part-Species1-VeloVecIC=(/1.0,1.0,0.0/)
+!Part-Species1-VeloVecIC=(/0.0,1.0,0.0/)
+!Part-Species1-VeloVecIC=(/0.0,1.0,0.0/)
+Part-Species1-VeloVecIC=(/1.0,1.0,0.0/)
+Part-Species1-ChargeIC=-1.
+Part-Species1-MassIC=9.
+Part-Species1-MacroParticleFactor=1E0
+Part-nBounds=1
+Part-Boundary1-SourceName=BC_Wall
+Part-Boundary1-Condition=reflective
+PIC-Interpolation-Type=particle_position
+PIC-Deposition-Type=delta_distri
+Part-FIBGMdeltas=(/0.550,0.550,0.550/)
+! =============================================================================== !
+! Analysis
+! =============================================================================== !
+CalcPotentialEnergy = T
+CalcCharge          = F
+CalcNumSpec         = F
+CalcKineticEnergy   = F
+TrackPosition       = T
+Part-TrackPosition  = T
+printDiff           = T
+printDiffTime       = 12.
+printDiffVec         =(/0.21145302115002,0.18723754743135,0.,-0.26787840265560,-0.64671567275788,0./)
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/plot.sh b/ini/Particles/Semicircle_lin_RefMap_T/plot.sh
new file mode 100644
index 0000000..c68acf5
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/plot.sh
@@ -0,0 +1,12 @@
+r=0.5
+set parametric
+set trange[0:pi]
+fx(t)=r*cos(t)
+fy(t)=r*sin(t)
+r2=0.1
+fx2(t)=r2*cos(t)
+fy2(t)=r2*sin(t)
+#set size equal
+plot './ParticlePosition.csv' u 3:4 w p, './geo/geo.csv' u 1:2 w l lc 4, fx(t),fy(t) lc 3,fx2(t),fy2(t) lc 3
+pause -1
+reload
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/plot2.sh b/ini/Particles/Semicircle_lin_RefMap_T/plot2.sh
new file mode 100644
index 0000000..c93334e
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/plot2.sh
@@ -0,0 +1,19 @@
+set terminal gif animate
+set output 'output.gif'
+stats './ParticlePosition.csv' nooutput
+r=0.5
+set parametric
+set trange[0:pi]
+set size ratio -1
+set xrange [-0.5:0.5]
+set yrange [0.:0.5]
+set nokey
+fx(t)=r*cos(t)
+fy(t)=r*sin(t)
+r2=0.1
+fx2(t)=r2*cos(t)
+fy2(t)=r2*sin(t)
+
+do for [i=1:int(STATS_blocks)] {
+   plot for [IDX=0:i-1] './ParticlePosition.csv' index IDX u 3:4 w p lc rgb "red" pt 1, fx(t),fy(t) lc 3,fx2(t),fy2(t) lc 3
+}
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/plot_exact.sh b/ini/Particles/Semicircle_lin_RefMap_T/plot_exact.sh
new file mode 100644
index 0000000..79afa5d
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/plot_exact.sh
@@ -0,0 +1,11 @@
+r=0.5
+set parametric
+set trange[0:pi]
+fx(t)=r*cos(t)
+fy(t)=r*sin(t)
+r2=0.1
+fx2(t)=r2*cos(t)
+fy2(t)=r2*sin(t)
+#set size equal
+plot './MyRank000000_ParticlePosition.csv' u 3:4 w l, './geo/geo.csv' u 1:2 w l lc 3, fx(t),fy(t) lc 3,fx2(t),fy2(t) lc 3
+pause -1
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/preproc_semicircle.ini b/ini/Particles/Semicircle_lin_RefMap_T/preproc_semicircle.ini
new file mode 100644
index 0000000..4715711
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/preproc_semicircle.ini
@@ -0,0 +1,47 @@
+!=============================================================================== !
+! MAKEFILE PARAMETER (put a "#" in front, NO blanks!)
+!=============================================================================== !
+! This is only a dummy parameter needed for the regression check
+#MPI=
+
+!=============================================================================== !
+! OUTPUT
+!=============================================================================== !
+  ProjectName  =semicircle  ! name of the project (used for filenames)
+  Debugvisu    =F                           ! Write debug mesh to tecplot file
+  Debugvisulevel=2
+  Logging      =F                           ! Write log files
+
+!=============================================================================== !
+! MESH
+!=============================================================================== !
+  FileName     =semicircle
+  Mode         =11                           ! 1 Strukti Curved mesh
+  nZones       =1                            ! number of zones
+  nElems       =(/2,2,2/)                 ! Anzahl der Elemente in jede Richtung (30x20x60)
+  BoundaryOrder= 3                          ! Ngeo+1
+  BCIndex      =(/1,1,1,1,1,1/)             ! Indices of UserDefinedBoundaries
+
+  Meshtype     = 3    ! Mesh Types: 1 - Cube     (origin + dimensions)
+                      !             2 - Bilinear (8 points CGNS notation)
+                      !             3 - Curved (see Whichmapping) 
+  WhichMapping = 3
+                      ! 1...Trilinear (equal to MeshType 2)
+                      ! 2... quadratic bubble function on the side
+                      ! 3...half cylinder
+                      ! 4...full cylinder
+
+  R_0=0.1
+  R_INF=0.5
+  Dz=0.25
+
+  useCurveds   =T                           ! T if curved boundaries defined
+  SpaceQuandt  =1.                          ! characteristic length of the mesh
+  ConformConnect=T
+  checkElemJacobians=T
+!=============================================================================== !
+! BOUNDARY CONDITIONS
+!=============================================================================== !
+! 22-Exakte Dirichlet RB, 3-Neumann-Null RB
+   BoundaryName=BC_Wall     
+   BoundaryType=(/4,0,1,0/)     
diff --git a/ini/Particles/Semicircle_lin_RefMap_T/test.sh b/ini/Particles/Semicircle_lin_RefMap_T/test.sh
new file mode 100755
index 0000000..d10e505
--- /dev/null
+++ b/ini/Particles/Semicircle_lin_RefMap_T/test.sh
@@ -0,0 +1,3 @@
+rm *.csv
+rm *State*
+./boltzplatz parameter_semicircle.ini
diff --git a/src/boltzplatz.h b/src/boltzplatz.h
index b99aa1a..c6cff4c 100644
--- a/src/boltzplatz.h
+++ b/src/boltzplatz.h
@@ -80,7 +80,8 @@
 #define PLANAR_RECT   0
 #define PLANAR_NONRECT   1
 #define BILINEAR 2
-#define CURVED   3
+#define PLANAR_CURVED   3
+#define CURVED   4
 
 ! entries for PartHaloToProc
 #define NATIVE_ELEM_ID  1
diff --git a/src/dg/fillflux.f90 b/src/dg/fillflux.f90
index 46b2898..8b7907c 100644
--- a/src/dg/fillflux.f90
+++ b/src/dg/fillflux.f90
@@ -34,7 +34,7 @@ USE MOD_Mesh_Vars,       ONLY:nSides,nBCSides,nInnerSides,nMPISides_MINE
 USE MOD_Riemann,         ONLY:Riemann
 USE MOD_Mesh_Vars,       ONLY:SideID_plus_lower,SideID_plus_upper
 USE MOD_Mesh_Vars,       ONLY:SideID_minus_lower,SideID_minus_upper
-USE MOD_Mesh_Vars,       ONLY:NormVec,TangVec1, tangVec2, SurfElem,BCFace_xGP
+USE MOD_Mesh_Vars,       ONLY:NormVec,TangVec1, tangVec2, SurfElem,Face_xGP
 USE MOD_GetBoundaryFlux, ONLY:GetBoundaryFlux
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
@@ -74,7 +74,12 @@ DO SideID=firstSideID,lastSideID
 END DO ! SideID
   
 IF(.NOT.doMPISides)THEN
-  CALL GetBoundaryFlux(t,tDeriv, Flux ,U_Minus ,NormVec, TangVec1, TangVec2, BCFace_xGP)
+  CALL GetBoundaryFlux(t,tDeriv,Flux           (1:PP_nVar,0:PP_N,0:PP_N,1:nBCSides) &
+                               ,U_Minus        (1:PP_nVar,0:PP_N,0:PP_N,1:nBCSides) &
+                               ,NormVec        (1:3      ,0:PP_N,0:PP_N,1:nBCSides) &
+                               ,TangVec1       (1:3      ,0:PP_N,0:PP_N,1:nBCSides) &
+                               ,TangVec2       (1:3      ,0:PP_N,0:PP_N,1:nBCSides) &
+                               ,Face_XGP       (1:3      ,0:PP_N,0:PP_N,1:nBCSides) )
 END IF
 
 ! Apply surface element size
diff --git a/src/interpolation/changeBasis.f90 b/src/interpolation/changeBasis.f90
index 50fd7a3..b6a1902 100644
--- a/src/interpolation/changeBasis.f90
+++ b/src/interpolation/changeBasis.f90
@@ -18,12 +18,17 @@ INTERFACE ChangeBasis3D
   MODULE PROCEDURE ChangeBasis3D
 END INTERFACE
 
+INTERFACE ChangeBasis3D_XYZ
+  MODULE PROCEDURE ChangeBasis3D_XYZ
+END INTERFACE
+
 INTERFACE ChangeBasis2D 
   MODULE PROCEDURE ChangeBasis2D
 END INTERFACE
 
 PUBLIC :: ChangeBasis3D
 PUBLIC :: ChangeBasis2D
+PUBLIC :: ChangeBasis3D_XYZ
 !===================================================================================================================================
 
 CONTAINS
@@ -90,6 +95,67 @@ END DO
 END SUBROUTINE ChangeBasis3D
 
 
+SUBROUTINE ChangeBasis3D_XYZ(Dim1,NIn,NOut,Vdm_xi,Vdm_eta,Vdm_zeta,X3D_In,X3D_Out)
+!==================================================================================================================================
+!> Interpolate a 3D tensor product Lagrange polynomial defined by (NIn+1) 1D Lagrange basis functions of order (Nin) and node 
+!> positions xi_In(0:Nin) to another 3D tensor product Lagrange basis defined by (NOut+1) 1D interpolation points on the node
+!> positions xi_out(0:NOut) using DIFFERENT 1D Vdm matrices in the xi,eta and zeta directions.
+!> xi is defined in the 1D referent element \f$ \xi \in [-1,1] \f$.
+!==================================================================================================================================
+! MODULES
+IMPLICIT NONE
+!----------------------------------------------------------------------------------------------------------------------------------
+! INPUT/OUTPUT VARIABLES
+INTEGER,INTENT(IN)  :: Dim1                                    !< Number of variables
+INTEGER,INTENT(IN)  :: NIn                                     !< Input polynomial degree, no. of points = NIn+1
+INTEGER,INTENT(IN)  :: NOut                                    !< Output polynomial degree, no. of points = NOut+1
+REAL,INTENT(IN)     :: X3D_In(1:Dim1,0:NIn,0:NIn,0:NIn)        !< Input field, dimensions must match Dim1,NIn
+REAL,INTENT(OUT)    :: X3D_Out(1:Dim1,0:NOut,0:NOut,0:NOut)    !< Output field, dimensions must match Dim1,NOut
+REAL,INTENT(IN)     :: Vdm_xi(0:NOut,0:NIn)                    !< 1D Vandermonde In -> Out xi direction
+REAL,INTENT(IN)     :: Vdm_eta(0:NOut,0:NIn)                   !< 1D Vandermonde In -> Out eta direction
+REAL,INTENT(IN)     :: Vdm_zeta(0:NOut,0:NIn)                  !< 1D Vandermonde In -> Out zeta direction
+
+!----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER             :: iNIn,jNIn,kNIn,iN_Out,jN_Out,kN_Out
+REAL                :: X3D_Buf1(1:Dim1,0:NOut,0:NIn,0:NIn)     ! first intermediate results from 1D interpolations
+REAL                :: X3D_Buf2(1:Dim1,0:NOut,0:NOut,0:NIn)    ! second intermediate results from 1D interpolations
+!==================================================================================================================================
+X3D_buf1=0.
+! first direction iNIn
+DO kNIn=0,NIn
+  DO jNIn=0,NIn
+    DO iNIn=0,NIn
+      DO iN_Out=0,NOut
+        X3D_Buf1(:,iN_Out,jNIn,kNIn)=X3D_Buf1(:,iN_Out,jNIn,kNIn)+Vdm_xi(iN_Out,iNIn)*X3D_In(:,iNIn,jNIn,kNIn)
+      END DO
+    END DO
+  END DO
+END DO
+X3D_buf2=0.
+! second direction jNIn
+DO kNIn=0,NIn
+  DO jNIn=0,NIn
+    DO jN_Out=0,NOut
+      DO iN_Out=0,NOut
+        X3D_Buf2(:,iN_Out,jN_Out,kNIn)=X3D_Buf2(:,iN_Out,jN_Out,kNIn)+Vdm_eta(jN_Out,jNIn)*X3D_Buf1(:,iN_Out,jNIn,kNIn)
+      END DO
+    END DO
+  END DO
+END DO
+X3D_Out=0.
+! last direction kNIn
+DO kNIn=0,NIn
+  DO kN_Out=0,NOut
+    DO jN_Out=0,NOut
+      DO iN_Out=0,NOut
+        X3D_Out(:,iN_Out,jN_Out,kN_Out)=X3D_Out(:,iN_Out,jN_Out,kN_Out)+Vdm_zeta(kN_Out,kNIn)*X3D_Buf2(:,iN_Out,jN_Out,kNIn)
+      END DO
+    END DO
+  END DO
+END DO
+END SUBROUTINE ChangeBasis3D_XYZ
+
 
 SUBROUTINE ChangeBasis2D(Dim1,N_In,N_Out,Vdm,X2D_In,X2D_Out)
 !===================================================================================================================================
diff --git a/src/interpolation/interpolation.f90 b/src/interpolation/interpolation.f90
index 053c13e..673c435 100644
--- a/src/interpolation/interpolation.f90
+++ b/src/interpolation/interpolation.f90
@@ -25,13 +25,33 @@ INTERFACE FinalizeInterpolation
    MODULE PROCEDURE FinalizeInterpolation
 END INTERFACE
 
+INTERFACE GetNodesAndWeights
+   MODULE PROCEDURE GetNodesAndWeights
+END INTERFACE
+
+INTERFACE GetVandermonde
+   MODULE PROCEDURE GetVandermonde
+END INTERFACE
+
+INTERFACE GetDerivativeMatrix
+   MODULE PROCEDURE GetDerivativeMatrix
+END INTERFACE
+
 INTERFACE ApplyJacobian
    MODULE PROCEDURE ApplyJacobian
 END INTERFACE
 
+INTERFACE InitInterpolationBasis
+   MODULE PROCEDURE InitInterpolationBasis
+END INTERFACE
+
 PUBLIC::InitInterpolation
 PUBLIC::ApplyJacobian
 PUBLIC::FinalizeInterpolation
+PUBLIC::GetNodesAndWeights
+PUBLIC::GetDerivativeMatrix
+PUBLIC::GetVandermonde
+PUBLIC::InitInterpolationBasis
 
 
 !===================================================================================================================================
@@ -71,8 +91,9 @@ SWRITE(UNIT_stdOut,'(A)') ' INIT INTERPOLATION...'
 #if PP_N == N
 PP_N=GETINT('N','2')   ! N could be set by readin_HDF5 routine -> postproctool
 #endif
-CALL initInterpolationBasis(PP_N)
-
+!CALL InitInterpolationBasis(PP_N, xGP ,wGP, swGP,wBary ,L_Minus ,L_Plus , L_PlusMinus, wGPSurf, Vdm_Leg ,sVdm_Leg)
+CALL InitInterpolationBasis(PP_N, xGP ,wGP, wBary ,L_Minus ,L_Plus , L_PlusMinus &
+                           ,swGP=swGP,wGPSurf=wGPSurf)
 
 InterpolationInitIsDone = .TRUE.
 SWRITE(UNIT_stdOut,'(A)')' INIT INTERPOLATION DONE!'
@@ -80,22 +101,32 @@ SWRITE(UNIT_StdOut,'(132("-"))')
 END SUBROUTINE InitInterpolation
 
 
-SUBROUTINE InitInterpolationBasis(N_in)
+SUBROUTINE InitInterpolationBasis(N_in, xGP ,wGP, wBary ,L_Minus ,L_Plus , L_PlusMinus,swGP, wGPSurf, Vdm_Leg ,sVdm_Leg)
 !============================================================================================================================
 ! Initialize basis for Gauss-points of order N. 
+! Calculate positions of Gauss-points, integration weights and barycentric weights. Prepare basis evaluation at -1 and +1.
 ! Prepares Differentiation matrices D, D_Hat, Basis at the boundaries L(1), L(-1), L_Hat(1), L_Hat(-1)
 ! Gaussnodes xGP and weights wGP, wBary 
 !============================================================================================================================
 ! MODULES
 USE MOD_Globals
-USE MOD_Interpolation_Vars,ONLY:xGP,wGP,wBary,L_Minus,L_Plus,StrNodeType,wGPSurf,swGP, L_PlusMinus
-USE MOD_Basis,ONLY:LegendreGaussNodesAndWeights,LegGaussLobNodesAndWeights,ChebyGaussLobNodesAndWeights
-USE MOD_Basis,ONLY:BarycentricWeights,LagrangeInterpolationPolys
+USE MOD_Interpolation_Vars,  ONLY:NodeType
+USE MOD_Basis,               ONLY:LagrangeInterpolationPolys,buildLegendreVdm
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
-INTEGER,INTENT(IN)                         :: N_in
+INTEGER,INTENT(IN)                                  :: N_in
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT)         :: xGP                !< Gauss points in [-1,1]
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT)         :: wGP                !< Integration weights
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT)         :: wBary              !< Barycentric weights
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT)         :: L_Minus            !< Lagrange polynomials at -1
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT)         :: L_Plus             !< Lagrange polynomials at +1
+REAL,ALLOCATABLE,DIMENSION(:,:),INTENT(OUT)         :: L_PlusMinus        !< Vandermonde Nodal->Modal 
+REAL,ALLOCATABLE,DIMENSION(:),  INTENT(OUT),OPTIONAL:: swGP                !< Integration weights
+REAL,ALLOCATABLE,DIMENSION(:,:),INTENT(OUT),OPTIONAL:: wGPSurf            !< Vandermonde Nodal->Modal 
+REAL,ALLOCATABLE,DIMENSION(:,:),INTENT(OUT),OPTIONAL:: Vdm_Leg            !< Vandermonde Nodal->Modal 
+REAL,ALLOCATABLE,DIMENSION(:,:),INTENT(OUT),OPTIONAL:: sVdm_Leg           !< Vandermonde Modal->Nodal
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -107,39 +138,21 @@ ALLOCATE(xGP(0:N_in), wGP(0:N_in), wBary(0:N_in))
 ALLOCATE(L_Minus(0:N_in), L_Plus(0:N_in))
 ALLOCATE(L_PlusMinus(0:N_in,6))
 
-! Compute Nodes and weights for Gauss or GaussLobatto-Nodes
-#if (PP_NodeType==1)
-    StrNodeType='GAUSS'
-    CALL LegendreGaussNodesAndWeights(N_in,xGP,wGP)
-    SWRITE(UNIT_stdOut,'(A)') ' NodeType: GAUSS'
-#elif (PP_NodeType==2)
-    StrNodeType='GAUSS-LOBATTO'
-    CALL LegGaussLobNodesAndWeights(N_in,xGP,wGP)
-    SWRITE(UNIT_stdOut,'(A)') ' NodeType: GAUSS-LOBATTO'
-#elif (PP_NodeType==3)
-    StrNodeType='CHEBYSHEV-GAUSS-LOBATTO'
-    CALL ChebyGaussLobNodesAndWeights(N_in,xGP,wGP)
-    SWRITE(UNIT_stdOut,'(A)') ' NodeType: CHEBYSHEV-GAUSS-LOBATTO'
-    SWRITE(UNIT_stdOut,'(A)') ' WARNING: CGL-nodes NOT fully implemented, Gauss-Nodes used, Enter to continue!'
-    READ(*,*)
-#else
-    SWRITE(UNIT_stdOut,'(A)') ' NodeType NOT implemented'
-    CALL abort(&
-        __STAMP__&
-        ,'Code stopped!',999,999.)
-#endif
-
-CALL BarycentricWeights(N_in,xGP,wBary)
+CALL GetNodesAndWeights(N_in,NodeType,xGP,wGP,wBary)
 
-ALLOCATE(wGPSurf(0:N_in,0:N_in))
-DO i=0,N_in;DO j=0,N_in;
-  wGPSurf(i,j)  = wGP(i)*wGP(j)
-END DO; END DO;
+IF(PRESENT(wGPSurf))THEN
+  ALLOCATE(wGPSurf(0:N_in,0:N_in))
+  DO i=0,N_in;DO j=0,N_in;
+    wGPSurf(i,j)  = wGP(i)*wGP(j)
+  END DO; END DO;
+END IF
 
-ALLOCATE(swGP(0:N_in))
-DO i=0,N_in
-  swGP(i)=1.0/wGP(i)
-END DO ! i
+IF(PRESENT(swGP))THEN
+  ALLOCATE(swGP(0:N_in))
+  DO i=0,N_in
+    swGP(i)=1.0/wGP(i)
+  END DO ! i
+END IF
 
 !! interpolate to left and right face (1 and -1) and pre-divide by mass matrix
 CALL LagrangeInterpolationPolys(1.,N_in,xGP,wBary,L_Plus)
@@ -150,8 +163,179 @@ L_PlusMinus(:,ZETA_MINUS) = L_Minus
 L_PlusMinus(:,  XI_PLUS)  = L_Plus
 L_PlusMinus(:, ETA_PLUS)  = L_Plus
 L_PlusMinus(:,ZETA_PLUS)  = L_Plus
+
+IF(PRESENT(Vdm_Leg).AND.PRESENT(sVdm_Leg))THEN
+! Vandermonde from NODAL <--> MODAL
+ALLOCATE(Vdm_Leg(0:N_in,0:N_in),sVdm_Leg(0:N_in,0:N_in))
+CALL buildLegendreVdm(N_in,xGP,Vdm_Leg,sVdm_Leg)
+END IF
+
 END SUBROUTINE InitInterpolationBasis
 
+
+SUBROUTINE GetNodesAndWeights(N_in,NodeType_in,xIP,wIP,wIPBary)
+!==================================================================================================================================
+! Compute 1D nodes and weights for several node types in interval [-1,1]
+!==================================================================================================================================
+! MODULES
+USE MOD_Globals
+USE MOD_Basis,       ONLY: LegendreGaussNodesAndWeights,LegGaussLobNodesAndWeights,ChebyGaussLobNodesAndWeights,BarycentricWeights
+IMPLICIT NONE
+!----------------------------------------------------------------------------------------------------------------------------------
+! INPUT/OUTPUT VARIABLES
+INTEGER,INTENT(IN)                 :: N_in            !< Polynomial degree
+CHARACTER(LEN=*),INTENT(IN)        :: NodeType_in     !< Type of 1D points
+REAL,INTENT(OUT)                   :: xIP(0:N_in)     !< Position of nodes
+REAL,INTENT(OUT),OPTIONAL          :: wIP(0:N_in)     !< Integration weights
+REAL,INTENT(OUT),OPTIONAL          :: wIPBary(0:N_in) !< Barycentric weights
+!----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER                            :: i
+!==================================================================================================================================
+IF(PRESENT(wIP))THEN
+  SELECT CASE(TRIM(NodeType_in))
+  CASE('GAUSS')
+    CALL LegendreGaussNodesAndWeights(N_in,xIP,wIP)
+  CASE('GAUSS-LOBATTO')
+    CALL LegGaussLobNodesAndWeights(N_in,xIP,wIP)
+  CASE('CHEBYSHEV-GAUSS-LOBATTO')
+    CALL ChebyGaussLobNodesAndWeights(N_in,xIP,wIP)
+  CASE('VISU')
+    DO i=0,N_in
+      xIP(i) = 2.*REAL(i)/REAL(N_in) - 1.
+    END DO
+    ! Trapez rule for integration !!!
+    wIP(:) = 2./REAL(N_in)
+    wIP(0) = 0.5*wIP(0)
+    wIP(N_in) = 0.5*wIP(N_in)
+  CASE('VISU_INNER')
+    DO i=0,N_in
+      xIP(i) = 1./REAL(N_in+1)+2.*REAL(i)/REAL(N_in+1) - 1.
+    END DO
+    ! first order intergration !!!
+    wIP=2./REAL(N_in+1)
+  CASE DEFAULT
+    CALL Abort(__STAMP__,&
+      'NodeType "'//TRIM(NodeType_in)//'" in GetNodesAndWeights not found!')
+  END SELECT
+ELSE
+  SELECT CASE(TRIM(NodeType_in))
+  CASE('GAUSS')
+    CALL LegendreGaussNodesAndWeights(N_in,xIP)
+  CASE('GAUSS-LOBATTO')
+    CALL LegGaussLobNodesAndWeights(N_in,xIP)
+  CASE('CHEBYSHEV-GAUSS-LOBATTO')
+    CALL ChebyGaussLobNodesAndWeights(N_in,xIP)
+  CASE('VISU')
+    DO i=0,N_in
+      xIP(i) = 2.*REAL(i)/REAL(N_in) - 1.
+    END DO
+  CASE('VISU_INNER')
+    DO i=0,N_in
+      xIP(i) = 1./REAL(N_in+1)+2.*REAL(i)/REAL(N_in+1) - 1.
+    END DO
+  CASE DEFAULT
+    CALL Abort(__STAMP__,&
+      'NodeType "'//TRIM(NodeType_in)//'" in GetNodesAndWeights not found!')
+  END SELECT
+END IF !present wIP
+IF(PRESENT(wIPBary)) CALL BarycentricWeights(N_in,xIP,wIPBary)
+END SUBROUTINE GetNodesAndWeights
+
+SUBROUTINE GetVandermonde(N_in,NodeType_in,N_out,NodeType_out,Vdm_In_Out,Vdm_Out_In,modal)
+!==================================================================================================================================
+!> Build a Vandermonde-Matrix from/to different node types and polynomial degrees.
+!==================================================================================================================================
+! MODULES
+USE MOD_Preproc
+USE MOD_Basis,             ONLY:BarycentricWeights,InitializeVandermonde
+IMPLICIT NONE
+!----------------------------------------------------------------------------------------------------------------------------------
+! INPUT/OUTPUT VARIABLES
+INTEGER,INTENT(IN)                 :: N_in                       !> Input polynomial degree
+INTEGER,INTENT(IN)                 :: N_out                      !> Output polynomial degree
+CHARACTER(LEN=255),INTENT(IN)      :: NodeType_in                !> Type of 1D input points
+CHARACTER(LEN=255),INTENT(IN)      :: NodeType_out               !> Type of 1D output points
+LOGICAL,INTENT(IN),OPTIONAL        :: modal                      !> Switch if a modal Vandermonde should be build 
+REAL,INTENT(OUT)                   :: Vdm_In_out(0:N_out,0:N_in) !> Vandermonde In->Out
+REAL,INTENT(OUT),OPTIONAL          :: Vdm_Out_In(0:N_in,0:N_out) !> Vandermonde Out->in
+!----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER                            :: i
+REAL                               :: xIP_in(0:N_in)
+REAL                               :: xIP_out(0:N_out)
+REAL                               :: wBary_in(0:N_in)
+REAL                               :: wBary_out(0:N_out)
+REAL                               ::  Vdm_Leg_in( 0:N_in,0:N_in)
+REAL                               :: sVdm_Leg_in( 0:N_in,0:N_in)
+REAL                               ::  Vdm_Leg_out(0:N_out,0:N_out)
+REAL                               :: sVdm_Leg_out(0:N_out,0:N_out)
+LOGICAL                            :: modalLoc
+!==================================================================================================================================
+modalLoc=.FALSE.
+IF(PRESENT(modal)) modalLoc=modal
+
+! Check if change Basis is needed
+IF((TRIM(NodeType_out).EQ.TRIM(NodeType_in)).AND.(N_in.EQ.N_out))THEN
+  Vdm_In_Out=0.
+  DO i=0,N_in
+    Vdm_In_out(i,i)=1.
+  END DO
+  IF(PRESENT(Vdm_Out_In))THEN
+    Vdm_Out_In=0.
+    DO i=0,N_Out
+      Vdm_Out_In(i,i)=1.
+    END DO
+  END IF
+ELSE
+  ! Input points
+  CALL GetNodesAndWeights(N_in,NodeType_in,xIP_in)
+  CALL BarycentricWeights(N_in,xIP_in,wBary_in)
+  ! Output points
+  CALL GetNodesAndWeights(N_out,NodeType_out,xIP_out)
+
+  IF(modalLoc)THEN
+    CALL buildLegendreVdm(N_In, xIP_in, Vdm_Leg_in, sVdm_Leg_in)
+    CALL buildLegendreVdm(N_Out,xIP_out,Vdm_Leg_out,sVdm_Leg_out)
+  END IF
+
+  IF((N_Out.LT.N_In).AND.modalLoc)THEN
+    Vdm_In_Out=MATMUL(Vdm_Leg_Out(0:N_Out,0:N_Out),sVdm_Leg_In(0:N_Out,0:N_In))
+  ELSE
+    CALL InitializeVandermonde(N_in,N_out,wBary_in,xIP_in,xIP_out,Vdm_In_Out)
+  END IF
+  IF(PRESENT(Vdm_Out_In))THEN
+    IF((N_In.LT.N_Out).AND.modalLoc)THEN
+      Vdm_Out_In=MATMUL(Vdm_Leg_In(0:N_In,0:N_In),sVdm_Leg_Out(0:N_In,0:N_Out))
+    ELSE
+      CALL BarycentricWeights(N_out,xIP_out,wBary_out)
+      CALL InitializeVandermonde(N_out,N_in,wBary_out,xIP_out,xIP_in,Vdm_Out_In)
+    END IF
+  END IF
+END IF
+END SUBROUTINE GetVandermonde
+
+SUBROUTINE GetDerivativeMatrix(N_in,NodeType_in,D)
+!==================================================================================================================================
+!> Compute polynomial derivative matrix. D(i,j) = Derivative of basis function j evaluated at node point i. 
+!==================================================================================================================================
+! MODULES
+USE MOD_Basis,             ONLY:PolynomialDerivativeMatrix
+IMPLICIT NONE
+!----------------------------------------------------------------------------------------------------------------------------------
+! INPUT/OUTPUT VARIABLES
+INTEGER,INTENT(IN)                 :: N_in                       !< Polynomial degree
+CHARACTER(LEN=255),INTENT(IN)      :: NodeType_in                !< Type of 1D input points
+REAL,INTENT(OUT)                   :: D(0:N_in,0:N_in)           !< Derivative matrix
+!----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+REAL                               :: xIP(0:N_in)
+!==================================================================================================================================
+CALL GetNodesAndWeights(N_in,NodeType_in,xIP)
+CALL PolynomialDerivativeMatrix(N_in,xIP,D)
+END SUBROUTINE GetDerivativeMatrix
+
+
 SUBROUTINE ApplyJacobian(U,toPhysical,toSwap)
 !===================================================================================================================================
 ! Convert solution between physical <-> reference space
diff --git a/src/interpolation/interpolation_vars.f90 b/src/interpolation/interpolation_vars.f90
index b108da3..24bdddd 100644
--- a/src/interpolation/interpolation_vars.f90
+++ b/src/interpolation/interpolation_vars.f90
@@ -19,7 +19,18 @@ REAL,ALLOCATABLE  :: swGP(:)                     ! 1.0/ GP integration weights
 REAL,ALLOCATABLE  :: wBary(:)                    ! barycentric weights
 REAL,ALLOCATABLE  :: wGPSurf(:,:)                ! wGPSurf(i,j)=wGP(i)*wGP(j)
 REAL,ALLOCATABLE  :: NChooseK(:,:)               ! array n over n
-CHARACTER(LEN=255)::StrNodeType
+REAL,ALLOCATABLE  :: Vdm_Leg(:,:), sVdm_Leg(:,:) !< Legendre Vandermonde matrix
+CHARACTER(LEN=255),PARAMETER :: NodeTypeG    = 'GAUSS'                    !< Gauss nodes (-1,1)
+CHARACTER(LEN=255),PARAMETER :: NodeTypeGL   = 'GAUSS-LOBATTO'            !< Gauss-Lobatto nodes [-1,1]
+CHARACTER(LEN=255),PARAMETER :: NodeTypeCL   = 'CHEBYSHEV-GAUSS-LOBATTO'  
+CHARACTER(LEN=255),PARAMETER :: NodeTypeVISU = 'VISU'                     !< equidistant nodes [-1,1]
+#if (PP_NodeType==1)
+  CHARACTER(LEN=255),PARAMETER :: NodeType = 'GAUSS'
+#elif (PP_NodeType==2)
+  CHARACTER(LEN=255),PARAMETER :: NodeType = 'GAUSS-LOBATTO'
+#elif (PP_NodeType==3)
+  CHARACTER(LEN=255),PARAMETER :: NodeType = 'CHEBYSHEV-GAUSS-LOBATTO'
+#endif
 !===================================================================================================================================
 
 LOGICAL           :: InterpolationInitIsDone = .FALSE.
diff --git a/src/linearsolver/newton.f90 b/src/linearsolver/newton.f90
index 7e3b53d..6749ce6 100644
--- a/src/linearsolver/newton.f90
+++ b/src/linearsolver/newton.f90
@@ -136,7 +136,6 @@ USE MOD_LinearSolver_Vars,       ONLY:Eps_FullNewton,Eps2_FullNewton,FullEisenst
 USE MOD_LinearSolver_Vars,       ONLY:Eps2PartNewton,UpdateInIter
 USE MOD_Particle_Vars,           ONLY:PartIsImplicit
 USE MOD_Particle_Vars,           ONLY:PartState, Pt, LastPartPos, DelayTime, PEM, PDM
-USE MOD_Particle_Tracking,       ONLY:ParticleTrackingCurved,ParticleRefTracking
 USE MOD_Part_RHS,                ONLY:PartVeloToImp
 USE MOD_PICInterpolation,        ONLY:InterpolateFieldToSingleParticle
 USE MOD_PICInterpolation_Vars,   ONLY:FieldAtParticle
@@ -189,13 +188,6 @@ IF (t.GE.DelayTime) THEN
 #ifdef MPI
   ! open receive buffer for number of particles
   CALL IRecvNbofParticles()
-#endif /*MPI*/
-!  IF(DoRefMapping)THEN
-!    CALL ParticleRefTracking(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!  ELSE
-!    CALL ParticleTrackingCurved(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!  END IF
-#ifdef MPI
   ! here: could use deposition as hiding, not done yet
   ! send number of particles
   CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
@@ -285,13 +277,6 @@ DO WHILE ((nFullNewtonIter.LE.maxFullNewtonIter).AND.(.NOT.IsConverged))
 #ifdef MPI
     ! open receive buffer for number of particles
     CALL IRecvNbofParticles()
-#endif /*MPI*/
-!    IF(DoRefMapping)THEN
-!      CALL ParticleRefTracking(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!    ELSE
-!      CALL ParticleTrackingCurved(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!    END IF
-#ifdef MPI
     ! here: could use deposition as hiding, not done yet
     ! send number of particles
     CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
@@ -361,7 +346,6 @@ USE MOD_LinearSolver_Vars,       ONLY:Eps_FullNewton,Eps2_FullNewton,FullEisenst
 USE MOD_LinearSolver_Vars,       ONLY:Eps2PartNewton
 USE MOD_Particle_Vars,           ONLY:PartIsImplicit
 USE MOD_Particle_Vars,           ONLY:PartState, Pt, LastPartPos, DelayTime, PEM, PDM
-USE MOD_Particle_Tracking,       ONLY:ParticleTrackingCurved,ParticleRefTracking
 USE MOD_Part_RHS,                ONLY:PartVeloToImp
 USE MOD_PICInterpolation,        ONLY:InterpolateFieldToSingleParticle
 USE MOD_PICInterpolation_Vars,   ONLY:FieldAtParticle
@@ -412,13 +396,6 @@ IF (t.GE.DelayTime) THEN
 #ifdef MPI
   ! open receive buffer for number of particles
   CALL IRecvNbofParticles()
-#endif /*MPI*/
-!  IF(DoRefMapping)THEN
-!    CALL ParticleRefTracking(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!  ELSE
-!    CALL ParticleTrackingCurved(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!  END IF
-#ifdef MPI
   ! here: could use deposition as hiding, not done yet
   ! send number of particles
   CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
@@ -502,13 +479,6 @@ DO WHILE ((nFullNewtonIter.LE.maxFullNewtonIter).AND.(Norm_R.GT.Norm_R0*Eps2_Ful
 #ifdef MPI
     ! open receive buffer for number of particles
     CALL IRecvNbofParticles()
-#endif /*MPI*/
-!    IF(DoRefMapping)THEN
-!      CALL ParticleRefTracking(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!    ELSE
-!      CALL ParticleTrackingCurved(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
-!    END IF
-#ifdef MPI
     ! here: could use deposition as hiding, not done yet
     ! send number of particles
     CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
diff --git a/src/linearsolver/particlesolver.f90 b/src/linearsolver/particlesolver.f90
index 88742c2..0a3af2c 100644
--- a/src/linearsolver/particlesolver.f90
+++ b/src/linearsolver/particlesolver.f90
@@ -184,7 +184,7 @@ USE MOD_Particle_Vars,           ONLY:PartState, Pt, LastPartPos, DelayTime, PEM
 USE MOD_TimeDisc_Vars,           ONLY:dt,iter
 USE MOD_PICInterpolation,        ONLY:InterpolateFieldToParticle
 USE MOD_LinearOperator,          ONLY:PartVectorDotProduct
-USE MOD_Particle_Tracking,       ONLY:ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY:ParticleTracing,ParticleRefTracking
 USE MOD_Particle_Tracking_vars,  ONLY:DoRefMapping
 USE MOD_Part_RHS,                ONLY:CalcPartRHS
 #ifdef MPI
@@ -366,7 +366,7 @@ DO WHILE((DoNewton) .AND. (nInnerPartNewton.LT.nPartNewtonIter))  ! maybe change
       CALL ParticleRefTracking(doParticle_In=DoPartInNewton(1:PDM%ParticleVecLength)) 
     ELSE
       ! input value: which list:DoPartInNewton or PDM%ParticleInisde?
-      CALL ParticleTrackingCurved(doParticle_In=DoPartInNewton(1:PDM%ParticleVecLength)) 
+      CALL ParticleTracing(doParticle_In=DoPartInNewton(1:PDM%ParticleVecLength)) 
     END IF
 #ifdef MPI
     ! send number of particles
diff --git a/src/mesh/mapping.f90 b/src/mesh/mapping.f90
index fd95bc1..643198a 100644
--- a/src/mesh/mapping.f90
+++ b/src/mesh/mapping.f90
@@ -29,6 +29,10 @@ INTERFACE CGNS_SideToVol
   MODULE PROCEDURE CGNS_SideToVol
 END INTERFACE
 
+INTERFACE CGNS_SideToVol2
+  MODULE PROCEDURE CGNS_SideToVol2
+END INTERFACE
+
 INTERFACE CGNS_VolToSide
   MODULE PROCEDURE CGNS_VolToSide
 END INTERFACE
@@ -53,6 +57,7 @@ PUBLIC::InitMappings
 PUBLIC::Flip_S2M
 PUBLIC::Flip_M2S
 PUBLIC::CGNS_SideToVol
+PUBLIC::CGNS_SideToVol2
 PUBLIC::CGNS_VolToSide
 PUBLIC::SideToVol
 PUBLIC::VolToSide
diff --git a/src/mesh/mesh.f90 b/src/mesh/mesh.f90
index 87ba05b..9d18895 100644
--- a/src/mesh/mesh.f90
+++ b/src/mesh/mesh.f90
@@ -142,9 +142,6 @@ PP_nElems=nElems
 SWRITE(UNIT_stdOut,'(A)') "NOW CALLING setLocalSideIDs..."
 CALL setLocalSideIDs()
 
-ALLOCATE(XCL_NGeo(3,0:NGeo,0:NGeo,0:NGeo,nElems))
-XCL_NGeo = 0.
-
 #ifdef MPI
 ! for MPI, we need to exchange flips, so that MINE MPISides have flip>0, YOUR MpiSides flip=0
 SWRITE(UNIT_stdOut,'(A)') "NOW CALLING exchangeFlip..."
@@ -224,22 +221,22 @@ IF(GETLOGICAL('meshdeform','.FALSE.'))THEN
   END DO
 END IF
 
-
-ALLOCATE(Elem_xGP(3,0:PP_N,0:PP_N,0:PP_N,nElems))
-ALLOCATE(BCFace_xGP(3,0:PP_N,0:PP_N,1:nBCSides))
-
-! PoyntingVecIntegral
-CalcPoyntingInt = GETLOGICAL('CalcPoyntingVecIntegral','.FALSE.')
-IF (CalcPoyntingInt) ALLOCATE(Face_xGP(3,0:PP_N,0:PP_N,1:nSides))
-
+! allocate type Mesh
+ALLOCATE(Elem_xGP      (3,0:PP_N,0:PP_N,0:PP_N,nElems))
+ALLOCATE(Face_xGP      (3,0:PP_N,0:PP_N,1:nSides))
 ALLOCATE(Metrics_fTilde(3,0:PP_N,0:PP_N,0:PP_N,nElems))
 ALLOCATE(Metrics_gTilde(3,0:PP_N,0:PP_N,0:PP_N,nElems))
 ALLOCATE(Metrics_hTilde(3,0:PP_N,0:PP_N,0:PP_N,nElems))
-ALLOCATE(            sJ(  0:PP_N,0:PP_N,0:PP_N,nElems))
-ALLOCATE(       NormVec(3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper)) 
-ALLOCATE(      TangVec1(3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper)) 
-ALLOCATE(      TangVec2(3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper))  
-ALLOCATE(      SurfElem(  0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper))  
+ALLOCATE(sJ            (  0:PP_N,0:PP_N,0:PP_N,nElems))
+ALLOCATE(NormVec       (3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper)) 
+ALLOCATE(TangVec1      (3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper)) 
+ALLOCATE(TangVec2      (3,0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper))  
+ALLOCATE(SurfElem      (  0:PP_N,0:PP_N,sideID_minus_lower:sideID_minus_upper))  
+
+! PoyntingVecIntegral
+CalcPoyntingInt = GETLOGICAL('CalcPoyntingVecIntegral','.FALSE.')
+NGeoRef=3*NGeo ! build jacobian at higher degree
+ALLOCATE(    DetJac_Ref(1,0:NgeoRef,0:NgeoRef,0:NgeoRef,nElems))
 
 ! assign all metrics Metrics_fTilde,Metrics_gTilde,Metrics_hTilde
 ! assign 1/detJ (sJ)
@@ -264,17 +261,23 @@ SideBoundingBoxVolume=0.
 crossProductMetrics=GETLOGICAL('crossProductMetrics','.FALSE.')
 SWRITE(UNIT_stdOut,'(A)') "NOW CALLING calcMetrics..."
 CALL InitMeshBasis(NGeo,PP_N,xGP)
-CALL CalcMetrics(NodeCoords)
-DEALLOCATE(NodeCoords)
 
+! to be moved to Mesh 
 CALL InitMappings(PP_N,VolToSideA,VolToSideIJKA,VolToSide2A,CGNS_VolToSideA, &
                        SideToVolA,SideToVol2A,CGNS_SideToVol2A)
-#ifndef PARTICLES
-DEALLOCATE(XCL_NGeo)
-#else
+
+#ifdef PARTICLES
+ALLOCATE(XCL_NGeo(3,0:NGeo,0:NGeo,0:NGeo,nElems))
+XCL_NGeo = 0.
+ALLOCATE(dXCL_NGeo(3,3,0:NGeo,0:NGeo,0:NGeo,nElems))
+dXCL_NGeo = 0.
+CALL CalcMetrics(NodeCoords,XCL_NGeo_Out=XCL_NGeo,dXCL_NGeo_Out=dXCL_NGeo)
 ! init element volume
 CALL InitElemVolumes()
+#else
+CALL CalcMetrics(NodeCoords,Mesh)
 #endif
+DEALLOCATE(NodeCoords)
 
 MeshInitIsDone=.TRUE.
 SWRITE(UNIT_stdOut,'(A)')' INIT MESH DONE!'
@@ -618,7 +621,6 @@ SDEALLOCATE(SideToElem)
 SDEALLOCATE(SideToElem2)
 SDEALLOCATE(BC)
 SDEALLOCATE(Elem_xGP)
-SDEALLOCATE(BCFace_xGP)
 SDEALLOCATE(Metrics_fTilde)
 SDEALLOCATE(Metrics_gTilde)
 SDEALLOCATE(Metrics_hTilde)
diff --git a/src/mesh/mesh_vars.f90 b/src/mesh/mesh_vars.f90
index 716eb30..a5c1c8d 100644
--- a/src/mesh/mesh_vars.f90
+++ b/src/mesh/mesh_vars.f90
@@ -20,6 +20,8 @@ INTEGER           :: SwapMeshLevel                ! 0: initial grid, 1: first sw
 ! basis
 !-----------------------------------------------------------------------------------------------------------------------------------
 INTEGER          :: NGeo                        ! polynomial degree of geometric transformation
+INTEGER          :: NGeoRef                     ! polynomial degree of geometric transformation
+INTEGER          :: NGeoElevated                ! polynomial degree of elevated geometric transformation
 REAL,ALLOCATABLE :: Xi_NGeo(:)                  ! 1D equidistant point positions for curved elements (during readin)
 REAL             :: DeltaXi_NGeo
 REAL,ALLOCATABLE :: Vdm_CLN_GaussN(:,:)
@@ -32,7 +34,7 @@ REAL,ALLOCATABLE :: DCL_N(:,:)
 ! GLOBAL VARIABLES 
 !-----------------------------------------------------------------------------------------------------------------------------------
 REAL,ALLOCATABLE :: Elem_xGP(:,:,:,:,:)   ! XYZ positions (first index 1:3) of the volume Gauss Point
-REAL,ALLOCATABLE :: BCFace_xGP(:,:,:,:)   ! XYZ positions (first index 1:3) of the Boundary Face Gauss Point
+REAL,ALLOCATABLE :: Face_xGP(:,:,:,:)   ! XYZ positions (first index 1:3) of the Boundary Face Gauss Point
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! Metrics on GaussPoints 
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -53,6 +55,7 @@ LOGICAL,ALLOCATABLE :: CurvedElem(:)
 REAL,ALLOCATABLE    :: XiCL_NGeo(:)
 REAL,ALLOCATABLE    :: XCL_NGeo(:,:,:,:,:)
 REAL,ALLOCATABLE    :: dXCL_NGeo(:,:,:,:,:,:) !jacobi matrix of the mapping P\in NGeo
+REAL,ALLOCATABLE    :: detJac_Ref(:,:,:,:,:)      !< determinant of the mesh Jacobian for each Gauss point at degree 3*NGeo
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! surface vectors 
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -116,7 +119,6 @@ LOGICAL          :: CrossProductMetrics=.FALSE.
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! PoyntingVectorIntegral variables
 !-----------------------------------------------------------------------------------------------------------------------------------
-REAL,ALLOCATABLE    :: Face_xGP(:,:,:,:)     ! XYZ positions (first index 1:3) of the Face Gauss Point
 INTEGER             :: nPoyntingIntSides=0   ! Sides for the calculation of the poynting vector
 LOGICAL,ALLOCATABLE :: isPoyntingIntSide(:)  ! number of all PoyntingInt sides
 INTEGER,ALLOCATABLE :: whichPoyntingPlane(:) ! number of plane used for calculation of poynting vector
diff --git a/src/mesh/metrics.f90 b/src/mesh/metrics.f90
index 4a89543..53cfa48 100644
--- a/src/mesh/metrics.f90
+++ b/src/mesh/metrics.f90
@@ -41,7 +41,7 @@ PUBLIC::CalcMetrics
 
 CONTAINS
 
-SUBROUTINE CalcMetrics(NodeCoords)
+SUBROUTINE CalcMetrics(NodeCoords,XCL_NGeo_Out,dXCL_NGeo_out)
 !===================================================================================================================================
 ! calculate the Volume Metric terms
 !           Metrics_fTilde(n=1:3) 
@@ -68,154 +68,232 @@ SUBROUTINE CalcMetrics(NodeCoords)
 ! MODULES
 USE MOD_Globals
 USE MOD_PreProc
-USE MOD_Mesh_Vars,               ONLY:NGeo,dXCL_NGeo,XCL_NGeo,Vdm_NGeo_CLNGeo
-USE MOD_Mesh_Vars,               ONLY:Vdm_CLNGeo_CLN,Vdm_CLN_GaussN
-USE MOD_Mesh_Vars,               ONLY:DCL_NGeo,DCL_N
+USE MOD_Mesh_Vars,               ONLY:NGeo,NGeoRef
 USE MOD_Mesh_Vars,               ONLY:sJ,Metrics_fTilde,Metrics_gTilde,Metrics_hTilde,Elem_xGP,crossProductMetrics
+USE MOD_Mesh_Vars,               ONLY:Face_xGP,normVec,surfElem,TangVec1,TangVec2
 USE MOD_Mesh_Vars,               ONLY:nElems,sideID_minus_upper,nBCSides
+USE MOD_Mesh_Vars,               ONLY:detJac_Ref
+USE MOD_Mesh_Vars,               ONLY:crossProductMetrics
+USE MOD_Mesh_Vars,               ONLY:nElems,sideID_minus_upper,nBCSides
+USE MOD_Interpolation,           ONLY:GetVandermonde,GetNodesAndWeights,GetDerivativeMatrix
+USE MOD_ChangeBasis,             ONLY:changeBasis3D,ChangeBasis3D_XYZ
+USE MOD_Basis,                   ONLY:LagrangeInterpolationPolys
+USE MOD_Interpolation_Vars,      ONLY:NodeTypeG,NodeTypeGL,NodeTypeCL,NodeTypeVISU
 #ifdef PARTICLES
-!USE MOD_Particle_Surfaces,       ONLY:GetSuperSampledSurface,GetBezierControlPoints3D!,GetSideType
+USE MOD_Mesh_Vars,               ONLY:NGeoElevated
+USE MOD_Particle_Surfaces,       ONLY:GetSideSlabNormalsAndIntervals
 USE MOD_Particle_Surfaces,       ONLY:GetBezierControlPoints3D
-USE MOD_Particle_Surfaces_Vars,  ONLY:BezierControlPoints3D
 USE MOD_Particle_Tracking_Vars,  ONLY:DoRefMapping
+USE MOD_Mesh_Vars,               ONLY:nBCSides,nInnerSides,nMPISides_MINE
+USE MOD_Particle_Surfaces_vars,  ONLY:BezierControlPoints3D,SideSlabIntervals,BezierControlPoints3DElevated &
+                                        ,SideSlabIntervals,SideSlabNormals,BoundingBoxIsEmpty
+#ifdef MPI
+USE MOD_Particle_MPI_Vars,       ONLY:PartMPI
+#endif /*MPI*/
 #endif /*PARTICLES*/
 !-----------------------------------------------------------------------------------------------------------------------------------
-USE MOD_ChangeBasis,        ONLY:changeBasis3D
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
-REAL,INTENT(IN)    :: NodeCoords(3,0:NGeo,0:NGeo,0:NGeo,nElems)
+!INTEGER,INTENT(IN)         :: PP_N
+REAL,INTENT(IN)             :: NodeCoords(3,0:NGeo,0:NGeo,0:NGeo,nElems)
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
+REAL,INTENT(INOUT),OPTIONAL  :: XCL_Ngeo_Out(1:3,0:Ngeo,0:Ngeo,0:Ngeo,nElems)      ! mapping X(xi) P\in Ngeo
+REAL ,INTENT(INOUT),OPTIONAL :: dXCL_Ngeo_Out(1:3,1:3,0:Ngeo,0:Ngeo,0:Ngeo,nElems)   ! jacobi matrix on CL Ngeo
+!
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-INTEGER            :: i,j,k,q,iElem
-INTEGER            :: dd,ee,ff
-INTEGER            :: nn,mm,ll
-INTEGER            :: iGeo,jGeo,kGeo,lGeo
-INTEGER            :: Cyclic(5),CycIJK(3),Cyc(3)
-REAL               :: XCL_NGeo_loc(3,0:NGeo,0:NGeo,0:NGeo)    !mapping X(xi) P\in NGeo
-REAL               :: DetJacCL_N(1,0:PP_N,0:PP_N,0:PP_N)
-REAL               :: DetJacGauss_N(1,0:PP_N,0:PP_N,0:PP_N)
-REAL               :: XCL_N(3,0:PP_N,0:PP_N,0:PP_N)       ! mapping X(xi) P\in N
-REAL               :: dXCL_N(3,3,0:PP_N,0:PP_N,0:PP_N)    !jacobi matrix interpolated on P\in N
-REAL               :: R_CL_N(3,3,0:PP_N,0:PP_N,0:PP_N)    ! buffer for metric terms, uses XCL_N,dXCL_N 
-REAL               :: JaCL_N(3,3,0:PP_N,0:PP_N,0:PP_N)    ! metric terms P\in N
-REAL               :: scaledJac(2)
+INTEGER :: i,j,k,q,iElem
+INTEGER :: dd,ee,ff
+INTEGER :: nn,mm,ll
+INTEGER :: Cyclic(5),CycIJK(3),Cyc(3)
+! Jacobian on CL N and NGeoRef
+REAL    :: DetJac_N( 1,0:PP_N,   0:PP_N,   0:PP_N)
+REAL    :: tmp(      1,0:NgeoRef,0:NgeoRef,0:NgeoRef)
+!REAL    :: tmp2(     1,0:Ngeo,0:Ngeo,0:Ngeo)
+! interpolation points and derivatives on CL N
+REAL    :: XCL_N(      3,  0:PP_N,0:PP_N,0:PP_N)          ! mapping X(xi) P\in N
+REAL    :: XCL_Ngeo(   3,  0:Ngeo,0:Ngeo,0:Ngeo)          ! mapping X(xi) P\in Ngeo
+REAL    :: XCL_N_quad( 3,  0:PP_N,0:PP_N,0:PP_N)          ! mapping X(xi) P\in N
+REAL    :: dXCL_N(     3,3,0:PP_N,0:PP_N,0:PP_N)          ! jacobi matrix on CL N
+REAL    :: dXCL_Ngeo(  3,3,0:Ngeo,0:Ngeo,0:Ngeo)          ! jacobi matrix on CL Ngeo
+REAL    :: dX_NgeoRef( 3,3,0:NgeoRef,0:NgeoRef,0:NgeoRef) ! jacobi matrix on SOL NgeoRef
+
+REAL    :: R_CL_N(     3,3,0:PP_N,0:PP_N,0:PP_N)    ! buffer for metric terms, uses XCL_N,dXCL_N
+REAL    :: JaCL_N(     3,3,0:PP_N,0:PP_N,0:PP_N)    ! metric terms P\in N
+REAL    :: JaCL_N_quad(3,3,0:PP_N,0:PP_N,0:PP_N)    ! metric terms P\in N
+REAL    :: scaledJac(2)
+
+! Polynomial derivativion matrices
+REAL    :: DCL_NGeo(0:Ngeo,0:Ngeo)
+REAL    :: DCL_N(   0:PP_N,0:PP_N)
+
+! Vandermonde matrices (N_OUT,N_IN)
+REAL    :: Vdm_EQNgeo_CLNgeo( 0:Ngeo   ,0:Ngeo)
+REAL    :: Vdm_CLNGeo_NgeoRef(0:NgeoRef,0:Ngeo)
+REAL    :: Vdm_NgeoRef_N(     0:PP_N   ,0:NgeoRef)
+REAL    :: Vdm_CLNGeo_CLN(    0:PP_N   ,0:Ngeo)
+REAL    :: Vdm_CLN_N(         0:PP_N   ,0:PP_N)
+
+! 3D Vandermonde matrices and lengths,nodes,weights
+REAL,DIMENSION(0:NgeoRef,0:NgeoRef) :: Vdm_xi_Ref,Vdm_eta_Ref,Vdm_zeta_Ref
+REAL,DIMENSION(0:PP_N   ,0:PP_N)    :: Vdm_xi_N  ,Vdm_eta_N  ,Vdm_zeta_N
+REAL    :: xiRef( 0:NgeoRef),wBaryRef( 0:NgeoRef)
+REAL    :: xiCL_N(0:PP_N)   ,wBaryCL_N(0:PP_N)
+REAL    :: xi0(3),dxi(3),length(3)
+
 #ifdef PARTICLES
 INTEGER            :: iSide,lowerLimit
+REAL               :: StartT2,BezierTime
 #endif /*PARTICLES*/
 REAL               :: StartT,EndT
 !===================================================================================================================================
 
 
-StartT=BOLTZPLATZTIME(MPI_COMM_WORLD)
-ALLOCATE(dXCL_NGeo(3,3,0:NGeo,0:NGeo,0:NGeo,1:PP_nElems)) !jacobi matrix of the mapping P\in NGeo
-! null outside!!
-dXCL_NGeo=0.
+StartT=BOLTZPLATZTIME()
+#ifdef PARTICLES
+BezierTime=0.
+#endif
+
 ! Prerequisites
 Metrics_fTilde=0.
 Metrics_gTilde=0.
 Metrics_hTilde=0.
-
 ! 
 Cyclic=(/1,2,3,1,2/)
+
+! Initialize Vandermonde and D matrices
+! Only use modal Vandermonde for terms that need to be conserved as Jacobian if N_out>PP_N
+! Always use interpolation for the rest!
+
+! 1.a) NodeCoords: EQUI Ngeo to CLNgeo and CLN
+CALL GetVandermonde(    Ngeo   , NodeTypeVISU, Ngeo    , NodeTypeCL, Vdm_EQNgeo_CLNgeo , modal=.FALSE.)
+
+! 1.b) dXCL_Ngeo:
+CALL GetDerivativeMatrix(Ngeo  , NodeTypeCL  , DCL_Ngeo)
+
+! 1.c) Jacobian: CLNgeo to NgeoRef, CLNgeoRef to N
+CALL GetVandermonde(    Ngeo   , NodeTypeCL  , NgeoRef , NodeType  , Vdm_CLNgeo_NgeoRef, modal=.FALSE.)
+CALL GetVandermonde(    NgeoRef, NodeType    , PP_N    , NodeType  , Vdm_NgeoRef_N     , modal=.TRUE.)
+CALL GetNodesAndWeights(NgeoRef, NodeType    , xiRef   , wIPBary=wBaryRef)
+
+! 1.d) derivatives (dXCL) by projection or by direct derivation (D_CL):
+CALL GetVandermonde(    Ngeo   , NodeTypeCL  , PP_N    , NodeTypeCL, Vdm_CLNgeo_CLN    , modal=.FALSE.)
+CALL GetDerivativeMatrix(PP_N  , NodeTypeCL  , DCL_N)
+
+! 2.d) derivatives (dXCL) by projection or by direct derivation (D_CL):
+CALL GetVandermonde(    PP_N   , NodeTypeCL  , PP_N    , NodeType,   Vdm_CLN_N         , modal=.FALSE.)
+CALL GetNodesAndWeights(PP_N   , NodeTypeCL  , xiCL_N  , wIPBary=wBaryCL_N)
+
 ! Outer loop over all elements
+detJac_Ref=0.
 DO iElem=1,nElems
-  !from equidistant to CL, save in global array XCL_NGEO for particle tracking
-  CALL ChangeBasis3D(3,NGeo,NGeo,Vdm_NGeo_CLNGeo,NodeCoords(:,:,:,:,iElem),XCL_NGeo(:,:,:,:,iElem))
-  XCL_NGeo_loc(:,:,:,:)=XCL_NGeo(:,:,:,:,iElem)
-  !1.a) Jacobi Matrix of d/dxi_dd(X_nn): dXCL_NGeo(dd,nn,i,j,k,iElem)) 
-  R_CL_N=0.
-  dXCL_N=0.
-  detJacCL_N=0.
-  JaCL_N=0.
-  DO nn=1,3
+  !1.a) Transform from EQUI_Ngeo to CL points on Ngeo and N
+  !IF(interpolateFromTree)THEN
+  !  xi0   =xiMinMax(:,1,iElem)
+  !  length=xiMinMax(:,2,iElem)-xi0
+  !  CALL ChangeBasis3D(3,NGeo,NGeo,Vdm_EQNGeo_CLNGeo,TreeCoords(:,:,:,:,ElemToTree(iElem)),XCL_Ngeo)
+  !ELSE
+    CALL ChangeBasis3D(3,NGeo,NGeo,Vdm_EQNGeo_CLNGeo,NodeCoords(:,:,:,:,iElem)            ,XCL_Ngeo)
+  !END IF
+  CALL   ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,   XCL_Ngeo                             ,XCL_N)
+
+  !1.b) Jacobi Matrix of d/dxi_dd(X_nn): dXCL_NGeo(dd,nn,i,j,k))
+  dXCL_NGeo=0.
+  DO k=0,Ngeo; DO j=0,Ngeo; DO i=0,Ngeo
+    ! Matrix-vector multiplication
+    DO ll=0,Ngeo
+      dXCL_Ngeo(1,:,i,j,k)=dXCL_Ngeo(1,:,i,j,k) + DCL_Ngeo(i,ll)*XCL_Ngeo(:,ll,j,k)
+      dXCL_Ngeo(2,:,i,j,k)=dXCL_Ngeo(2,:,i,j,k) + DCL_Ngeo(j,ll)*XCL_Ngeo(:,i,ll,k)
+      dXCL_Ngeo(3,:,i,j,k)=dXCL_Ngeo(3,:,i,j,k) + DCL_Ngeo(k,ll)*XCL_Ngeo(:,i,j,ll)
+    END DO !l=0,N
+  END DO; END DO; END DO !i,j,k=0,Ngeo
+
+  ! 1.c)Jacobians! grad(X_1) (grad(X_2) x grad(X_3))
+  ! Compute Jacobian on NGeo and then interpolate:
+  ! required to guarantee conservativity when restarting with N<NGeo
+  CALL ChangeBasis3D(3,Ngeo,NgeoRef,Vdm_CLNGeo_NgeoRef,dXCL_NGeo(:,1,:,:,:),dX_NgeoRef(:,1,:,:,:))
+  CALL ChangeBasis3D(3,Ngeo,NgeoRef,Vdm_CLNGeo_NgeoRef,dXCL_NGeo(:,2,:,:,:),dX_NgeoRef(:,2,:,:,:))
+  CALL ChangeBasis3D(3,Ngeo,NgeoRef,Vdm_CLNGeo_NgeoRef,dXCL_NGeo(:,3,:,:,:),dX_NgeoRef(:,3,:,:,:))
+  DO k=0,NgeoRef; DO j=0,NgeoRef; DO i=0,NgeoRef
     DO dd=1,3
-      DO kGeo=0,NGeo
-                      CycIJK(3)=kGeo
-        DO jGeo=0,NGeo
-                        CycIJK(2)=jGeo
-          DO iGeo=0,NGeo
-                          CycIJK(1)=iGeo
-            ! Matrix-vector multiplication
-            Cyc=CycIJK
-            DO lGeo=0,NGeo
-              Cyc(dd)=lGeo   !d/dxi_dd 
-              dXCL_NGeo(dd,nn,iGeo,jGeo,kGeo,iElem)=dXCL_NGeo(dd,nn,iGeo,jGeo,kGeo,iElem) + &
-                                               DCL_NGeo(CycIJK(dd),lGeo)*XCL_NGeo_loc( nn ,Cyc(1),Cyc(2),Cyc(3))
-            END DO !lGeo=0,NGeo
-          END DO !iGeo=0,NGeo
-        END DO !jGeo=0,NGeo
-      END DO !kGeo=0,NGeo
-    END DO !dd=1,3
-  END DO !nn=1,3
-  ! Interpolate the gradient of the mapping (living in a NGeo world) to the N (Cheb Lob) world
-  CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,1,:,:,:,iElem),dXCL_N(:,1,:,:,:))
-  CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,2,:,:,:,iElem),dXCL_N(:,2,:,:,:))
-  CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,3,:,:,:,iElem),dXCL_N(:,3,:,:,:))
-  ! 1.b)Jacobians! grad(X_1) (grad(X_2) x grad(X_3))
-  DO dd=1,3
-    ee=Cyclic(dd+1) !cyclic!
-    ff=Cyclic(dd+2) !cyclic!
-    DO k=0,PP_N
-      DO j=0,PP_N
-        DO i=0,PP_N
-          detJacCL_N(1,i,j,k)=detJacCL_N(1,i,j,k) + &
-                              dXCL_N(dd,1,i,j,k) * &
-                              ( dXCL_N(ee,2,i,j,k)*dXCL_N(ff,3,i,j,k) - &
-                                dXCL_N(ff,2,i,j,k)*dXCL_N(ee,3,i,j,k)   )
-
-        END DO !i=0,N
-      END DO !j=0,N
-    END DO !k=0,N
-  END DO !nn=1,3
-  ! Interpolate the coordinates of the mapping (living in a NGeo world) to the N (Cheb Lob) world
-  CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,XCL_NGeo_loc(:,:,:,:),XCL_N(:,:,:,:))
-  !interpolate detJac to the GaussPoints
-  CALL ChangeBasis3D(1,PP_N,PP_N,Vdm_CLN_GaussN,detJacCL_N(:,:,:,:),DetJacGauss_N(:,:,:,:))
-  ! check scaled Jacobians
-  scaledJac(1)=MINVAL(detJacCL_N(1,:,:,:))/MAXVAL(detJacCL_N(1,:,:,:))
-  scaledJac(2)=MINVAL(detJacGauss_N(1,:,:,:))/MAXVAL(detJacGauss_N(1,:,:,:))
-  IF(ANY(scaledJac.LT.0.01)) THEN
-    WRITE(Unit_StdOut,*) 'Too small scaled Jacobians found (Jac/element):', scaledJac,iElem
-    CALL abort(&
-        __STAMP__&
-        ,'Scaled Jacobian lower then tolerance!',iElem)
-  END IF
-  ! check for negative Jacobians
-  DO k=0,PP_N
-    DO j=0,PP_N
-      DO i=0,PP_N
-        IF(detJacCL_N(1,i,j,k).LE.0.)THEN
-          WRITE(Unit_StdOut,*) 'Negative Jacobian found in element on CL points. Coords:', XCL_NGeo_loc(:,i,j,k)
-          WRITE(Unit_StdOut,*) 'Jacobian is:', detJacCL_N(1,i,j,k)
-          CALL abort(&
-              __STAMP__&
-              ,'Negative Jacobian found! Elem:',iElem)
-        END IF
-        IF(detJacGauss_N(1,i,j,k).LE.0.)THEN
-          WRITE(Unit_StdOut,*) 'Negative Jacobian found in element on Gauss points. Coords:', XCL_N(:,i,j,k)
-          WRITE(Unit_StdOut,*) 'Jacobian is:', detJacGauss_N(1,i,j,k)
-          CALL abort(&
-              __STAMP__&
-              ,'Negative Jacobian found! Elem:', iElem)
-        END IF
-      END DO !i=0,N
-    END DO !j=0,N
-  END DO !k=0,N
+      ee=Cyclic(dd+1) !cyclic!
+      ff=Cyclic(dd+2) !cyclic!
+      detJac_Ref(1,i,j,k,iElem)=detJac_Ref(1,i,j,k,iElem) + &
+                             dX_NgeoRef(dd,1,i,j,k) * &
+                           ( dX_NgeoRef(ee,2,i,j,k) * dX_NgeoRef(ff,3,i,j,k) - &
+                             dX_NgeoRef(ff,2,i,j,k) * dX_NgeoRef(ee,3,i,j,k)   )
+    END DO !nn=1,3
+  END DO; END DO; END DO !i,j,k=0,NgeoRef
+
+  !tmp2=0.
+  !DO dd=1,3
+  !  ee=Cyclic(dd+1) !cyclic!
+  !  ff=Cyclic(dd+2) !cyclic!
+  !  DO k=0,Ngeo; DO j=0,Ngeo; DO i=0,Ngeo
+  !        tmp2(1,i,j,k)=tmp2(1,i,j,k) + &
+  !                          dXCL_Ngeo(dd,1,i,j,k) * &
+  !                        ( dXCL_Ngeo(ee,2,i,j,k) * dXCL_Ngeo(ff,3,i,j,k) - &
+  !                          dXCL_Ngeo(ff,2,i,j,k) * dXCL_Ngeo(ee,3,i,j,k)   )
+  !  END DO; END DO; END DO !i,j,k=0,NgeoRef
+  !END DO !nn=1,3
+  !CALL ChangeBasis3D(1,Ngeo,PP_N,Vdm_CLNgeo_CLN,tmp2,XCL_N_quad)
+  !CALL ChangeBasis3D(1,PP_N,PP_N,Vdm_CLN_N,XCL_N_quad,DetJac_N)
+
+  !IF(interpolateFromTree)THEN
+  !  !interpolate detJac to the GaussPoints
+  !  DO i=0,NgeoRef
+  !    dxi=0.5*(xiRef(i)+1.)*Length
+  !    CALL LagrangeInterpolationPolys(xi0(1) + dxi(1),NgeoRef,xiRef,wBaryRef,Vdm_xi_Ref(  i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(2) + dxi(2),NgeoRef,xiRef,wBaryRef,Vdm_eta_Ref( i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(3) + dxi(3),NgeoRef,xiRef,wBaryRef,Vdm_zeta_Ref(i,:))
+  !  END DO
+  !  tmp=DetJac_Ref(:,:,:,:,iElem)
+  !  CALL ChangeBasis3D_XYZ(1,NgeoRef,NgeoRef,Vdm_xi_Ref,Vdm_eta_Ref,Vdm_zeta_Ref,&
+  !                         tmp,DetJac_Ref(:,:,:,:,iElem))
+  !END IF
+  ! interpolate detJac_ref to the solution points
+  CALL ChangeBasis3D(1,NgeoRef,PP_N,Vdm_NgeoRef_N,DetJac_Ref(:,:,:,:,iElem),DetJac_N)
 
   ! assign to global Variable sJ
-  DO k=0,PP_N
-    DO j=0,PP_N
-      DO i=0,PP_N
-        sJ(i,j,k,iElem)=1./DetJacGauss_N(1,i,j,k)
-      END DO !iGeo=0,NGeo
-    END DO !jGeo=0,NGeo
-  END DO !kGeo=0,NGeo
+  DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+    sJ(i,j,k,iElem)=1./DetJac_N(1,i,j,k)
+  END DO; END DO; END DO !i,j,k=0,PP_N
 
+  ! check for negative Jacobians
+  DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+    IF(detJac_N(1,i,j,k).LE.0.)&
+      WRITE(Unit_StdOut,*) 'Negative Jacobian found on Gauss point. Coords:', Elem_xGP(:,i,j,k,iElem)
+  END DO; END DO; END DO !i,j,k=0,N
+  ! check scaled Jacobians
+  scaledJac(2)=MINVAL(detJac_N(1,:,:,:))/MAXVAL(detJac_N(1,:,:,:))
+  IF(scaledJac(2).LT.0.01) THEN
+    WRITE(Unit_StdOut,*) 'Too small scaled Jacobians found (CL/Gauss):', scaledJac
+    CALL abort(__STAMP__,'Scaled Jacobian lower then tolerance!',iElem)
+  END IF
 
+  !2.a) Jacobi Matrix of d/dxi_dd(X_nn): dXCL_N(dd,nn,i,j,k))
+  ! N>=Ngeo: interpolate from dXCL_Ngeo (default)
+  ! N< Ngeo: directly derive XCL_N
+  IF(PP_N.GE.NGeo)THEN !compute first derivative on Ngeo and then interpolate
+    CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,1,:,:,:),dXCL_N(:,1,:,:,:))
+    CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,2,:,:,:),dXCL_N(:,2,:,:,:))
+    CALL ChangeBasis3D(3,NGeo,PP_N,Vdm_CLNGeo_CLN,dXCL_NGeo(:,3,:,:,:),dXCL_N(:,3,:,:,:))
+  ELSE  !N<Ngeo: first interpolate and then compute derivative (important if curved&periodic)
+    dXCL_N=0.
+    DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+      ! Matrix-vector multiplication
+      DO ll=0,PP_N
+        dXCL_N(1,:,i,j,k)=dXCL_N(1,:,i,j,k) + DCL_N(i,ll)*XCL_N(:,ll,j,k)
+        dXCL_N(2,:,i,j,k)=dXCL_N(2,:,i,j,k) + DCL_N(j,ll)*XCL_N(:,i,ll,k)
+        dXCL_N(3,:,i,j,k)=dXCL_N(3,:,i,j,k) + DCL_N(k,ll)*XCL_N(:,i,j,ll)
+      END DO !l=0,N
+    END DO; END DO; END DO !i,j,k=0,N
+  END IF !N>=Ngeo
+
+  JaCL_N=0.
   IF(crossProductMetrics)THEN
     ! exact (cross-product) form
     DO nn=1,3
@@ -224,106 +302,146 @@ DO iElem=1,nElems
       DO dd=1,3
         ee=Cyclic(dd+1) !cyclic!
         ff=Cyclic(dd+2) !cyclic!
-        DO k=0,PP_N
-          DO j=0,PP_N
-            DO i=0,PP_N
-              ! exact (cross-product) form
-              JaCL_N(dd,nn,i,j,k)=dXCL_N(ee,mm,i,j,k)*dXCL_N(ff,ll,i,j,k) - dXCL_N(ee,ll,i,j,k)*dXCL_N(ff,mm,i,j,k)  
-            END DO !i=0,N
-          END DO !j=0,N
-        END DO !k=0,N
+        DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+          ! exact (cross-product) form
+          JaCL_N(dd,nn,i,j,k)=dXCL_N(ee,mm,i,j,k)*dXCL_N(ff,ll,i,j,k) - dXCL_N(ee,ll,i,j,k)*dXCL_N(ff,mm,i,j,k)
+        END DO; END DO; END DO ! i,j,k
       END DO !dd=1,3
     END DO !nn=1,3
-  ELSE ! curl metrics 
-    ! 2a.) Calculate X_l grad (X_m) 
-    DO nn=1,3
-      mm=Cyclic(nn+1) !cyclic!
-      ll=Cyclic(nn+2) !cyclic!
-      DO dd=1,3
-        DO k=0,PP_N
-          DO j=0,PP_N
-            DO i=0,PP_N
-              ! conservative curl form
-              !R_CL_N(dd,nn,i,j,k)=XCL_N(ll,i,j,k)*dXCL_N(dd,mm,i,j,k) 
-              ! invariant curl form
-              R_CL_N(dd,nn,i,j,k)=0.5*(XCL_N(ll,i,j,k)*dXCL_N(dd,mm,i,j,k) - &
-                                         XCL_N(mm,i,j,k)*dXCL_N(dd,ll,i,j,k)   )
-            END DO !i=0,N
-          END DO !j=0,N
-        END DO !k=0,N
-      END DO !dd=1,3
-    END DO !nn=1,3
-    DO nn=1,3
-      DO dd=1,3
-        ee=Cyclic(dd+1) !cyclic!
-        ff=Cyclic(dd+2) !cyclic!
-        DO k=0,PP_N
-                  CycIJK(3)=k
-          DO j=0,PP_N
-                    CycIJK(2)=j
-            DO i=0,PP_N
-                      CycIJK(1)=i
-              ! the f***ing curl is needed for the metric terms
-              !
-              !Metrics_fTilde(nn)=d/dxi_m (R_CL(1))_l - d/dxi_l (R_CL(1))_m
-              !Metrics_gTilde(nn)=d/dxi_m (R_CL(2))_l - d/dxi_l (R_CL(2))_m
-              !Metrics_hTilde(nn)=d/dxi_m (R_CL(3))_l - d/dxi_l (R_CL(3))_m
-              !
-              ! first part of the curl with cyclic indices
-              !
-              Cyc=CycIJK
-              DO q=0,PP_N
-                Cyc(ee)=q    !d/dxi_m
-                JaCL_N(dd,nn,i,j,k)=JaCL_N(dd,nn,i,j,k) - &
-                                    DCL_N(CycIJK(ee),q)*R_CL_N(ff,nn,Cyc(1),Cyc(2),Cyc(3))
-              END DO!q=0,PP_N
-            END DO !i=0,PP_N
-          END DO !j=0,PP_N
-        END DO !k=0,PP_N
-      END DO!dd=1,3
-    END DO!nn=1,3
-    DO nn=1,3
-      DO dd=1,3
-        ee=Cyclic(dd+1) !cyclic!
-        ff=Cyclic(dd+2) !cyclic!
-        DO k=0,PP_N
-                  CycIJK(3)=k
-          DO j=0,PP_N
-                    CycIJK(2)=j
-            DO i=0,PP_N
-                      CycIJK(1)=i
-              !
-              ! second part of the curl with cyclic indices
-              !
-              Cyc=CycIJK
-              DO q=0,PP_N
-                Cyc(ff)=q    !d/dxi_l
-                JaCL_N(dd,nn,i,j,k)=JaCL_N(dd,nn,i,j,k) + &
-                                    DCL_N(CycIJK(ff),q)*R_CL_N(ee,nn,Cyc(1),Cyc(2),Cyc(3))
-              END DO!q=0,PP_N
-            END DO !i=0,PP_N
-          END DO !j=0,PP_N
-        END DO !k=0,PP_N
-      END DO!dd=1,3
-    END DO!nn=1,3
+  ELSE ! curl metrics
+    ! 2. b.) Calculate X_l grad (X_m)
+    R_CL_N=0.
+    DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+      DO nn=1,3
+        mm=Cyclic(nn+1) !cyclic!
+        ll=Cyclic(nn+2) !cyclic!
+        DO dd=1,3
+          ! conservative curl form
+          !R_CL_N(dd,nn,i,j,k)=XCL_N(ll,i,j,k)*dXCL_N(dd,mm,i,j,k)
+          ! invariant curl form
+          R_CL_N(dd,nn,i,j,k)=0.5*(XCL_N(ll,i,j,k)*dXCL_N(dd,mm,i,j,k) - &
+                                   XCL_N(mm,i,j,k)*dXCL_N(dd,ll,i,j,k)   )
+        END DO !dd=1,3
+      END DO !nn=1,3
+    END DO; END DO; END DO ! i,j,k
+
+    DO nn=1,3; DO dd=1,3
+      ee=Cyclic(dd+1) !cyclic!
+      ff=Cyclic(dd+2) !cyclic!
+      DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+        CycIJK(1)=i; CycIJK(2)=j; CycIJK(3)=k
+        ! the f***ing curl is needed for the metric terms
+        !
+        !Metrics_fTilde(nn)=d/dxi_m (R_CL(1))_l - d/dxi_l (R_CL(1))_m
+        !Metrics_gTilde(nn)=d/dxi_m (R_CL(2))_l - d/dxi_l (R_CL(2))_m
+        !Metrics_hTilde(nn)=d/dxi_m (R_CL(3))_l - d/dxi_l (R_CL(3))_m
+        !
+        ! first part of the curl with cyclic indices
+        !
+        Cyc=CycIJK
+        DO q=0,PP_N
+          Cyc(ee)=q    !d/dxi_m
+          JaCL_N(dd,nn,i,j,k)=JaCL_N(dd,nn,i,j,k) - &
+                              DCL_N(CycIJK(ee),q)*R_CL_N(ff,nn,Cyc(1),Cyc(2),Cyc(3))
+        END DO!q=0,PP_N
+      END DO; END DO; END DO ! i,j,k
+    END DO; END DO ! nn,dd=1,3
+
+    DO nn=1,3; DO dd=1,3
+      ee=Cyclic(dd+1) !cyclic!
+      ff=Cyclic(dd+2) !cyclic!
+      DO k=0,PP_N; DO j=0,PP_N; DO i=0,PP_N
+        CycIJK(1)=i; CycIJK(2)=j; CycIJK(3)=k
+        !
+        ! second part of the curl with cyclic indices
+        !
+        Cyc=CycIJK
+        DO q=0,PP_N
+          Cyc(ff)=q    !d/dxi_l
+          JaCL_N(dd,nn,i,j,k)=JaCL_N(dd,nn,i,j,k) + &
+                              DCL_N(CycIJK(ff),q)*R_CL_N(ee,nn,Cyc(1),Cyc(2),Cyc(3))
+        END DO!q=0,PP_N
+      END DO; END DO; END DO ! i,j,k=0,PP_N
+    END DO;END DO ! nn,dd=1,3
   END IF !crossProductMetrics
-  ! interpolate Metrics from Cheb-Lobatto N onto GaussPoints N
-  CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(:,:,:,:),Elem_xGP(:,:,:,:,iElem))
-  CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(1,:,:,:,:),Metrics_fTilde(:,:,:,:,iElem))
-  CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(2,:,:,:,:),Metrics_gTilde(:,:,:,:,iElem))
-  CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(3,:,:,:,:),Metrics_hTilde(:,:,:,:,iElem))
-  CALL CalcSurfMetrics(JaCL_N,XCL_N,iElem)
+
+
+  !IF(interpolateFromTree)THEN
+  !  ! interpolate Metrics from Cheb-Lobatto N on tree level onto GaussPoints N on quad level
+  !  DO i=0,PP_N
+  !    dxi=0.5*(xGP(i)+1.)*length
+  !    CALL LagrangeInterpolationPolys(xi0(1) + dxi(1),PP_N,xiCL_N,wBaryCL_N,Vdm_xi_N(  i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(2) + dxi(2),PP_N,xiCL_N,wBaryCL_N,Vdm_eta_N( i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(3) + dxi(3),PP_N,xiCL_N,wBaryCL_N,Vdm_zeta_N(i,:))
+  !  END DO
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,XCL_N            ,Elem_xGP(      :,:,:,:,iElem))
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(1,:,:,:,:),Metrics_fTilde(:,:,:,:,iElem))
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(2,:,:,:,:),Metrics_gTilde(:,:,:,:,iElem))
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(3,:,:,:,:),Metrics_hTilde(:,:,:,:,iElem))
+  !  ! for the metrics and the jacobian, we have to take into account the level !!!!!
+  !  Metrics_fTilde(:,:,:,:,iElem)=(length(1)/2.)**2*Metrics_fTilde(:,:,:,:,iElem)
+  !  Metrics_gTilde(:,:,:,:,iElem)=(length(2)/2.)**2*Metrics_gTilde(:,:,:,:,iElem)
+  !  Metrics_hTilde(:,:,:,:,iElem)=(length(3)/2.)**2*Metrics_hTilde(:,:,:,:,iElem)
+  !  sJ(:,:,:,iElem)=(8./PRODUCT(length))*sJ(:,:,:,iElem) ! scale down sJ
+
+  !  ! interpolate Metrics and grid to Cheb-Lobatto on quadrant level for Surface metrics
+  !  DO i=0,PP_N
+  !    dxi=0.5*(xiCL_N(i)+1.)*length
+  !    CALL LagrangeInterpolationPolys(xi0(1) + dxi(1),PP_N,xiCL_N,wBaryCL_N,Vdm_xi_N(  i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(2) + dxi(2),PP_N,xiCL_N,wBaryCL_N,Vdm_eta_N( i,:))
+  !    CALL LagrangeInterpolationPolys(xi0(3) + dxi(3),PP_N,xiCL_N,wBaryCL_N,Vdm_zeta_N(i,:))
+  !  END DO
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,XCL_N            ,XCL_N_quad            )
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(1,:,:,:,:),JaCL_N_quad(1,:,:,:,:))
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(2,:,:,:,:),JaCL_N_quad(2,:,:,:,:))
+  !  CALL ChangeBasis3D_XYZ(3,PP_N,PP_N,Vdm_xi_N,Vdm_eta_N,Vdm_zeta_N,JaCL_N(3,:,:,:,:),JaCL_N_quad(3,:,:,:,:))
+  !  !TODO: scale Ja for anisotropic
+  !  JaCL_N_quad(:,1,:,:,:)=(length(2)*length(3)/4.)*JaCL_N_quad(:,1,:,:,:)
+  !  JaCL_N_quad(:,2,:,:,:)=(length(1)*length(3)/4.)*JaCL_N_quad(:,2,:,:,:)
+  !  JaCL_N_quad(:,3,:,:,:)=(length(1)*length(2)/4.)*JaCL_N_quad(:,3,:,:,:)
+  !  CALL CalcSurfMetrics(PP_N,JaCL_N_quad,XCL_N_quad,Vdm_CLN_N,iElem,&
+  !                       NormVec,TangVec1,TangVec2,SurfElem,Face_xGP)
+  !ELSE
+    ! interpolate Metrics from Cheb-Lobatto N onto GaussPoints N
+    CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_N,XCL_N            ,Elem_xGP(      :,:,:,:,iElem))
+    CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_N,JaCL_N(1,:,:,:,:),Metrics_fTilde(:,:,:,:,iElem))
+    CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_N,JaCL_N(2,:,:,:,:),Metrics_gTilde(:,:,:,:,iElem))
+    CALL ChangeBasis3D(3,PP_N,PP_N,Vdm_CLN_N,JaCL_N(3,:,:,:,:),Metrics_hTilde(:,:,:,:,iElem))
+    CALL CalcSurfMetrics(PP_N,JaCL_N,XCL_N,Vdm_CLN_N,iElem,&
+                         NormVec,TangVec1,TangVec2,SurfElem,Face_xGP)
+  !END IF
+
+  IF(PRESENT(XCL_Ngeo_Out))   XCL_Ngeo_Out(1:3,0:Ngeo,0:Ngeo,0:Ngeo,iElem)= XCL_Ngeo(1:3,0:Ngeo,0:Ngeo,0:Ngeo)
+  IF(PRESENT(dXCL_Ngeo_Out)) dXCL_Ngeo_Out(1:3,1:3,0:Ngeo,0:Ngeo,0:Ngeo,iElem)=dXCL_Ngeo(1:3,1:3,0:Ngeo,0:Ngeo,0:Ngeo)
 #ifdef PARTICLES
-  CALL GetBezierControlPoints3D(XCL_NGeo(:,:,:,:,iElem),iElem)
+  CALL CPU_TIME(StartT2)
+  CALL GetBezierControlPoints3D(XCL_NGeo(:,:,:,:),iElem)
+  CALL CPU_TIME(endT)
+  BezierTime=BezierTime+endT-StartT2
 #endif /*PARTICLES*/
 END DO !iElem=1,nElems
 
-
 #ifdef PARTICLES
 SWRITE(UNIT_stdOut,'(A)') ' '
-SWRITE(UNIT_stdOut,'(A)') ' VALIDATION OF BEZIERCONTROLPOINTS ...'
+SWRITE(UNIT_stdOut,'(A)') 'BEZIERCONTROLPOINTS ...'
+StartT2=BOLTZPLATZTIME()
+#ifdef MPI
+CALL MPI_ALLREDUCE(MPI_IN_PLACE, BezierTime, 1, MPI_DOUBLE_PRECISION, MPI_MAX, MPI_COMM_WORLD, IERROR)
+#endif /*MPI*/
+lowerLimit = nBCSides+nInnerSides+nMPISides_MINE
+DO iSide=1,lowerLimit
+  !CALL GetSideSlabNormalsAndIntervals(iSide) ! elevation occurs within this routine
+  ! elevation occurs within this routine
+  CALL GetSideSlabNormalsAndIntervals(BezierControlPoints3D(1:3,0:NGeo,0:NGeo,iSide)                         &
+                                     ,BezierControlPoints3DElevated(1:3,0:NGeoElevated,0:NGeoElevated,iSide) &
+                                     ,SideSlabNormals(1:3,1:3,iSide)                                         &
+                                     ,SideSlabInterVals(1:6,iSide)                                           &
+                                     ,BoundingBoxIsEmpty(iSide)                                              )
+
+END DO
+
+!IF(DoRefMapping) lowerLimit=nBCSides
 lowerLimit=SideID_minus_upper
-IF(DoRefMapping) lowerLimit=nBCSides
 DO iSide=1,lowerLimit
   IF(SUM(ABS(BezierControlPoints3D(:,:,:,iSide))).LT.1e-10)THEN
     IPWRITE(UNIT_stdOut,'(I6,A,I6)') ' Warning, BezierControlPoint is zero! SideID:', iSide
@@ -331,270 +449,133 @@ DO iSide=1,lowerLimit
   END IF
 END DO 
 
+endT=BOLTZPLATZTIME()
+BezierTime=BezierTime+endT-StartT2
+
 SWRITE(UNIT_stdOut,'(A)') ' '
+endt=BOLTZPLATZTIME()
+SWRITE(UNIT_stdOut,'(A,F8.3,A)',ADVANCE='YES')' Calculation of Bezier control points took [',BezierTime            ,'s]'
+SWRITE(UNIT_stdOut,'(A,F8.3,A)',ADVANCE='YES')' Calculation of metrics took               [',EndT-StartT-BezierTime,'s]'
+#else
+endt=BOLTZPLATZTIME()
+SWRITE(UNIT_stdOut,'(A,F8.3,A)',ADVANCE='YES')' Calculation of metrics took               [',EndT-StartT,'s]'
 #endif /*PARTICLES*/
 
 
-endt=BOLTZPLATZTIME(MPI_COMM_WORLD)
-SWRITE(UNIT_stdOut,'(A,F8.3,A)',ADVANCE='YES')' Calculation of metrics took      [',EndT-StartT,'s]'
 
-!#ifdef PARTICLES
-!  CALL GetSideType()
-!#endif /*PARTICLES*/
 END SUBROUTINE CalcMetrics 
 
 
-
-SUBROUTINE CalcSurfMetrics(JaCL_N,XCL_N,iElem)
+SUBROUTINE CalcSurfMetrics(Nloc,JaCL_N,XCL_N,Vdm_CLN_N,iElem,NormVec,TangVec1,TangVec2,SurfElem,Face_xGP)
 !===================================================================================================================================
 ! Compute normal and tangential vectors from element metrics. Input is JaCL_N, the 3D element metrics on Cebychev-Lobatto points
 !===================================================================================================================================
 ! MODULES
 USE MOD_PreProc
 USE MOD_Globals,     ONLY:CROSS
-USE MOD_Mesh_Vars,   ONLY:Vdm_CLN_GaussN
-USE MOD_Mesh_Vars,   ONLY:ElemToSide,BCFace_xGP,nBCSides,Face_xGP
-USE MOD_Mesh_Vars,   ONLY:NormVec,TangVec1,TangVec2,SurfElem
-USE MOD_Analyze_Vars,ONLY:CalcPoyntingInt
-!-----------------------------------------------------------------------------------------------------------------------------------
+USE MOD_Mesh_Vars,   ONLY:ElemToSide,nBCSides,nBCSides,nSides!,MortarType
+USE MOD_Mesh_Vars,   ONLY:sideid_minus_lower,sideid_minus_upper,nBCSides
+USE MOD_Mappings,    ONLY:CGNS_SideToVol2
 USE MOD_ChangeBasis, ONLY:ChangeBasis2D
+!USE MOD_Mortar_Geo,  ONLY:MortarGeo
+!-----------------------------------------------------------------------------------------------------------------------------------
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
-INTEGER,INTENT(IN) :: iElem
-REAL,INTENT(IN)    :: JaCL_N(3,3,0:PP_N,0:PP_N,0:PP_N)  !Metrics from Element iElem
-REAL,INTENT(IN)    :: XCL_N(3,0:PP_N,0:PP_N,0:PP_N)
+INTEGER,INTENT(IN) :: Nloc                                !< (IN) polynomial degree
+INTEGER,INTENT(IN) :: iElem                               !< (IN) element index
+REAL,INTENT(IN)    :: JaCL_N(  3,3,0:Nloc,0:Nloc,0:Nloc)  !< (IN) volume metrics of element
+REAL,INTENT(IN)    :: XCL_N(     3,0:Nloc,0:Nloc,0:Nloc)  !< (IN) element geo. interpolation points (CL)
+REAL,INTENT(IN)    :: Vdm_CLN_N(   0:Nloc,0:Nloc)         !< (IN) Vandermonde matrix from Cheby-Lob on N to final nodeset on N
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
+REAL,INTENT(OUT)   ::    NormVec(3,0:Nloc,0:Nloc,SideID_minus_Lower:SideID_minus_Upper) !< (OUT) element face normal vectors
+REAL,INTENT(OUT)   ::   TangVec1(3,0:Nloc,0:Nloc,SideID_minus_Lower:SideID_minus_Upper) !< (OUT) element face tangential vectors
+REAL,INTENT(OUT)   ::   TangVec2(3,0:Nloc,0:Nloc,SideID_minus_Lower:SideID_minus_Upper) !< (OUT) element face tangential vectors
+REAL,INTENT(OUT)   ::   SurfElem(  0:Nloc,0:Nloc,SideID_minus_Lower:SideID_minus_Upper) !< (OUT) element face surface area
+REAL,INTENT(OUT)   :: Face_xGP(3,0:Nloc,0:Nloc,1:nSides)                       !< (OUT) element face interpolation points
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-INTEGER            :: p,q
-INTEGER            :: dd
-INTEGER            :: sideID
-REAL               :: Ja_Face(3,3,0:PP_N,0:PP_N)
-REAL               :: tmp(3,0:PP_N,0:PP_N)
+INTEGER            :: p,q,pq(2),dd,iLocSide,SideID
+INTEGER            :: NormalDirs(6),TangDirs(6)
+INTEGER            :: NormalDir    ,TangDir
+REAL               :: NormalSign,   NormalSigns(6)
+REAL               :: Ja_Face(3,3,0:Nloc,0:Nloc)
+REAL               :: tmp(      3,0:Nloc,0:Nloc)
+REAL               :: tmp2(     3,0:Nloc,0:Nloc)
 !===================================================================================================================================
 
-! interpolate to xi sides
-IF(ElemToSide(E2S_FLIP,XI_MINUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,XI_MINUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,0,:,:),tmp)
-    ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        BCFace_xGP(1:3,p,q,sideID)=tmp(:,q,p)
-      END DO !p
-    END DO !q
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,0,:,:),tmp)
-      ! turn into right hand system of side
-      DO q=0,PP_N
-        DO p=0,PP_N
-          Face_xGP(1:3,p,q,sideID)=tmp(:,q,p)
-        END DO !p
-      END DO !q
-    END IF ! BC
-  END IF ! PoyntingIntegral
-  DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,0,:,:),tmp)
-    ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        Ja_Face(dd,1:3,p,q)=tmp(:,q,p)
-      END DO !p
-    END DO !q
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(1,:,p,q)**2))
-      NormVec( :,p,q,SideID) = -Ja_Face(1,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(2,:,p,q)-SUM(Ja_Face(2,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
-
-IF(ElemToSide(E2S_FLIP,XI_PLUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,XI_PLUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,PP_N,:,:),BCFace_xGP(1:3,:,:,sideID))
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF ! CalcPoyntintIntegral
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,PP_N,:,:),Face_xGP(1:3,:,:,SideID))
-    END IF ! BC
-  END IF ! PoyntingIntegral
-  DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,PP_N,:,:),Ja_Face(dd,1:3,:,:))
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(1,:,p,q)**2))
-      NormVec( :,p,q,SideID) = Ja_Face(1,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(2,:,p,q)-SUM(Ja_Face(2,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
-
-! interpolate to eta sides
-IF(ElemToSide(E2S_FLIP,ETA_MINUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,ETA_MINUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,0,:),BCFace_xGP(1:3,:,:,sideID))
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF ! CalcPoyntingInt
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,0,:),Face_xGP(1:3,:,:,SideID))
-    END IF ! BC
-  END IF ! PoyntingIntegral
-  DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,:,0,:),Ja_Face(dd,1:3,:,:))
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(2,:,p,q)**2))
-      NormVec( :,p,q,SideID) = -Ja_Face(2,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(3,:,p,q)-SUM(Ja_Face(3,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
-  
-IF(ElemToSide(E2S_FLIP,ETA_PLUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,ETA_PLUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,PP_N,:),tmp)
-    ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        BCFace_xGP(1:3,p,q,sideID)=tmp(:,PP_N-p,q)
-      END DO !p
-    END DO !q
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,PP_N,:),tmp)
-      ! turn into right hand system of side
-      DO q=0,PP_N
-        DO p=0,PP_N
-          Face_xGP(1:3,p,q,sideID)=tmp(:,PP_N-p,q)
-        END DO !p
-      END DO !q
-    END IF ! BC
-  END IF ! PoyntingIntegral
-  DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,:,PP_N,:),tmp)
-    ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        Ja_Face(dd,1:3,p,q)=tmp(:,PP_N-p,q)
-      END DO !p
-    END DO !q
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(2,:,p,q)**2))
-      NormVec( :,p,q,SideID) = Ja_Face(2,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(3,:,p,q)-SUM(Ja_Face(3,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
-
-! interpolate to zeta sides
-IF(ElemToSide(E2S_FLIP,ZETA_MINUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,ZETA_MINUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,:,0),tmp)
-    ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        BCFace_xGP(1:3,p,q,sideID)=tmp(:,q,p)
-      END DO !p
-    END DO !q
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,:,0),tmp)
-      ! turn into right hand system of side
-      DO q=0,PP_N
-        DO p=0,PP_N
-          Face_xGP(1:3,p,q,sideID)=tmp(:,q,p)
-        END DO !p
-      END DO !q
-    END IF ! BC
-  END IF ! PoyntingIntegral
+NormalDirs(XI_MINUS)  =1; TangDirs(XI_MINUS)    =2; NormalSigns(XI_MINUS)  =-1.
+NormalDirs(XI_PLUS)   =1; TangDirs(XI_PLUS)     =2; NormalSigns(XI_PLUS)   = 1.
+NormalDirs(ETA_MINUS) =2; TangDirs(ETA_MINUS)   =3; NormalSigns(ETA_MINUS) =-1.
+NormalDirs(ETA_PLUS)  =2; TangDirs(ETA_PLUS)    =3; NormalSigns(ETA_PLUS)  = 1.
+NormalDirs(ZETA_MINUS)=3; TangDirs(ZETA_MINUS)  =1; NormalSigns(ZETA_MINUS)=-1.
+NormalDirs(ZETA_PLUS) =3; TangDirs(ZETA_PLUS)   =1; NormalSigns(ZETA_PLUS) = 1.
+
+DO iLocSide=1,6
+  IF(ElemToSide(E2S_FLIP,iLocSide,iElem).NE.0) CYCLE ! only master sides with flip=0
+  SideID=ElemToSide(E2S_SIDE_ID,iLocSide,iElem)
+
+  SELECT CASE(iLocSide)
+  CASE(XI_MINUS)
+    tmp=XCL_N(1:3,0   ,:   ,:   )
+  CASE(XI_PLUS)
+    tmp=XCL_N(1:3,Nloc,:   ,:   )
+  CASE(ETA_MINUS)
+    tmp=XCL_N(1:3,:   ,0   ,:   )
+  CASE(ETA_PLUS)
+    tmp=XCL_N(1:3,:   ,Nloc,:   )
+  CASE(ZETA_MINUS)
+    tmp=XCL_N(1:3,:   ,:   ,0   )
+  CASE(ZETA_PLUS)
+    tmp=XCL_N(1:3,:   ,:   ,Nloc)
+  END SELECT
+  CALL ChangeBasis2D(3,Nloc,Nloc,Vdm_CLN_N,tmp,tmp2)
+  ! turn into right hand system of side
+  DO q=0,Nloc; DO p=0,Nloc
+    pq=CGNS_SideToVol2(p,q,iLocSide)
+    ! Compute Face_xGP for sides
+    Face_xGP(1:3,p,q,sideID)=tmp2(:,pq(1),pq(2))
+  END DO; END DO ! p,q
+
+  NormalDir=NormalDirs(iLocSide); TangDir=TangDirs(iLocSide); NormalSign=NormalSigns(iLocSide);
   DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,:,:,0),tmp)
+    SELECT CASE(iLocSide)
+    CASE(XI_MINUS)
+      tmp=JaCL_N(dd,1:3,0   ,:   ,:   )
+    CASE(XI_PLUS)
+      tmp=JaCL_N(dd,1:3,Nloc,:   ,:   )
+    CASE(ETA_MINUS)
+      tmp=JaCL_N(dd,1:3,:   ,0   ,:   )
+    CASE(ETA_PLUS)
+      tmp=JaCL_N(dd,1:3,:   ,Nloc,:   )
+    CASE(ZETA_MINUS)
+      tmp=JaCL_N(dd,1:3,:   ,:   ,0   )
+    CASE(ZETA_PLUS)
+      tmp=JaCL_N(dd,1:3,:   ,:   ,Nloc)
+    END SELECT
+    CALL ChangeBasis2D(3,Nloc,Nloc,Vdm_CLN_N,tmp,tmp2)
     ! turn into right hand system of side
-    DO q=0,PP_N
-      DO p=0,PP_N
-        Ja_Face(dd,1:3,p,q)=tmp(:,q,p)
-      END DO !p
-    END DO !q
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(3,:,p,q)**2))
-      NormVec( :,p,q,SideID) = -Ja_Face(3,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(1,:,p,q)-SUM(Ja_Face(1,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
-
-IF(ElemToSide(E2S_FLIP,ZETA_PLUS,iElem).EQ.0) THEN !if flip=0, master side!!
-  SideID=ElemToSide(E2S_SIDE_ID,ZETA_PLUS,iElem)
-  IF ((sideID.LE.nBCSides))THEN !BC
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,:,PP_N),BCFace_xGP(1:3,:,:,sideID))
-    IF (CalcPoyntingInt) THEN
-      Face_xGP(:,:,:,SideID) = BCFace_xGP(:,:,:,SideID)
-    END IF ! PoyntingIntegral
-  END IF !BC
-  IF (CalcPoyntingInt) THEN
-    IF((SideID.GT.nBCSides))THEN ! > BC
-       CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,XCL_N(1:3,:,:,PP_N),Face_xGP(1:3,:,:,SideID))
-    END IF ! BC
-  END IF ! PoyntingIntegral
-  DO dd=1,3
-    CALL ChangeBasis2D(3,PP_N,PP_N,Vdm_CLN_GaussN,JaCL_N(dd,1:3,:,:,PP_N),Ja_Face(dd,1:3,:,:))
-  END DO
-  DO q=0,PP_N
-    DO p=0,PP_N
-      SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(3,:,p,q)**2))
-      NormVec( :,p,q,SideID) = Ja_Face(3,:,p,q)/SurfElem(p,q,SideID)
-      TangVec1(:,p,q,SideID) = Ja_Face(1,:,p,q)-SUM(Ja_Face(1,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
-      TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
-      TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
-    END DO
-  END DO
-END IF !flip=0
+    DO q=0,Nloc; DO p=0,Nloc
+      pq=CGNS_SideToVol2(p,q,iLocSide)
+      Ja_Face(dd,1:3,p,q)=tmp2(:,pq(1),pq(2))
+    END DO; END DO ! p,q
+  END DO ! dd
+  DO q=0,Nloc; DO p=0,Nloc
+    SurfElem(  p,q,SideID) = SQRT(SUM(Ja_Face(NormalDir,:,p,q)**2))
+    NormVec( :,p,q,SideID) = NormalSign*Ja_Face(NormalDir,:,p,q)/SurfElem(p,q,SideID)
+    TangVec1(:,p,q,SideID) = Ja_Face(TangDir,:,p,q) &
+        -SUM(Ja_Face(TangDir,:,p,q)*NormVec(:,p,q,SideID))*NormVec(:,p,q,SideID)
+    TangVec1(:,p,q,SideID) = TangVec1(:,p,q,SideID)/SQRT(SUM(TangVec1(:,p,q,SideID)**2))
+    TangVec2(:,p,q,SideID) = CROSS(NormVec(:,p,q,SideID),TangVec1(:,p,q,SideID))
+  END DO; END DO ! p,q
+!  IF(MortarType(SideID).GT.0) CALL mortarGeo(SideID,iLocSide,Ja_Face) !set Normal,tangential and surfelem on mortars
+END DO
 
 END SUBROUTINE CalcSurfMetrics
 
+
+
+
 END MODULE MOD_Metrics
diff --git a/src/particles/boundary/particle_boundary_condition.f90 b/src/particles/boundary/particle_boundary_condition.f90
index 1dd1168..d04ab7c 100644
--- a/src/particles/boundary/particle_boundary_condition.f90
+++ b/src/particles/boundary/particle_boundary_condition.f90
@@ -27,7 +27,7 @@ PUBLIC::GetBoundaryInteraction,GetBoundaryInteractionRef
 
 CONTAINS
 
-SUBROUTINE GetBoundaryInteraction(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,ElemID)
+SUBROUTINE GetBoundaryInteraction(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,ElemID,reflected)
 !===================================================================================================================================
 ! Computes the post boundary state of a particle that interacts with a boundary condition
 !  OpenBC                  = 1  
@@ -69,6 +69,7 @@ REAL,INTENT(IN)                      :: xi,eta
 ! OUTPUT VARIABLES
 INTEGER,INTENT(INOUT)                :: ElemID
 REAL,INTENT(INOUT)                   :: alpha,PartTrajectory(1:3),lengthPartTrajectory
+LOGICAL,INTENT(OUT)                  :: Reflected
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 REAL                                 :: n_loc(1:3),RanNum
@@ -84,6 +85,7 @@ __STAMP__&
 ,' ERROR: PartBound not allocated!.',999,999.)
 END IF
 IsSpeciesSwap=.FALSE.
+Reflected    =.FALSE.
 ! Select the corresponding boundary condition and calculate particle treatment
 SELECT CASE(PartBound%TargetBoundCond(PartBound%MapToPartBC(BC(SideID))))
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -92,7 +94,7 @@ CASE(1) !PartBound%OpenBC)
   IF(alpha/lengthPartTrajectory.LE.epsilontol)THEN !if particle is close to BC, it encounters the BC only if it leaves element/grid
     !BCSideID=PartBCSideList(SideID)
     SELECT CASE(SideType(SideID))
-    CASE(PLANAR_RECT,PLANAR_NONRECT)
+    CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
       n_loc=SideNormVec(1:3,SideID)
     CASE(BILINEAR)
       CALL CalcNormAndTangBilinear(nVec=n_loc,xi=xi,eta=eta,SideID=SideID)
@@ -130,9 +132,9 @@ CASE(2) !PartBound%ReflectiveBC)
       CALL RANDOM_NUMBER(RanNum)
       IF(RanNum.GE.PartBound%MomentumACC(PartBound%MapToPartBC(BC(SideID)))) THEN
         ! perfectly reflecting, specular re-emission
-        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap)
+        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,opt_Reflected=reflected)
       ELSE
-        CALL DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap)
+        CALL DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,opt_Reflected=reflected)
       END IF
     ELSE IF (WallModeltype.EQ.1) THEN
                adsorbindex = 0
@@ -151,7 +153,7 @@ CASE(2) !PartBound%ReflectiveBC)
         END IF
       ELSE IF (adsorbindex.EQ.0) THEN
 !--- Inelastic Reflection (not diffuse)               
-        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap)
+        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,opt_Reflected=reflected)
       ELSE
         WRITE(*,*)'Boundary_PIC: Adsorption error.'
         CALL Abort(&
@@ -194,8 +196,8 @@ __STAMP__&
 !-----------------------------------------------------------------------------------------------------------------------------------
 CASE(10) !PartBound%SymmetryBC
 !-----------------------------------------------------------------------------------------------------------------------------------
-  CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,opt_Symmetry=.TRUE.)
-
+  CALL  PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap &
+                                       ,opt_Symmetry=.TRUE.,opt_Reflected=reflected)
 
 CASE DEFAULT
 CALL abort(&
@@ -206,7 +208,7 @@ END SELECT !PartBound%MapToPartBC(BC(SideID)
 END SUBROUTINE GetBoundaryInteraction
 
 
-SUBROUTINE GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID)
+SUBROUTINE GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,reflected)
 !===================================================================================================================================
 ! Computes the post boundary state of a particle that interacts with a boundary condition
 !  OpenBC                  = 1  
@@ -245,6 +247,7 @@ REAL,INTENT(IN)                      :: xi,eta
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 REAL,INTENT(INOUT)                   :: alpha,PartTrajectory(1:3),lengthPartTrajectory
+LOGICAL,INTENT(OUT)                  :: reflected
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 REAL                                 :: RanNum,n_loc(1:3)
@@ -258,6 +261,7 @@ __STAMP__&
 ,' ERROR: PartBound not allocated!.',999,999.)
 END IF
 IsSpeciesSwap=.FALSE.
+Reflected    =.FALSE.
 ! Select the corresponding boundary condition and calculate particle treatment
 SELECT CASE(PartBound%TargetBoundCond(PartBound%MapToPartBC(BC(SideID))))
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -266,7 +270,7 @@ CASE(1) !PartBound%OpenBC)
   IF(alpha/lengthPartTrajectory.LE.epsilontol)THEN !if particle is close to BC, it encounters the BC only if it leaves element/grid
     BCSideID=PartBCSideList(SideID)
     SELECT CASE(SideType(BCSideID))
-    CASE(PLANAR_RECT,PLANAR_NONRECT)
+    CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
       n_loc=SideNormVec(1:3,BCSideID)
     CASE(BILINEAR)
       CALL CalcNormAndTangBilinear(nVec=n_loc,xi=xi,eta=eta,SideID=BCSideID)
@@ -307,9 +311,11 @@ CASE(2) !PartBound%ReflectiveBC)
       BCSideID=PartBCSideList(SideID)
       IF(RanNum.GE.PartBound%MomentumACC(PartBound%MapToPartBC(BC(SideID)))) THEN
         ! perfectly reflecting, specular re-emission
-        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,BCSideID=BCSideID)
+        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap &
+                              ,BCSideID=BCSideID,opt_reflected=reflected)
       ELSE
-        CALL DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,BCSideID)
+        CALL DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap&
+                              ,BCSideID=BCSideID,opt_reflected=reflected)
       END IF
     ELSE IF (WallModeltype.EQ.1) THEN
                adsorbindex = 0
@@ -329,7 +335,8 @@ CASE(2) !PartBound%ReflectiveBC)
       ELSE IF (adsorbindex.EQ.0) THEN
 !--- Inelastic Reflection (not diffuse)  
         BCSideID=PartBCSideList(SideID)
-        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,BCSideID=BCSideID)
+        CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap &
+                              ,BCSideID=BCSideID,opt_reflected=reflected)
       ELSE
         WRITE(*,*)'Boundary_PIC: Adsorption error.'
         CALL Abort(&
@@ -374,9 +381,8 @@ __STAMP__&
 CASE(10) !PartBound%SymmetryBC
 !-----------------------------------------------------------------------------------------------------------------------------------
   BCSideID=PartBCSideList(SideID)
-  CALL PerfectReflection(&
-    PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap,BCSideID=BCSideID,opt_Symmetry=.TRUE.)
-
+  CALL PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID,IsSpeciesSwap &
+                        ,BCSideID=BCSideID,opt_Symmetry=.TRUE.,opt_reflected=reflected)
 
 CASE DEFAULT
 CALL abort(&
@@ -387,7 +393,8 @@ END SELECT !PartBound%MapToPartBC(BC(SideID)
 END SUBROUTINE GetBoundaryInteractionRef
 
 
-SUBROUTINE PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,PartID,SideID,IsSpeciesSwap,BCSideID,opt_Symmetry)
+SUBROUTINE PerfectReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,PartID,SideID,IsSpeciesSwap,BCSideID,opt_Symmetry&
+                                           ,opt_Reflected)
 !----------------------------------------------------------------------------------------------------------------------------------!
 ! Computes the perfect reflection in 3D
 !----------------------------------------------------------------------------------------------------------------------------------!
@@ -426,6 +433,7 @@ INTEGER,INTENT(IN),OPTIONAL       :: BCSideID
 LOGICAL,INTENT(IN),OPTIONAL       :: opt_Symmetry
 !----------------------------------------------------------------------------------------------------------------------------------!
 ! OUTPUT VARIABLES
+LOGICAL,INTENT(OUT),OPTIONAL      :: opt_Reflected
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 REAL                                 :: v_old(1:3),v_2(1:3),v_aux(1:3),n_loc(1:3), v_help(3), WallVelo(3)
@@ -452,7 +460,7 @@ WallVelo=PartBound%WallVelo(1:3,PartBound%MapToPartBC(BC(SideID)))
 
 IF(PRESENT(BCSideID))THEN
   SELECT CASE(SideType(BCSideID))
-  CASE(PLANAR_RECT,PLANAR_NONRECT)
+  CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
     n_loc=SideNormVec(1:3,BCSideID)
   CASE(BILINEAR)
     CALL CalcNormAndTangBilinear(nVec=n_loc,xi=xi,eta=eta,SideID=BCSideID)
@@ -461,7 +469,7 @@ IF(PRESENT(BCSideID))THEN
   END SELECT 
 ELSE
   SELECT CASE(SideType(SideID))
-  CASE(PLANAR_RECT,PLANAR_NONRECT)
+  CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
     n_loc=SideNormVec(1:3,SideID)
   CASE(BILINEAR)
     CALL CalcNormAndTangBilinear(nVec=n_loc,xi=xi,eta=eta,SideID=SideID)
@@ -475,7 +483,12 @@ ELSE
   Symmetry = .FALSE.
 END IF
 
-IF(DOT_PRODUCT(PartTrajectory,n_loc).LE.0.) RETURN
+IF(DOT_PRODUCT(PartTrajectory,n_loc).LE.0.) THEN
+  IF(PRESENT(opt_Reflected)) opt_Reflected=.FALSE.
+  RETURN
+ELSE
+  IF(PRESENT(opt_Reflected)) opt_Reflected=.TRUE.
+END IF
 
 ! In vector notation: r_neu = r_alt + T - 2*((1-alpha)*<T,n>)*n
 v_aux                  = -2.0*((LengthPartTrajectory-alpha)*DOT_PRODUCT(PartTrajectory(1:3),n_loc))*n_loc
@@ -490,10 +503,10 @@ v_aux                  = -2.0*((LengthPartTrajectory-alpha)*DOT_PRODUCT(PartTraj
   PartState(PartID,1:3)   = PartState(PartID,1:3)+v_aux
   v_old = PartState(PartID,4:6)
 
-  ! move particle a bit in interior
-  ElemID=PartSideToElem(S2E_ELEM_ID,SideID)
-  v_help=LastPartPos(PartID,1:3)-ElemBaryNGeo(1:3,ElemID)
-  LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*MAX(1.0-epsInCell/SQRT(DOT_PRODUCT(v_help,v_help)),0.)
+ ! ! move particle a bit in interior
+ ! ElemID=PartSideToElem(S2E_ELEM_ID,SideID)
+ ! v_help=LastPartPos(PartID,1:3)-ElemBaryNGeo(1:3,ElemID)
+ ! LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*MAX(1.0-epsInCell/SQRT(DOT_PRODUCT(v_help,v_help)),0.)
 
   ! new velocity vector 
   !v_2=(1-alpha)*PartTrajectory(1:3)+v_aux
@@ -604,7 +617,7 @@ __STAMP__&
 END SUBROUTINE PerfectReflection
 
 
-SUBROUTINE DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,PartID,SideID,IsSpeciesSwap,BCSideID)
+SUBROUTINE DiffuseReflection(PartTrajectory,lengthPartTrajectory,alpha,xi,eta,PartID,SideID,IsSpeciesSwap,BCSideID,opt_Reflected)
 !----------------------------------------------------------------------------------------------------------------------------------!
 ! Computes the diffuse reflection in 3D
 ! only implemented for DoRefMapping tracking
@@ -640,6 +653,7 @@ LOGICAL,INTENT(IN)                :: IsSpeciesSwap
 INTEGER,INTENT(IN),OPTIONAL       :: BCSideID
 !----------------------------------------------------------------------------------------------------------------------------------!
 ! OUTPUT VARIABLES
+LOGICAL,INTENT(OUT),OPTIONAL      :: Opt_Reflected
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 INTEGER                              :: locBCID, vibQuant, vibQuantNew, VibQuantWall
@@ -678,7 +692,7 @@ RotACC       = PartBound%RotACC(locBCID)
 
 IF(PRESENT(BCSideID))THEN
   SELECT CASE(SideType(BCSideID))
-  CASE(PLANAR_RECT,PLANAR_NONRECT)
+  CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
     n_loc=SideNormVec(1:3,BCSideID)
     tang1=UNITVECTOR(BezierControlPoints3D(:,NGeo,0,BCSideID)-BezierControlPoints3D(:,0,0,BCSideID))
     tang2=CROSSNORM(n_loc,tang1)
@@ -691,7 +705,7 @@ IF(PRESENT(BCSideID))THEN
   END SELECT 
 ELSE
   SELECT CASE(SideType(SideID))
-  CASE(PLANAR_RECT,PLANAR_NONRECT)
+  CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
     n_loc=SideNormVec(1:3,SideID)
     tang1=UNITVECTOR(BezierControlPoints3D(:,NGeo,0,SideID)-BezierControlPoints3D(:,0,0,SideID))
     tang2=CROSSNORM(n_loc,tang1)
@@ -704,7 +718,12 @@ ELSE
   END SELECT 
 END IF
 
-IF(DOT_PRODUCT(n_loc,PartTrajectory).LT.0.)  RETURN
+IF(DOT_PRODUCT(n_loc,PartTrajectory).LT.0.)  THEN
+  IF(PRESENT(opt_Reflected)) opt_Reflected=.FALSE.
+  RETURN
+ELSE
+  IF(PRESENT(opt_Reflected)) opt_Reflected=.TRUE.
+END IF
 
 ! calculate new velocity vector (Extended Maxwellian Model)
 VeloReal = SQRT(PartState(PartID,4) * PartState(PartID,4) + &
@@ -756,10 +775,11 @@ NewVelo = VeloCx*tang1-tang2*VeloCy-VeloCz*n_loc
 ! intersection point with surface
 LastPartPos(PartID,1:3) = LastPartPos(PartID,1:3) + PartTrajectory(1:3)*alpha
 
-ElemID=PartSideToElem(S2E_ELEM_ID,SideID)
-v_help=LastPartPos(PartID,1:3)-ElemBaryNGeo(1:3,ElemID)
-!LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*MAX(1.0-epsInCell/SQRT(DOT_PRODUCT(v_help,v_help)),0.)
-LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*(1.0-epsInCell)
+! should not be required any-more
+!ElemID=PartSideToElem(S2E_ELEM_ID,SideID)
+!v_help=LastPartPos(PartID,1:3)-ElemBaryNGeo(1:3,ElemID)
+!!LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*MAX(1.0-epsInCell/SQRT(DOT_PRODUCT(v_help,v_help)),0.)
+!LastPartPos(PartID,1:3)=ElemBaryNGeo(1:3,ElemID)+v_help*(1.0-epsInCell)
 
 ! recompute initial position and ignoring preceding reflections and trajectory between current position and recomputed position
 !TildPos       =PartState(PartID,1:3)-dt*RKdtFrac*PartState(PartID,4:6)
diff --git a/src/particles/boundary/particle_boundary_sampling.f90 b/src/particles/boundary/particle_boundary_sampling.f90
index 85edf0a..cd43538 100644
--- a/src/particles/boundary/particle_boundary_sampling.f90
+++ b/src/particles/boundary/particle_boundary_sampling.f90
@@ -928,8 +928,8 @@ FileString=TRIM(FileName)//'.h5'
 
 
 ! Generate skeleton for the file with all relevant data on a single proc (MPIRoot)
-IF(SurfCOMM%MPIOutputRoot)THEN
 #ifdef MPI
+IF(SurfCOMM%MPIOutputRoot)THEN
   CALL OpenDataFile(FileString,create=.TRUE.,single=.TRUE.)
 #else
   CALL OpenDataFile(FileString,create=.TRUE.)
@@ -959,9 +959,9 @@ IF(SurfCOMM%MPIOutputRoot)THEN
 
   CALL CloseDataFile()
   DEALLOCATE(StrVarNames)
+#ifdef MPI
 END IF
 
-#ifdef MPI
 CALL MPI_BARRIER(SurfCOMM%OutputCOMM,iERROR)
 #endif /*MPI*/
 
diff --git a/src/particles/particle_emission.f90 b/src/particles/particle_emission.f90
index 571c069..8f929ef 100644
--- a/src/particles/particle_emission.f90
+++ b/src/particles/particle_emission.f90
@@ -3697,7 +3697,7 @@ __STAMP__&
             CASE(PLANAR_RECT,PLANAR_NONRECT)
               LastPartPos(ParticleIndexNbr,1:3)=ElemBaryNGeo(1:3,ElemID) &
               + (PartState(ParticleIndexNbr,1:3)-ElemBaryNGeo(1:3,ElemID)) * (1.0-epsInCell)
-            CASE(BILINEAR,CURVED) !to be changed into more efficient method using known xi
+            CASE(BILINEAR,CURVED,PLANAR_CURVED) !to be changed into more efficient method using known xi
               CALL Eval_xyz_ElemCheck(PartState(ParticleIndexNbr,1:3),Particle_pos(1:3),ElemID) !RefMap PartState
               DO iLoop=1,3 !shift border-RefCoords into elem
                 IF( ABS(Particle_pos(iLoop)) .GT. 1.0-epsInCell ) THEN
diff --git a/src/particles/particle_init.f90 b/src/particles/particle_init.f90
index 41a0fd3..4894402 100644
--- a/src/particles/particle_init.f90
+++ b/src/particles/particle_init.f90
@@ -1020,8 +1020,8 @@ SWRITE(UNIT_stdOut,'(A)')' INIT FIBGM...'
 SafetyFactor  =GETREAL('Part-SafetyFactor','1.0')
 halo_eps_velo =GETREAL('Particles-HaloEpsVelo','0')
 !-- Finalizing InitializeVariables
-!CALL InitFIBGM()
-CALL InitSFIBGM()
+CALL InitFIBGM()
+!CALL InitSFIBGM()
 #ifdef MPI
 CALL InitEmissionComm()
 #endif /*MPI*/
diff --git a/src/particles/particle_mesh/particle_mesh.f90 b/src/particles/particle_mesh/particle_mesh.f90
index 144f6ca..a8a3d4e 100644
--- a/src/particles/particle_mesh/particle_mesh.f90
+++ b/src/particles/particle_mesh/particle_mesh.f90
@@ -78,11 +78,17 @@ INTERFACE GetElemAndSideType
   MODULE PROCEDURE GetElemAndSideType
 END INTERFACE
 
+INTERFACE PartInElemCheck
+  MODULE PROCEDURE PartInElemCheck
+END INTERFACE
+
+
 PUBLIC::CountPartsPerElem
 PUBLIC::BuildElementBasis,CheckIfCurvedElem,BuildElementOrigin
 PUBLIC::InitElemVolumes,MapRegionToElem,PointToExactElement
 PUBLIC::InitParticleMesh,FinalizeParticleMesh, InitFIBGM,InitSFIBGM, SingleParticleToExactElement, SingleParticleToExactElementNoMap
 PUBLIC::InsideElemBoundingBox
+PUBLIC::PartInElemCheck
 !===================================================================================================================================
 !
 CONTAINS
@@ -97,7 +103,7 @@ USE MOD_Preproc
 USE MOD_Particle_Mesh_Vars
 USE MOD_Particle_Surfaces_Vars, ONLY:BezierEpsilonBilinear,BezierElevation,BezierControlPoints3DElevated
 USE MOD_Particle_Tracking_Vars, ONLY:DoRefMapping,MeasureTrackTime,FastPeriodic
-USE MOD_Mesh_Vars,              ONLY:nElems,nSides,SideToElem,ElemToSide,NGeo
+USE MOD_Mesh_Vars,              ONLY:nElems,nSides,SideToElem,ElemToSide,NGeo,NGeoElevated
 USE MOD_ReadInTools,            ONLY:GETREAL,GETINT,GETLOGICAL,GetRealArray
 USE MOD_Particle_Surfaces_Vars, ONLY:BezierSampleN,BezierSampleXi
 ! IMPLICIT VARIABLE HANDLING
@@ -160,6 +166,7 @@ END IF
 BezierEpsilonBilinear = GETREAL('BezierEpsilonBilinear','1e-6')
 
 BezierElevation = GETINT('BezierElevation','0')
+NGeoElevated    = NGeo + BezierElevation
 SDEALLOCATE(BezierControlPoints3DElevated)
 ALLOCATE(BezierControlPoints3DElevated(1:3,0:NGeo+BezierElevation,0:NGeo+BezierElevation,1:nSides) &
         ,STAT=ALLOCSTAT )
@@ -285,7 +292,6 @@ USE MOD_Particle_Tracking_Vars, ONLY:DoRefMapping
 USE MOD_Particle_Mesh_Vars,     ONLY:epsInCell,epsOneCell,ElemBaryNGeo,IsBCElem,ElemRadius2NGeo
 USE MOD_Eval_xyz,               ONLY:eval_xyz_elemcheck
 USE MOD_Utils,                  ONLY:InsertionSort !BubbleSortID
-USE MOD_Particle_Intersection,  ONLY:PartInElemCheck
 USE MOD_Particle_Tracking_Vars, ONLY:DoRefMapping,Distance,ListDistance
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE                                                                                   
@@ -320,26 +326,20 @@ END IF
 
 ! --- get background mesh cell of particle
 CellX = CEILING((PartState(iPart,1)-GEO%xminglob)/GEO%FIBGMdeltas(1)) 
-CellX = MAX(MIN(GEO%FIBGMimax,CellX),GEO%FIBGMimin)
+CellX = MAX(MIN(GEO%TFIBGMimax,CellX),GEO%TFIBGMimin)
 CellY = CEILING((PartState(iPart,2)-GEO%yminglob)/GEO%FIBGMdeltas(2))
-CellY = MAX(MIN(GEO%FIBGMjmax,CellY),GEO%FIBGMjmin)
+CellY = MAX(MIN(GEO%TFIBGMjmax,CellY),GEO%TFIBGMjmin)
 CellZ = CEILING((PartState(iPart,3)-GEO%zminglob)/GEO%FIBGMdeltas(3))
-CellZ = MAX(MIN(GEO%FIBGMkmax,CellZ),GEO%FIBGMkmin)
-
-
-
-!   print*,'cell indices',CellX,CellY,CellZ
-!   print*,'number of cells in bgm',GEO%FIBGM(CellX,CellY,CellZ)%nElem
-!   read*
+CellZ = MAX(MIN(GEO%TFIBGMkmax,CellZ),GEO%TFIBGMkmin)
 
 !--- check all cells associated with this beckground mesh cell
-nBGMElems=GEO%FIBGM(CellX,CellY,CellZ)%nElem
+nBGMElems=GEO%TFIBGM(CellX,CellY,CellZ)%nElem
 
 ! get closest element barycenter
 Distance=-1.
 ListDistance=0
 DO iBGMElem = 1, nBGMElems
-  ElemID = GEO%FIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
+  ElemID = GEO%TFIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
   Distance2=(PartState(iPart,1)-ElemBaryNGeo(1,ElemID))*(PartState(iPart,1)-ElemBaryNGeo(1,ElemID)) &
            +(PartState(iPart,2)-ElemBaryNGeo(2,ElemID))*(PartState(iPart,2)-ElemBaryNGeo(2,ElemID)) &
            +(PartState(iPart,3)-ElemBaryNGeo(3,ElemID))*(PartState(iPart,3)-ElemBaryNGeo(3,ElemID)) 
@@ -356,7 +356,6 @@ IF(ALMOSTEQUAL(MAXVAL(Distance),-1.))THEN
   RETURN
 END IF
 
-!print*,'earlier',Distance,ListDistance
 !CALL BubbleSortID(Distance,ListDistance,nBGMElems)
 IF(nBGMElems.GT.1) CALL InsertionSort(Distance(1:nBGMElems),ListDistance(1:nBGMElems),nBGMElems)
 
@@ -368,7 +367,7 @@ DO iBGMElem=1,nBGMElems
     IF(ElemID.GT.PP_nElems) CYCLE
   END IF
   IF(IsBCElem(ElemID))THEN
-    CALL PartInElemCheck(iPart,ElemID,InElementCheck)
+    CALL PartInElemCheck(PartState(iPart,1:3),iPart,ElemID,InElementCheck)
     IF(.NOT.InElementCheck) CYCLE
   END IF
 
@@ -378,31 +377,6 @@ DO iBGMElem=1,nBGMElems
   ELSE ! particle at face,edge or node, check most possible point
     InElementCheck=.FALSE.
   END IF
-
-
-!  IF(MAXVAL(ABS(Xi)).LE.1.0) THEN ! particle inside
-!    InElementCheck=.TRUE.
-!  ELSE IF(MAXVAL(ABS(Xi)).GT.epsOneCell(ElemID))THEN ! particle outside
-!  !  print*,'ici'
-!    InElementCheck=.FALSE.
-!  ELSE ! particle at face,edge or node, check most possible point
-!    ! alter particle position
-!    ! 1) compute vector to cell centre
-!    vBary=ElemBaryNGeo(1:3,ElemID)-PartState(iPart,1:3)
-!    ! 2) move particle pos along vector
-!    PartState(iPart,1:3) = PartState(iPart,1:3)+epsInCell*VBary(1:3)
-!    CALL Eval_xyz_elemcheck(PartState(iPart,1:3),xi,ElemID)
-!    !print*,xi
-!    IF(ALL(ABS(Xi).LE.1.0)) THEN ! particle inside
-!      InElementCheck=.TRUE.
-!    ELSE
-!!      IPWRITE(UNIT_stdOut,*) ' PartPos', PartState(iPart,1:3)
-!!      IPWRITE(UNIT_stdOut,*) ' xi',      XI(1:3)
-!      !SWRITE(*,*) ' Particle not located!'
-!      !SWRITE(*,*) ' PartPos', PartState(iPart,1:3)
-!      InElementCheck=.FALSE.
-!    END IF
-!  END IF
   IF (InElementCheck) THEN !  !     print*,Element
  ! read*
     PEM%Element(iPart) = ElemID
@@ -436,7 +410,7 @@ USE MOD_Particle_Surfaces_Vars, ONLY:epsilontol,BezierControlPoints3D,SideType
 USE MOD_Utils,                  ONLY:InsertionSort !BubbleSortID
 USE MOD_Particle_Intersection,  ONLY:ComputePlanarInterSectionBezier,ComputeBilinearIntersectionSuperSampled2
 USE MOD_Particle_Intersection,  ONLY:ComputeBezierIntersection
-USE MOD_Particle_Intersection,  ONLY:ComputePlanarIntersectionBezierRobust,ComputeBiLinearIntersectionRobust
+USE MOD_Particle_Intersection,  ONLY:ComputePlanarRectIntersection,ComputeBiLinearIntersectionRobust
 USE MOD_Particle_Tracking_Vars, ONLY:Distance,ListDistance
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE                                                                                   
@@ -453,16 +427,10 @@ LOGICAL,INTENT(IN)                :: doHalo
 INTEGER                           :: iBGMElem,nBGMElems, ElemID, CellX,CellY,CellZ
 !-----------------------------------------------------------------------------------------------------------------------------------
 INTEGER                           :: ilocSide,SideID,flip
-LOGICAL                           :: ParticleFound,isHit
-REAL                              :: lengthPartTrajectory,tmpPos(3),xNodes(1:3,1:4),tmpLastPartPos(1:3),Distance2
-REAL,PARAMETER                    :: eps=1e-8 ! same value as in eval_xyz_elem
-REAL,PARAMETER                    :: eps2=1e-3
-REAL                              :: epsOne,OneMeps,locAlpha(6),xi,eta
-REAL                              :: PartTrajectory(1:3)
+LOGICAL                           :: ParticleFound,InElementCheck
+REAL                              :: Distance2
 !===================================================================================================================================
 
-epsOne=1.0+eps
-OneMeps=1.0-eps
 ParticleFound = .FALSE.
 IF ( (PartState(iPart,1).LT.GEO%xmin).OR.(PartState(iPart,1).GT.GEO%xmax).OR. &
      (PartState(iPart,2).LT.GEO%ymin).OR.(PartState(iPart,2).GT.GEO%ymax).OR. &
@@ -473,21 +441,23 @@ END IF
 
 ! --- get background mesh cell of particle
 CellX = CEILING((PartState(iPart,1)-GEO%xminglob)/GEO%FIBGMdeltas(1)) 
-CellX = MAX(MIN(GEO%FIBGMimax,CellX),GEO%FIBGMimin)
+CellX = MAX(MIN(GEO%TFIBGMimax,CellX),GEO%TFIBGMimin)
 CellY = CEILING((PartState(iPart,2)-GEO%yminglob)/GEO%FIBGMdeltas(2))
-CellY = MAX(MIN(GEO%FIBGMjmax,CellY),GEO%FIBGMjmin)
+CellY = MAX(MIN(GEO%TFIBGMjmax,CellY),GEO%TFIBGMjmin)
 CellZ = CEILING((PartState(iPart,3)-GEO%zminglob)/GEO%FIBGMdeltas(3))
-CellZ = MAX(MIN(GEO%FIBGMkmax,CellZ),GEO%FIBGMkmin)
+CellZ = MAX(MIN(GEO%TFIBGMkmax,CellZ),GEO%TFIBGMkmin)
 
 !--- check all cells associated with this beckground mesh cell
 
-nBGMElems=GEO%FIBGM(CellX,CellY,CellZ)%nElem
+nBGMElems=GEO%TFIBGM(CellX,CellY,CellZ)%nElem
+
 
 ! get closest element barycenter
 Distance=-1.
+
 ListDistance=0
 DO iBGMElem = 1, nBGMElems
-  ElemID = GEO%FIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
+  ElemID = GEO%TFIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
   IF(.NOT.DoHALO)THEN
     IF(ElemID.GT.PP_nElems) CYCLE
   END IF
@@ -510,9 +480,6 @@ END IF
 !CALL BubbleSortID(Distance,ListDistance,nBGMElems)
 IF(nBGMElems.GT.1) CALL InsertionSort(Distance(1:nBGMElems),ListDistance(1:nBGMElems),nBGMElems)
 ! loop through sorted list and start by closest element  
-tmpPos=PartState(iPart,1:3)
-tmpLastPartPos(1:3)=LastPartPos(iPart,1:3)
-LastPartPos(iPart,1:3)=PartState(iPart,1:3)
 
 DO iBGMElem=1,nBGMElems
   IF(ALMOSTEQUAL(Distance(iBGMElem),-1.))CYCLE
@@ -520,86 +487,16 @@ DO iBGMElem=1,nBGMElems
   IF(.NOT.DoHALO)THEN
     IF(ElemID.GT.PP_nElems) CYCLE
   END IF
-  PartState(iPart,1:3)=ElemBaryNGeo(:,ElemID)
-  PartTrajectory=PartState(iPart,1:3) - LastPartPos(iPart,1:3)
-  lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
-                           +PartTrajectory(2)*PartTrajectory(2) &
-                           +PartTrajectory(3)*PartTrajectory(3) )
-  PartTrajectory=PartTrajectory/lengthPartTrajectory
-  lengthPartTrajectory=lengthPartTrajectory+epsilontol
-  locAlpha=1.
-  DO ilocSide=1,6
-    !SideID=ElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
-    SideID=PartElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
-    flip  = PartElemToSide(E2S_FLIP,ilocSide,ElemID)
-    SELECT CASE(SideType(SideID))
-!    CASE(PLANAR_RECT)
-!      CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                              ,xi                 &
-!                                                                              ,eta             ,iPart,flip,SideID)
-!                                                                              !,eta             ,iPart,ilocSide,SideID,ElemID)
-!    CASE(BILINEAR,PLANAR_NONRECT)
-!      xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
-!      xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
-!      xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
-!      xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
-!      CALL ComputeBiLinearIntersectionSuperSampled2(ishit,xNodes &
-!                                                          ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                                        ,xi                       &
-!                                                                                        ,eta                ,iPart,flip,SideID)
-! 
-!
-!
-!!      CALL ComputeBiLinearIntersectionSuperSampled2(ishit,[BezierControlPoints3D(1:3,0   ,0   ,SideID)  &
-!!                                                          ,BezierControlPoints3D(1:3,NGeo,0   ,SideID)  &
-!!                                                          ,BezierControlPoints3D(1:3,NGeo,NGeo,SideID)  &
-!!                                                          ,BezierControlPoints3D(1:3,0   ,NGeo,SideID)] &
-!!                                                          ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!!                                                                                        ,xi                       &
-!                                                                                        !,eta                ,iPart,flip,SideID)
-!    CASE(CURVED)
-!      CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                              ,xi                 &
-!                                                                              ,eta                ,iPart,SideID)
-!    END SELECT
-
-    CASE(PLANAR_RECT)
-      CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                              ,xi,eta ,iPart,flip,SideID)
-
-!      CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                                    ,xi,eta  ,iPart,flip,SideID)
-    CASE(BILINEAR)
-      xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
-      xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
-      xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
-      xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
-      CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
-                                            ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                                        ,xi,eta,iPart,flip,SideID)
-
-
-    CASE(CURVED,PLANAR_NONRECT)
-      CALL ComputeBezierIntersection(ishit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                              ,xi ,eta,iPart,SideID)
-
-    END SELECT
-
-    !IF(locAlpha(ilocSide).GT.-1.0)THEN
-    !  IF((ABS(xi).GT.1.0).OR.(ABS(eta).GT.1.0)) locAlpha(ilocSide)=-1.0
-    !END IF
-  END DO ! ilocSide
-  IF(ALMOSTEQUAL(MAXVAL(locAlpha(:)),-1.0))THEN
+  CALL PartInElemCheck(PartState(iPart,1:3),iPart,ElemID,InElementCheck)
+
+  IF(InElementCheck)THEN
     ! no intersection found and particle is in final element
-    PartState(iPart,1:3)=tmpPos
-    LastPartPos(iPart,1:3)=tmpLastPartPos
     PEM%Element(iPart) = ElemID
     ParticleFound=.TRUE.
     EXIT
   END IF
 END DO ! iBGMElem
 
-
 ! particle not found
 IF (.NOT.ParticleFound) THEN
   PDM%ParticleInside(iPart) = .FALSE.
@@ -607,6 +504,110 @@ END IF
 END SUBROUTINE SingleParticleToExactElementNoMap
 
 
+SUBROUTINE PartInElemCheck(PartPos_In,PartID,ElemID,Check)
+!===================================================================================================================================
+! Checks if particle is in Element
+!===================================================================================================================================
+! MODULES
+USE MOD_Globals,                ONLY:Almostzero
+USE MOD_Mesh_Vars,              ONLY:NGeo
+USE MOD_Particle_Mesh_Vars,     ONLY:ElemBaryNGeo
+USE MOD_Particle_Surfaces_Vars, ONLY:BezierControlPoints3D,SideType,BezierControlPoints3D,SideNormVec
+USE MOD_Particle_Mesh_Vars,     ONLY:PartElemToSide,PartBCSideList
+USE MOD_Particle_Surfaces,      ONLY:CalcNormAndTangBilinear,CalcNormAndTangBezier
+USE MOD_Particle_Intersection,  ONLY:ComputePlanarIntersectionBezier,ComputePlanarNonrectIntersection
+USE MOD_Particle_Intersection,  ONLY:ComputeBiLinearIntersectionRobust,ComputeBezierIntersection
+USE MOD_Particle_Tracking_Vars, ONLY:DoRefMapping
+USE MOD_Particle_Vars,          ONLY:PartState,LastPartPos
+! IMPLICIT VARIABLE HANDLING
+IMPLICIT NONE
+! INPUT VARIABLES
+!-----------------------------------------------------------------------------------------------------------------------------------
+! INPUT VARIABLES
+INTEGER,INTENT(IN)                       :: ElemID,PartID
+REAL,INTENT(IN)                          :: PartPos_In(1:3)
+!-----------------------------------------------------------------------------------------------------------------------------------
+! OUTPUT VARIABLES
+LOGICAL,INTENT(OUT)                      :: Check
+!-----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER                                  :: ilocSide,flip,SideID,BCSideID
+REAL                                     :: PartTrajectory(1:3),NormVec(1:3)
+REAL                                     :: lengthPartTrajectory,PartPos(1:3),LastPosTmp(1:3),xNodes(1:3,1:4)
+LOGICAL                                  :: isHit
+REAL                                     :: alpha,eta,xi
+!===================================================================================================================================
+
+! virtual move to element barycenter
+LastPosTmp(1:3) =LastPartPos(PartID,1:3)
+LastPartPos(PartID,1:3) =ElemBaryNGeo(1:3,ElemID)
+PartPos(1:3) =PartPos_In(1:3)
+PartTrajectory=PartPos - LastPartPos(PartID,1:3)
+lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
+                         +PartTrajectory(2)*PartTrajectory(2) &
+                         +PartTrajectory(3)*PartTrajectory(3) )
+IF(ALMOSTZERO(lengthPartTrajectory))THEN
+  Check=.TRUE.
+  LastPartPos(PartID,1:3) = LastPosTmp(1:3) 
+  ! bugfix by Tilman
+  RETURN
+END IF
+PartTrajectory=PartTrajectory/lengthPartTrajectory
+isHit=.FALSE.
+DO ilocSide=1,6
+  !SideID=ElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
+  SideID=PartElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
+  flip  = PartElemToSide(E2S_FLIP,ilocSide,ElemID)
+  IF(DoRefMapping)THEN
+    IF(SideID.LT.1) CYCLE
+    BCSideID=SideID
+    SideID=PartBCSideList(BCSideID)
+    IF(SideID.LT.1) CYCLE
+  END IF
+  
+  SELECT CASE(SideType(SideID))
+  CASE(PLANAR_RECT)
+    CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta ,PartID,flip,SideID)
+  CASE(PLANAR_NONRECT)
+    CALL ComputePlanarNonrectIntersection(isHit,PartTrajectory,lengthPartTrajectory,Alpha,xi,eta,PartID,flip,SideID)
+  CASE(BILINEAR)
+    xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
+    xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
+    xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
+    xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
+    CALL ComputeBiLinearIntersectionRobust(isHit,xNodes,PartTrajectory,lengthPartTrajectory,Alpha,xi,eta,PartID,flip,SideID)
+  CASE(CURVED,PLANAR_CURVED)
+    CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,Alpha,xi,eta,PartID,SideID)
+  END SELECT
+  IF(DoRefMapping)THEN
+    IF(alpha.GT.-1)THEN
+      SELECT CASE(SideType(SideID))
+      CASE(PLANAR_RECT,PLANAR_NONRECT,PLANAR_CURVED)
+        NormVec=SideNormVec(1:3,SideID)
+      CASE(BILINEAR)
+        CALL CalcNormAndTangBilinear(nVec=NormVec,xi=xi,eta=eta,SideID=SideID)
+      CASE(CURVED)
+        CALL CalcNormAndTangBezier(nVec=NormVec,xi=xi,eta=eta,SideID=SideID)
+      END SELECT 
+      IF(DOT_PRODUCT(NormVec,PartState(PartID,4:6)).LT.0.) alpha=-1.0
+    END IF
+  END IF
+  IF(alpha.GT.-1.0) THEN
+    !IF((ABS(xi).GT.1.0).OR.(ABS(eta).GT.1.0)) THEN
+    !IF((ABS(xi).GT.BezierClipHit).OR.(ABS(eta).GT.BezierClipHit)) THEN
+    !  isHit=.FALSE.
+    !END IF
+    isHit=.TRUE.
+  END IF
+  IF(isHit) EXIT
+END DO ! ilocSide
+Check=.TRUE.
+IF(isHit) Check=.FALSE.
+LastPartPos(PartID,1:3) = LastPosTmp(1:3) 
+
+END SUBROUTINE PartInElemCheck
+
+
 SUBROUTINE InitSFIBGM()
 !===================================================================================================================================
 ! Build Fast-Init-Background-Mesh.
@@ -623,8 +624,9 @@ USE MOD_Particle_Mesh_Vars,                 ONLY:XiEtaZetaBasis,ElemBaryNGeo,sle
 #ifdef MPI
 USE MOD_Particle_MPI,                       ONLY:InitSimpleHALOMesh
 USE MOD_Particle_MPI,                       ONLY:InitHALOMesh
-USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI,printMPINeighborWarnings
+USE MOD_Particle_MPI_Vars,                  ONLY:printMPINeighborWarnings
 #endif /*MPI*/
+USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
 ! INPUT VARIABLES
@@ -634,9 +636,7 @@ IMPLICIT NONE
 ! OUTPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-#ifdef MPI
 REAL                     :: StartT,EndT
-#endif /*MPI*/
 !=================================================================================================================================
 
 !! Read parameter for FastInitBackgroundMesh (FIBGM)
@@ -646,6 +646,7 @@ GEO%FIBGMdeltas(1:3) = 1./GEO%FactorFIBGM(1:3) * GEO%FIBGMdeltas(1:3)
 
 ! simplified halo region
 ! compute elem bary and elem radius
+StartT=BOLTZPLATZTIME()
 ALLOCATE(ElemBaryNGeo(1:3,1:nTotalElems) )
 CALL BuildElementOrigin()
 ALLOCATE(XiEtaZetaBasis(1:3,1:6,1:nTotalElems) &
@@ -653,15 +654,26 @@ ALLOCATE(XiEtaZetaBasis(1:3,1:6,1:nTotalElems) &
         ,ElemRadiusNGeo(1:nTotalElems)         &
         ,ElemRadius2NGeo(1:nTotalElems)        )
 CALL BuildElementBasis()
+EndT=BOLTZPLATZTIME()
+IF(PartMPI%MPIROOT)THEN
+  WRITE(UNIT_stdOut,'(A,F12.3,A)',ADVANCE='YES')' Init element-basis took          [',EndT-StartT,'s]'
+END IF
 
+StartT=BOLTZPLATZTIME()
 CALL GetSFIBGM()
+EndT=BOLTZPLATZTIME()
+IF(PartMPI%MPIROOT)THEN
+  WRITE(UNIT_stdOut,'(A,F12.3,A)',ADVANCE='YES')' Init FIBGM took                  [',EndT-StartT,'s]'
+END IF
 
 #ifdef MPI
 SWRITE(UNIT_stdOut,'(A)')' INIT HALO REGION...' 
-StartT=MPI_WTIME()
+StartT=BOLTZPLATZTIME()
 !CALL Initialize()  ! Initialize parallel environment for particle exchange between MPI domains
 printMPINeighborWarnings = GETLOGICAL('printMPINeighborWarnings','.TRUE.')
 CALL InitSimpleHaloMesh()
+#else
+StartT=BOLTZPLATZTIME()
 #endif /*MPI*/
 
 ! remove inner BezierControlPoints3D and SlabNormals, usw.
@@ -681,15 +693,13 @@ ALLOCATE(XiEtaZetaBasis(1:3,1:6,1:nTotalElems) &
 CALL BuildElementBasis()
 
 
-#ifdef MPI
 ! HALO mesh and region build. Unfortunately, the local FIBGM has to be extended to include the HALO elements :(
 ! rebuild is a local operation
 CALL AddSimpleHALOCellsToFIBGM()
-EndT=MPI_WTIME()
+EndT=BOLTZPLATZTIME()
 IF(PartMPI%MPIROOT)THEN
    WRITE(UNIT_stdOut,'(A,F12.3,A)',ADVANCE='YES')' Construction of halo region took [',EndT-StartT,'s]'
 END IF
-#endif /*MPI*/
 
 !CALL MapElemToFIBGM()
 
@@ -727,6 +737,8 @@ IMPLICIT NONE
 #ifdef MPI
 REAL                     :: StartT,EndT
 #endif /*MPI*/
+INTEGER                  :: iElem,ElemToBGM(1:6,1:PP_nElems)
+INTEGER,ALLOCATABLE      :: HaloElemToBGM(:,:)
 !=================================================================================================================================
 
 !! Read parameter for FastInitBackgroundMesh (FIBGM)
@@ -734,24 +746,59 @@ GEO%FIBGMdeltas(1:3) = GETREALARRAY('Part-FIBGMdeltas',3,'1. , 1. , 1.')
 GEO%FactorFIBGM(1:3) = GETREALARRAY('Part-FactorFIBGM',3,'1. , 1. , 1.')
 GEO%FIBGMdeltas(1:3) = 1./GEO%FactorFIBGM(1:3) * GEO%FIBGMdeltas(1:3)
 
-CALL GetFIBGM()
+! compute elem bary and elem radius
+StartT=BOLTZPLATZTIME()
 ALLOCATE(ElemBaryNGeo(1:3,1:nTotalElems) )
 CALL BuildElementOrigin()
+ALLOCATE(XiEtaZetaBasis(1:3,1:6,1:nTotalElems) &
+        ,slenXiEtaZetaBasis(1:6,1:nTotalElems) &
+        ,ElemRadiusNGeo(1:nTotalElems)         &
+        ,ElemRadius2NGeo(1:nTotalElems)        )
+CALL BuildElementBasis()
+EndT=BOLTZPLATZTIME()
+IF(PartMPI%MPIROOT)THEN
+  WRITE(UNIT_stdOut,'(A,F12.3,A)',ADVANCE='YES')' Init element-basis took          [',EndT-StartT,'s]'
+END IF
+
+StartT=BOLTZPLATZTIME()
+! get new min max
+CALL GetFIBGMminmax()
+! sort elem in bgm cells
+DO iElem=1,PP_nElems
+  CALL BGMIndexOfElement(iElem,ElemToBGM(1:6,iElem)) 
+END DO ! iElem = nElems+1,nTotalElems
+CALL GetFIBGM(ElemToBGM)
+EndT=BOLTZPLATZTIME()
+IF(PartMPI%MPIROOT)THEN
+  WRITE(UNIT_stdOut,'(A,F12.3,A)',ADVANCE='YES')' Init FIBGM took                  [',EndT-StartT,'s]'
+END IF
 
+StartT=BOLTZPLATZTIME()
 #ifdef MPI
 SWRITE(UNIT_stdOut,'(A)')' INIT HALO REGION...' 
-StartT=MPI_WTIME()
 !CALL Initialize()  ! Initialize parallel environment for particle exchange between MPI domains
 printMPINeighborWarnings = GETLOGICAL('printMPINeighborWarnings','.TRUE.')
 CALL InitHaloMesh()
 ! HALO mesh and region build. Unfortunately, the local FIBGM has to be extended to include the HALO elements :(
 ! rebuild is a local operation
-CALL AddHALOCellsToFIBGM()
+#endif /*MPI*/
+
+IF(nTotalElems.GT.PP_nElems)THEN
+  ALLOCATE(HaloElemToBGM(1:6,PP_nElems+1:nTotalElems))
+  DO iElem=PP_nElems+1,nTotalElems
+    CALL BGMIndexOfElement(iElem,HaloElemToBGM(1:6,iElem)) 
+  END DO ! iElem = nElems+1,nTotalElems
+  CALL AddHALOCellsToFIBGM(ElemToBGM,HaloElemToBGM)
+  DEALLOCATE(HaloElemToBGM)
+ELSE
+  CALL AddHALOCellsToFIBGM(ElemToBGM)
+END IF
+
+
 EndT=MPI_WTIME()
 IF(PartMPI%MPIROOT)THEN
    WRITE(UNIT_stdOut,'(A,F8.3,A)',ADVANCE='YES')' Construction of halo region took [',EndT-StartT,'s]'
 END IF
-#endif /*MPI*/
 
 ! remove inner BezierControlPoints3D and SlabNormals, usw.
 IF(DoRefMapping) CALL ReshapeBezierSides()
@@ -768,20 +815,18 @@ SDEALLOCATE(XiEtaZetaBasis)
 SDEALLOCATE(slenXiEtaZetaBasis)
 SDEALLOCATE(ElemRadiusNGeo)
 SDEALLOCATE(ElemRadius2NGeo)
-
 ALLOCATE(XiEtaZetaBasis(1:3,1:6,1:nTotalElems) &
         ,slenXiEtaZetaBasis(1:6,1:nTotalElems) &
         ,ElemRadiusNGeo(1:nTotalElems)         &
         ,ElemRadius2NGeo(1:nTotalElems)        )
 CALL BuildElementBasis()
-!CALL MapElemToFIBGM()
 
 SWRITE(UNIT_stdOut,'(A)')' DONE!' 
 
 END SUBROUTINE InitFIBGM
 
 
-SUBROUTINE GetFIBGM()
+SUBROUTINE GetFIBGM(ElemToBGM)
 !===================================================================================================================================
 ! build local FIBGM mesh for process local FIBGM mesh including HALO region
 ! mode 1: build local BGM and interconnections with other processes
@@ -820,13 +865,14 @@ USE MOD_Particle_Mesh_Vars,                 ONLY:NbrOfCases,casematrix
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
 !INTEGER,INTENT(IN)    :: mode
+INTEGER,INTENT(IN)     :: ElemToBGM(1:6,1:PP_nElems)
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 !REAL                  :: localXmin,localXmax,localymin,localymax,localzmin,localzmax
 INTEGER                          :: BGMimin,BGMimax,BGMjmin,BGMjmax,BGMkmin,BGMkmax
-REAL                             :: xmin, xmax, ymin, ymax, zmin, zmax
+!REAL                             :: xmin, xmax, ymin, ymax, zmin, zmax
 INTEGER                          :: iBGM,jBGM,kBGM,iElem,ilocSide,iSide,SideID
 INTEGER                          :: BGMCellXmax,BGMCellXmin
 INTEGER                          :: BGMCellYmax,BGMCellYmin
@@ -861,68 +907,15 @@ jj=0
 kk=0
 #endif /*MPI*/
 
-!#ifdef MPI
-!   !--- If this MPI process does not contain particles, step out
-!   IF (PMPIVAR%GROUP.EQ.MPI_GROUP_EMPTY) RETURN
-!#endif
-!--- calc min and max coordinates for mesh
-xmin = HUGE(1.0)
-xmax =-HUGE(1.0)
-ymin = HUGE(1.0)
-ymax =-HUGE(1.0)
-zmin = HUGE(1.0)
-zmax =-HUGE(1.0)
-
-! serch for min,max of BezierControlPoints, e.g. the convec hull of the domain
-! more accurate, XCL_NGeo
-!DO iElem=1,nTotalElems
-!  xmin=MIN(xmin,MINVAL(XCL_NGeo(1,:,:,:,iElem)))
-!  xmax=MAX(xmax,MAXVAL(XCL_NGeo(1,:,:,:,iElem)))
-!  ymin=MIN(ymin,MINVAL(XCL_NGeo(2,:,:,:,iElem)))
-!  ymax=MAX(ymax,MAXVAL(XCL_NGeo(2,:,:,:,iElem)))
-!  zmin=MIN(zmin,MINVAL(XCL_NGeo(3,:,:,:,iElem)))
-!  zmax=MAX(zmax,MAXVAL(XCL_NGeo(3,:,:,:,iElem)))
-!END DO ! iElem
-
-! bounding box!!
-DO iSide=1,nTotalSides
-  xmin=MIN(xmin,MINVAL(BezierControlPoints3D(1,:,:,iSide)))
-  xmax=MAX(xmax,MAXVAL(BezierControlPoints3D(1,:,:,iSide)))
-  ymin=MIN(ymin,MINVAL(BezierControlPoints3D(2,:,:,iSide)))
-  ymax=MAX(ymax,MAXVAL(BezierControlPoints3D(2,:,:,iSide)))
-  zmin=MIN(zmin,MINVAL(BezierControlPoints3D(3,:,:,iSide)))
-  zmax=MAX(zmax,MAXVAL(BezierControlPoints3D(3,:,:,iSide)))
-END DO ! iSide
-
-GEO%xmin=xmin
-GEO%xmax=xmax
-GEO%ymin=ymin
-GEO%ymax=ymax
-GEO%zmin=zmin
-GEO%zmax=zmax
 
 #ifdef MPI
   ! allocate and initialize MPINeighbor
   ALLOCATE(PartMPI%isMPINeighbor(0:PartMPI%nProcs-1))
   PartMPI%isMPINeighbor(:) = .FALSE.
   PartMPI%nMPINeighbors=0
-
-! get global min, max
-  CALL MPI_ALLREDUCE(GEO%xmin, GEO%xminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
-  CALL MPI_ALLREDUCE(GEO%ymin, GEO%yminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
-  CALL MPI_ALLREDUCE(GEO%zmin, GEO%zminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
-  CALL MPI_ALLREDUCE(GEO%xmax, GEO%xmaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
-  CALL MPI_ALLREDUCE(GEO%ymax, GEO%ymaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
-  CALL MPI_ALLREDUCE(GEO%zmax, GEO%zmaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
-#else
-  GEO%xminglob=GEO%xmin
-  GEO%yminglob=GEO%ymin
-  GEO%zminglob=GEO%zmin
-  GEO%xmaxglob=GEO%xmax
-  GEO%ymaxglob=GEO%ymax
-  GEO%zmaxglob=GEO%zmax
 #endif   
 
+
   CALL InitPeriodicBC()
   ! reduce beziercontrolpoints to boundary sides
   !IF(DoRefMapping) CALL ReshapeBezierSides()
@@ -1005,7 +998,6 @@ IF ((DepositionType.EQ.'shape_function')             &
 END IF
 #endif
 
-!print*,"BGM-Indices:",PartMPI%iProc, BGMimin, BGMimax, BGMjmin, BGMjmax, BGMkmin, BGMkmax
 GEO%FIBGMimax=BGMimax
 GEO%FIBGMimin=BGMimin
 GEO%FIBGMjmax=BGMjmax
@@ -1030,72 +1022,23 @@ __STAMP__&
 END IF
 
 ! null number of element per BGM cell
-DO iBGM = BGMimin,BGMimax
+DO kBGM = BGMkmin,BGMkmax
    DO jBGM = BGMjmin,BGMjmax
-      DO kBGM = BGMkmin,BGMkmax
+     DO iBGM = BGMimin,BGMimax
          GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
       END DO
    END DO
 END DO
 
 !--- compute number of elements in each background cell
-DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
-
-  ! use XCL_NGeo of each element :)
-  !xmin=MIN(xmin,MINVAL(XCL_NGeo(1,:,:,:,iElem)))
-  !xmax=MAX(xmax,MAXVAL(XCL_NGeo(1,:,:,:,iElem)))
-  !ymin=MIN(ymin,MINVAL(XCL_NGeo(2,:,:,:,iElem)))
-  !ymax=MAX(ymax,MAXVAL(XCL_NGeo(2,:,:,:,iElem)))
-  !zmin=MIN(zmin,MINVAL(XCL_NGeo(3,:,:,:,iElem)))
-  !zmax=MAX(zmax,MAXVAL(XCL_NGeo(3,:,:,:,iElem)))
-  !! get min,max of BezierControlPoints of Element ! bounding box
-  ! if no master side, control points of sides have to be recomputet, requried for parallel
-  DO iLocSide = 1,6
-    SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, iElem)
-    IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-      BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-    ELSE
-      SELECT CASE(ilocSide)
-      CASE(XI_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-      CASE(XI_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ETA_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ETA_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ZETA_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-      CASE(ZETA_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-      END SELECT
-    END IF
-    xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
-    xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
-    ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
-    ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
-    zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
-    zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
-  END DO ! ilocSide
-  !--- find minimum and maximum BGM cell for current element
-  BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-  BGMCellXmax = MIN(BGMCellXmax,BGMimax)
-  BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-  BGMCellXmin = MAX(BGMCellXmin,BGMimin)
-  BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-  BGMCellYmax = MIN(BGMCellYmax,BGMjmax)
-  BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-  BGMCellYmin = MAX(BGMCellYmin,BGMjmin)
-  BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-  BGMCellZmax = MIN(BGMCellZmax,BGMkmax)
-  BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-  BGMCellZmin = MAX(BGMCellZmin,BGMkmin)      
+DO iElem=1,PP_nElems
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(ElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(ElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(ElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(ElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(ElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(ElemToBGM(6,iElem),BGMkmax),BGMkmin)
   ! add ecurrent element to number of BGM-elems
   DO iBGM = BGMCellXmin,BGMCellXmax
     DO jBGM = BGMCellYmin,BGMCellYmax
@@ -1107,9 +1050,10 @@ DO iElem=1,nTotalElems
 END DO ! iElem
 
 !--- allocate mapping variable and clean number for mapping (below)
-DO iBGM = BGMimin,BGMimax
+DO kBGM = BGMkmin,BGMkmax
   DO jBGM = BGMjmin,BGMjmax
-    DO kBGM = BGMkmin,BGMkmax
+    DO iBGM = BGMimin,BGMimax
+      IF(GEO%FIBGM(iBGM,jBGM,kBGM)%nElem.EQ.0) CYCLE
       ALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%Element(1:GEO%FIBGM(iBGM,jBGM,kBGM)%nElem))
       GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
     END DO ! kBGM
@@ -1117,67 +1061,18 @@ DO iBGM = BGMimin,BGMimax
 END DO ! iBGM
 
 !--- map elements to background cells
-DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
-
-  ! use XCL_NGeo of each element :)
-  !xmin=MIN(xmin,MINVAL(XCL_NGeo(1,:,:,:,iElem)))
-  !xmax=MAX(xmax,MAXVAL(XCL_NGeo(1,:,:,:,iElem)))
-  !ymin=MIN(ymin,MINVAL(XCL_NGeo(2,:,:,:,iElem)))
-  !ymax=MAX(ymax,MAXVAL(XCL_NGeo(2,:,:,:,iElem)))
-  !zmin=MIN(zmin,MINVAL(XCL_NGeo(3,:,:,:,iElem)))
-  !zmax=MAX(zmax,MAXVAL(XCL_NGeo(3,:,:,:,iElem)))
-  !! get min,max of BezierControlPoints of Element
-  DO iLocSide = 1,6
-    SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, iElem)
-    IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-      BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-    ELSE
-      SELECT CASE(ilocSide)
-      CASE(XI_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-      CASE(XI_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ETA_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ETA_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-      CASE(ZETA_MINUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-      CASE(ZETA_PLUS)
-        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-      END SELECT
-    END IF
-    xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
-    xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
-    ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
-    ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
-    zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
-    zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
-  END DO ! ilocSide
-
-  ! same as above
-  BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-  BGMCellXmax = MIN(BGMCellXmax,BGMimax)
-  BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-  BGMCellXmin = MAX(BGMCellXmin,BGMimin)
-  BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-  BGMCellYmax = MIN(BGMCellYmax,BGMjmax)
-  BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-  BGMCellYmin = MAX(BGMCellYmin,BGMjmin)
-  BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-  BGMCellZmax = MIN(BGMCellZmax,BGMkmax)
-  BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-  BGMCellZmin = MAX(BGMCellZmin,BGMkmin)     
+DO iElem=1,PP_nElems
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(ElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(ElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(ElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(ElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(ElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(ElemToBGM(6,iElem),BGMkmax),BGMkmin)
   ! add current Element to BGM-Elem
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
+      DO iBGM = BGMCellXmin,BGMCellXmax
         GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1    
         GEO%FIBGM(iBGM,jBGM,kBGM)%Element(GEO%FIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
       END DO ! kBGM
@@ -1195,9 +1090,6 @@ DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside and save their in
   DO jBGM=BGMjmin, BGMjmax
     DO kBGM=BGMkmin, BGMkmax
       IF (GEO%FIBGM(iBGM,jBGM,kBGM)%nElem .GT. 0) THEN
-        !print*,"1",BGMCells*3+1,iBGM
-        !print*,"2",BGMCells*3+2,jBGM
-        !print*,"3",BGMCells*3+3,kBGM
         BGMCellsArray(BGMCells*3+1)= iBGM
         BGMCellsArray(BGMCells*3+2)= jBGM
         BGMCellsArray(BGMCells*3+3)= kBGM
@@ -1214,7 +1106,6 @@ Displacement(1)=0
 DO i=2, PartMPI%nProcs
   Displacement(i) = SUM(NbrOfBGMCells(0:i-2))*3
 END DO
-!print*,'displacement',displacement
 !Gather indices of every Procs' Cells
 CALL MPI_ALLGATHERV(BGMCellsArray(1:BGMCells*3), BGMCells*3, MPI_INTEGER, GlobalBGMCellsArray, &    
                    & NbrOfBGMCells(0:PartMPI%nProcs-1)*3, Displacement, MPI_INTEGER, PartMPI%COMM, IERROR)
@@ -1398,7 +1289,6 @@ DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside or adjacent and s
     END DO !iBGM
   END DO !jBGM
 END DO !kBGM
-!print*,'BGMCellsArray',BGMCellsArray
 
 ! now create a temporary array in which for all BGM Cells + ShapePadding the processes are saved 
 ! reason: this way, the ReducedBGM List only needs to be searched once and not once for each BGM Cell+Stencil
@@ -1638,7 +1528,7 @@ SUBROUTINE GetSFIBGM()
 USE MOD_PreProc
 USE MOD_Globals!,            ONLY : UNIT_StdOut
 USE MOD_Particle_Mesh_Vars,                 ONLY:ElemBaryNGeo,ElemRadiusNGeo
-USE MOD_Particle_Surfaces_Vars,             ONLY:BezierControlPoints3D
+!USE MOD_Particle_Surfaces_Vars,             ONLY:BezierControlPoints3D
 USE MOD_Partilce_Periodic_BC,               ONLY:InitPeriodicBC
 USE MOD_Particle_Mesh_Vars,                 ONLY:GEO,nTotalElems,nTotalSides
 USE MOD_PICDepo,                            ONLY:InitializeDeposition
@@ -1677,10 +1567,11 @@ INTEGER                          :: BGMCellYmax,BGMCellYmin
 INTEGER                          :: BGMCellZmax,BGMCellZmin
 INTEGER                          :: ALLOCSTAT
 INTEGER                          :: iProc
+INTEGER                          :: nEntry
 REAL                             :: deltaT
 #ifdef MPI
 INTEGER                          :: ii,jj,kk,i,j
-INTEGER                          :: BGMCells,  m, CurrentProc, Cell, Procs
+INTEGER                          :: BGMCells,  m, CurrentProc, Cell, Procs,Cell3
 INTEGER                          :: imin, imax, kmin, kmax, jmin, jmax
 INTEGER                          :: nPaddingCellsX, nPaddingCellsY, nPaddingCellsZ
 INTEGER                          :: nShapePaddingX, nShapePaddingY, nShapePaddingZ
@@ -1717,25 +1608,25 @@ zmin = HUGE(1.0)
 zmax =-HUGE(1.0)
 
 ! serch for min,max of BezierControlPoints, e.g. the convec hull of the domain
-! more accurate, XCL_NGeo
-!DO iElem=1,nTotalElems
-!  xmin=MIN(xmin,MINVAL(XCL_NGeo(1,:,:,:,iElem)))
-!  xmax=MAX(xmax,MAXVAL(XCL_NGeo(1,:,:,:,iElem)))
-!  ymin=MIN(ymin,MINVAL(XCL_NGeo(2,:,:,:,iElem)))
-!  ymax=MAX(ymax,MAXVAL(XCL_NGeo(2,:,:,:,iElem)))
-!  zmin=MIN(zmin,MINVAL(XCL_NGeo(3,:,:,:,iElem)))
-!  zmax=MAX(zmax,MAXVAL(XCL_NGeo(3,:,:,:,iElem)))
-!END DO ! iElem
-
 ! bounding box!!
-DO iSide=1,nTotalSides
-  xmin=MIN(xmin,MINVAL(BezierControlPoints3D(1,:,:,iSide)))
-  xmax=MAX(xmax,MAXVAL(BezierControlPoints3D(1,:,:,iSide)))
-  ymin=MIN(ymin,MINVAL(BezierControlPoints3D(2,:,:,iSide)))
-  ymax=MAX(ymax,MAXVAL(BezierControlPoints3D(2,:,:,iSide)))
-  zmin=MIN(zmin,MINVAL(BezierControlPoints3D(3,:,:,iSide)))
-  zmax=MAX(zmax,MAXVAL(BezierControlPoints3D(3,:,:,iSide)))
-END DO ! iSide
+!DO iSide=1,nTotalSides
+!  xmin=MIN(xmin,MINVAL(BezierControlPoints3D(1,:,:,iSide)))
+!  xmax=MAX(xmax,MAXVAL(BezierControlPoints3D(1,:,:,iSide)))
+!  ymin=MIN(ymin,MINVAL(BezierControlPoints3D(2,:,:,iSide)))
+!  ymax=MAX(ymax,MAXVAL(BezierControlPoints3D(2,:,:,iSide)))
+!  zmin=MIN(zmin,MINVAL(BezierControlPoints3D(3,:,:,iSide)))
+!  zmax=MAX(zmax,MAXVAL(BezierControlPoints3D(3,:,:,iSide)))
+!END DO ! iSide
+
+DO iElem=1,nTotalElems
+  xmin=MIN(xmin,ElemBaryNGeo(1,iElem)-ElemRadiusNGeo(iElem))
+  xmax=MAX(xmax,ElemBaryNGeo(1,iElem)+ElemRadiusNGeo(iElem))
+  ymin=MIN(ymin,ElemBaryNGeo(2,iElem)-ElemRadiusNGeo(iElem))
+  ymax=MAX(ymax,ElemBaryNGeo(2,iElem)+ElemRadiusNGeo(iElem))
+  zmin=MIN(zmin,ElemBaryNGeo(3,iElem)-ElemRadiusNGeo(iElem))
+  zmax=MAX(zmax,ElemBaryNGeo(3,iElem)+ElemRadiusNGeo(iElem))
+END DO 
+
 
 GEO%xmin=xmin
 GEO%xmax=xmax
@@ -1776,9 +1667,9 @@ GEO%zmax=zmax
 ! deallocate stuff // required for dynamic load balance
 #ifdef MPI
 IF (ALLOCATED(GEO%FIBGM)) THEN
-  DO iBGM=GEO%FIBGMimin,GEO%FIBGMimax
+  DO kBGM=GEO%FIBGMkmin,GEO%FIBGMkmax
     DO jBGM=GEO%FIBGMjmin,GEO%FIBGMjmax
-      DO kBGM=GEO%FIBGMkmin,GEO%FIBGMkmax
+      DO iBGM=GEO%FIBGMimin,GEO%FIBGMimax
         SDEALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%Element)
         SDEALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%ShapeProcs)
         SDEALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%PaddingProcs)
@@ -1847,7 +1738,6 @@ IF ((DepositionType.EQ.'shape_function') &
 END IF
 #endif
 
-!print*,"BGM-Indices:",PartMPI%iProc, BGMimin, BGMimax, BGMjmin, BGMjmax, BGMkmin, BGMkmax
 GEO%FIBGMimax=BGMimax
 GEO%FIBGMimin=BGMimin
 GEO%FIBGMjmax=BGMjmax
@@ -1872,9 +1762,9 @@ __STAMP__&
 END IF
 
 ! null number of element per BGM cell
-DO iBGM = BGMimin,BGMimax
-   DO jBGM = BGMjmin,BGMjmax
-      DO kBGM = BGMkmin,BGMkmax
+DO kBGM = BGMkmin,BGMkmax
+  DO jBGM = BGMjmin,BGMjmax
+    DO iBGM = BGMimin,BGMimax
          GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
       END DO
    END DO
@@ -1882,12 +1772,6 @@ END DO
 
 !--- compute number of elements in each background cell
 DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
 
   ! get elem extension based on barycenter and radius
   xmin = ElemBaryNGeo(1,iElem) -ElemRadiusNGeo(iElem)
@@ -1912,9 +1796,9 @@ DO iElem=1,nTotalElems
   BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
   BGMCellZmin = MAX(BGMCellZmin,BGMkmin)      
   ! add ecurrent element to number of BGM-elems
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
+      DO iBGM = BGMCellXmin,BGMCellXmax
          GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1
       END DO ! kBGM
     END DO ! jBGM
@@ -1922,9 +1806,9 @@ DO iElem=1,nTotalElems
 END DO ! iElem
 
 !--- allocate mapping variable and clean number for mapping (below)
-DO iBGM = BGMimin,BGMimax
+DO kBGM = BGMkmin,BGMkmax
   DO jBGM = BGMjmin,BGMjmax
-    DO kBGM = BGMkmin,BGMkmax
+    DO iBGM = BGMimin,BGMimax
       ALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%Element(1:GEO%FIBGM(iBGM,jBGM,kBGM)%nElem))
       GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
     END DO ! kBGM
@@ -1933,13 +1817,6 @@ END DO ! iBGM
 
 !--- map elements to background cells
 DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
-
   ! get elem extension based on barycenter and radius
   xmin = ElemBaryNGeo(1,iElem) -ElemRadiusNGeo(iElem)
   ymin = ElemBaryNGeo(2,iElem) -ElemRadiusNGeo(iElem)
@@ -1962,11 +1839,14 @@ DO iElem=1,nTotalElems
   BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
   BGMCellZmin = MAX(BGMCellZmin,BGMkmin)     
   ! add current Element to BGM-Elem
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
-        GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1    
-        GEO%FIBGM(iBGM,jBGM,kBGM)%Element(GEO%FIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
+      DO iBGM = BGMCellXmin,BGMCellXmax
+        nEntry = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem
+        nEntry = nEntry+1
+        !GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1    
+        GEO%FIBGM(iBGM,jBGM,kBGM)%Element(nEntry) = iElem
+        GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = nEntry
       END DO ! kBGM
     END DO ! jBGM
   END DO ! iBGM
@@ -1978,13 +1858,10 @@ END DO ! iElem
 !--- MPI stuff for background mesh (FastinitBGM)
 BGMCells=0 
 ALLOCATE(BGMCellsArray(1:(BGMimax-BGMimin+1)*(BGMjmax-BGMjmin+1)*(BGMkmax-BGMkmin+1)*3))
-DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside and save their indices in BGMCellsArray
+DO kBGM=BGMkmin, BGMkmax
   DO jBGM=BGMjmin, BGMjmax
-    DO kBGM=BGMkmin, BGMkmax
+    DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside and save their indices in BGMCellsArray
       IF (GEO%FIBGM(iBGM,jBGM,kBGM)%nElem .GT. 0) THEN
-        !print*,"1",BGMCells*3+1,iBGM
-        !print*,"2",BGMCells*3+2,jBGM
-        !print*,"3",BGMCells*3+3,kBGM
         BGMCellsArray(BGMCells*3+1)= iBGM
         BGMCellsArray(BGMCells*3+2)= jBGM
         BGMCellsArray(BGMCells*3+3)= kBGM
@@ -2001,7 +1878,6 @@ Displacement(1)=0
 DO i=2, PartMPI%nProcs
   Displacement(i) = SUM(NbrOfBGMCells(0:i-2))*3
 END DO
-!print*,'displacement',displacement
 !Gather indices of every Procs' Cells
 CALL MPI_ALLGATHERV(BGMCellsArray(1:BGMCells*3), BGMCells*3, MPI_INTEGER, GlobalBGMCellsArray, &    
                    & NbrOfBGMCells(0:PartMPI%nProcs-1)*3, Displacement, MPI_INTEGER, PartMPI%COMM, IERROR)
@@ -2168,9 +2044,10 @@ END IF !periodic
 !        is not necessarily always true. Hence new shape_proc padding:
 
 BGMCells=0 
-DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside or adjacent and save their indices in BGMCellsArray
+!Count BGMCells with Elements inside or adjacent and save their indices in BGMCellsArray
+DO kBGM=BGMkmin, BGMkmax
   DO jBGM=BGMjmin, BGMjmax
-    DO kBGM=BGMkmin, BGMkmax
+    DO iBGM=BGMimin, BGMimax  
       iMin=MAX(iBGM-nShapePaddingX,BGMimin); iMax=MIN(iBGM+nShapePaddingX,BGMimax)
       jMin=MAX(jBGM-nShapePaddingY,BGMjmin); jMax=MIN(jBGM+nShapePaddingY,BGMjmax)
       kMin=MAX(kBGM-nShapePaddingZ,BGMkmin); kMax=MIN(kBGM+nShapePaddingZ,BGMkmax)
@@ -2184,7 +2061,6 @@ DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside or adjacent and s
     END DO !iBGM
   END DO !jBGM
 END DO !kBGM
-!print*,'BGMCellsArray',BGMCellsArray
 
 ! now create a temporary array in which for all BGM Cells + ShapePadding the processes are saved 
 ! reason: this way, the ReducedBGM List only needs to be searched once and not once for each BGM Cell+Stencil
@@ -2235,17 +2111,18 @@ END DO
 ! fill real array
 DO Cell=0, BGMCells-1
   TempProcList=0
-  DO iBGM = BGMCellsArray(Cell*3+1)-nShapePaddingX, BGMCellsArray(Cell*3+1)+nShapePaddingX
-    DO jBGM = BGMCellsArray(Cell*3+2)-nShapePaddingY, BGMCellsArray(Cell*3+2)+nShapePaddingY
-      DO kBGM = BGMCellsArray(Cell*3+3)-nShapePaddingZ, BGMCellsArray(Cell*3+3)+nShapePaddingZ
+  Cell3=3*Cell
+  DO kBGM = BGMCellsArray(Cell3+3)-nShapePaddingZ, BGMCellsArray(Cell3+3)+nShapePaddingZ
+    DO jBGM = BGMCellsArray(Cell3+2)-nShapePaddingY, BGMCellsArray(Cell3+2)+nShapePaddingY
+      DO iBGM = BGMCellsArray(Cell3+1)-nShapePaddingX, BGMCellsArray(Cell3+1)+nShapePaddingX
         DO m = 1,CellProcNum(iBGM,jBGM,kBGM)
           TempProcList(CellProcList(iBGM,jBGM,kBGM,m))=1       ! every proc that is within the stencil gets a 1
         END DO ! m
-        kk = kBGM
+        ii = iBGM
       END DO !kBGM
       jj = jBGM
     END DO !jBGM
-    ii = iBGM
+    kk = kBGM
   END DO !iBGM
   Procs=SUM(TempProcList)
   IF (Procs.NE.0) THEN
@@ -2323,9 +2200,9 @@ DEALLOCATE(CellProcNum)
 !--- JN: But therefore we first have to refill BGMCellsArray to not only contain
 !        cells with PIC%FastInitBGM%nElem.GT.0 but also those adjacent and the paddingcells to them!
 BGMCells=0
-DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside or adjacent and save their indices in BGMCellsArray
+DO kBGM=BGMkmin, BGMkmax
   DO jBGM=BGMjmin, BGMjmax
-    DO kBGM=BGMkmin, BGMkmax
+    DO iBGM=BGMimin, BGMimax  !Count BGMCells with Elements inside or adjacent and save their indices in BGMCellsArray
       iMin=MAX(iBGM-nPaddingCellsX,BGMimin); iMax=MIN(iBGM+nPaddingCellsX,BGMimax)
       jMin=MAX(jBGM-nPaddingCellsY,BGMjmin); jMax=MIN(jBGM+nPaddingCellsY,BGMjmax)
       kMin=MAX(kBGM-nPaddingCellsZ,BGMkmin); kMax=MIN(kBGM+nPaddingCellsZ,BGMkmax)
@@ -2383,17 +2260,19 @@ END DO
 ! fill real array
 DO Cell=0, BGMCells-1
   TempProcList=0
-  DO iBGM = BGMCellsArray(Cell*3+1)-nPaddingCellsX, BGMCellsArray(Cell*3+1)+nPaddingCellsX
-    DO jBGM = BGMCellsArray(Cell*3+2)-nPaddingCellsY, BGMCellsArray(Cell*3+2)+nPaddingCellsY
-      DO kBGM = BGMCellsArray(Cell*3+3)-nPaddingCellsZ, BGMCellsArray(Cell*3+3)+nPaddingCellsZ
-        DO m = 1,CellProcNum(iBGM,jBGM,kBGM)
+  Cell3=3*Cell
+  DO kBGM = BGMCellsArray(Cell3+3)-nPaddingCellsZ, BGMCellsArray(Cell3+3)+nPaddingCellsZ
+    DO jBGM = BGMCellsArray(Cell3+2)-nPaddingCellsY, BGMCellsArray(Cell3+2)+nPaddingCellsY
+      DO iBGM = BGMCellsArray(Cell3+1)-nPaddingCellsX, BGMCellsArray(Cell3+1)+nPaddingCellsX
+        nEntry=CellProcNum(iBGM,jBGM,kBGM)
+        DO m = 1,nEntry
           TempProcList(CellProcList(iBGM,jBGM,kBGM,m))=1       ! every proc that is within the stencil gets a 1
         END DO ! m
-        kk = kBGM
+        ii = iBGM
       END DO !l
       jj = jBGM
     END DO !k
-    ii = iBGM
+    kk = kBGM
   END DO !i
   Procs=SUM(TempProcList)
   IF (Procs.NE.0) THEN
@@ -2414,8 +2293,7 @@ DEALLOCATE(ReducedBGMArray, BGMCellsArray, CellProcList, GlobalBGMCellsArray, Ce
 END SUBROUTINE GetSFIBGM
 
 
-#ifdef MPI
-SUBROUTINE AddHALOCellsToFIBGM()
+SUBROUTINE AddHALOCellsToFIBGM(ElemToBGM,HaloElemToBGM)
 !===================================================================================================================================
 ! remap all elements including halo-elements into FIBGM
 !===================================================================================================================================
@@ -2424,22 +2302,26 @@ USE MOD_PreProc
 USE MOD_Globals!,            ONLY : UNIT_StdOut
 USE MOD_ChangeBasis,                        ONLY:ChangeBasis2D
 USE MOD_Particle_Surfaces_Vars,             ONLY:BezierControlPoints3D,sVdm_Bezier
+USE MOD_Particle_Surfaces_Vars,             ONLY:sVdm_Bezier
 USE MOD_Mesh_Vars,                          ONLY:XCL_NGeo
 USE MOD_Mesh_Vars,                          ONLY:nSides,NGeo
 USE MOD_Particle_Mesh_Vars,                 ONLY:GEO,nTotalElems
 USE MOD_Particle_Tracking_Vars,             ONLY:DoRefMapping
 USE MOD_Particle_Mesh_Vars,                 ONLY:PartElemToSide
 USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI
+USE MOD_Particle_Tracking_Vars,             ONLY:Distance,ListDistance
 ! IMPLICIT VARIABLE HANDLING
  IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
 !INTEGER,INTENT(IN)    :: mode
+INTEGER,INTENT(IN)               :: ElemToBGM(1:6,1:PP_nElems)
+INTEGER,INTENT(IN),OPTIONAL      :: HaloElemToBGM(1:6,PP_nElems+1:nTotalElems)
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-INTEGER                          :: BGMimin,BGMimax,BGMjmin,BGMjmax,BGMkmin,BGMkmax
+INTEGER                          :: BGMimin,BGMimax,BGMjmin,BGMjmax,BGMkmin,BGMkmax,Allocstat
 REAL                             :: xmin, xmax, ymin, ymax, zmin, zmax
 INTEGER                          :: iBGM,jBGM,kBGM,SideID,iElem,ilocSide
 INTEGER                          :: BGMCellXmax,BGMCellXmin
@@ -2447,9 +2329,11 @@ INTEGER                          :: BGMCellYmax,BGMCellYmin
 INTEGER                          :: BGMCellZmax,BGMCellZmin
 LOGICAL, ALLOCATABLE             :: ElementFound(:)
 REAL                             :: BezierControlPoints3D_tmp(1:3,0:NGeo,0:NGeo)
+INTEGER                          :: maxnBGMElems
 !===================================================================================================================================
 
-! simplify writting
+
+! current min,max
 BGMimax=GEO%FIBGMimax
 BGMimin=GEO%FIBGMimin
 BGMjmax=GEO%FIBGMjmax
@@ -2457,379 +2341,212 @@ BGMjmin=GEO%FIBGMjmin
 BGMkmax=GEO%FIBGMkmax
 BGMkmin=GEO%FIBGMkmin
 
-! delete all elements form FIBGM && zero nElems per BGM-cell
-DO iBGM=GEO%FIBGMimin,GEO%FIBGMimax
-  DO jBGM=GEO%FIBGMjmin,GEO%FIBGMjmax
-    DO kBGM=GEO%FIBGMkmin,GEO%FIBGMkmax
-      SDEALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%Element)
-      GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
-    END DO
-  END DO
-END DO
+GEO%TFIBGMimax =GEO%FIBGMimax
+GEO%TFIBGMimin =GEO%FIBGMimin
+GEO%TFIBGMjmax =GEO%FIBGMjmax
+GEO%TFIBGMjmin =GEO%FIBGMjmin
+GEO%TFIBGMkmax =GEO%FIBGMkmax
+GEO%TFIBGMkmin =GEO%FIBGMkmin
+
+BGMCellXmax = BGMimax
+BGMCellXmin = BGMimin
+BGMCellYmax = BGMjmax
+BGMCellYmin = BGMjmin
+BGMCellZmax = BGMkmax
+BGMCellZmin = BGMkmin
+
+DO iElem=1,nTotalElems
+  IF(iElem.LE.PP_nElems)THEN
+    BGMCellXmin = ElemToBGM(1,iElem)
+    BGMCellXmax = ElemToBGM(2,iElem)
+    BGMCellYmin = ElemToBGM(3,iElem)
+    BGMCellYmax = ElemToBGM(4,iElem)
+    BGMCellZmin = ElemToBGM(5,iElem)
+    BGMCellZmax = ElemToBGM(6,iElem)
+  ELSE
+    IF(.NOT.GEO%directions(1)) BGMCellXmin = HaloElemToBGM(1,iElem)
+    IF(.NOT.GEO%directions(1)) BGMCellXmax = HaloElemToBGM(2,iElem)
+    IF(.NOT.GEO%directions(2)) BGMCellYmin = HaloElemToBGM(3,iElem)
+    IF(.NOT.GEO%directions(2)) BGMCellYmax = HaloElemToBGM(4,iElem)
+    IF(.NOT.GEO%directions(3)) BGMCellZmin = HaloElemToBGM(5,iElem)
+    IF(.NOT.GEO%directions(3)) BGMCellZmax = HaloElemToBGM(6,iElem)
+  END IF
+
+  BGMimin=MIN(BGMimin,BGMCellXmin)
+  BGMimax=MAX(BGMimax,BGMCellXmax)
+  BGMjmin=MIN(BGMjmin,BGMCellYmin)
+  BGMjmax=MAX(BGMjmax,BGMCellYmax)
+  BGMkmin=MIN(BGMkmin,BGMCellZmin)
+  BGMkmax=MAX(BGMkmax,BGMCellZmax)
+
+END DO ! iElem = nElems+1,nTotalElems
+
+GEO%TFIBGMimax =BGMimax
+GEO%TFIBGMimin =BGMimin
+GEO%TFIBGMjmax =BGMjmax
+GEO%TFIBGMjmin =BGMjmin
+GEO%TFIBGMkmax =BGMkmax
+GEO%TFIBGMkmin =BGMkmin
+
+ALLOCATE(GEO%TFIBGM(BGMimin:BGMimax,BGMjmin:BGMjmax,BGMkmin:BGMkmax), STAT=ALLOCSTAT)
+IF (ALLOCSTAT.NE.0) THEN
+    CALL abort(&
+__STAMP__&
+,' ERROR in AddElemsToTFIBGM: Cannot allocate GEO%TFIBGM!')
+END IF
 
 ALLOCATE( ElementFound(1:nTotalElems) )
 ElementFound = .FALSE.
 
-!--- compute number of elements in each background cell
-DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
-
-  ! get min,max of BezierControlPoints of Element
-  DO iLocSide = 1,6
-    SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, iElem)
-    IF(DoRefMapping)THEN
-      IF(SideID.GT.0)THEN
-        IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-          BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-        ELSE
-          SELECT CASE(ilocSide)
-          CASE(XI_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(XI_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-          END SELECT
-        END IF
-      ELSE
-        SELECT CASE(ilocSide)
-        CASE(XI_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-        CASE(XI_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ETA_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ETA_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ZETA_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-        CASE(ZETA_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-        END SELECT
-      END IF
-    ELSE ! pure tracing
-      BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !IF(SideID.LE.nSides)THEN
-      !  IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-      !    BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !  ELSE
-      !    SELECT CASE(ilocSide)
-      !    CASE(XI_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(XI_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ETA_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ETA_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ZETA_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ZETA_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-      !    END SELECT
-      !  END IF
-      !ELSE
-      !  BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !END IF
-    END IF
-    xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
-    xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
-    ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
-    ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
-    zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
-    zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
-  END DO ! ilocSide
+! null number of elements per BGM-Cell
+DO kBGM = BGMkmin,BGMkmax
+  DO jBGM = BGMjmin,BGMjmax
+    DO iBGM = BGMimin,BGMimax
+       GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
+    END DO ! kBGM
+  END DO ! jBGM
+END DO ! iBGM
 
+
+!--- compute number of elements in each background cell
+DO iElem=1,PP_nElems
   !--- find minimum and maximum BGM cell for current element
-  IF(GEO%nPeriodicVectors.EQ.0)THEN
-    ! same fancy stuff
-    !BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    !BGMCellXmax = MIN(BGMCellXmax,BGMimax)
-    !BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    !BGMCellXmin = MAX(BGMCellXmin,BGMimin)
-    !BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    !BGMCellYmax = MIN(BGMCellYmax,BGMjmax)
-    !BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    !BGMCellYmin = MAX(BGMCellYmin,BGMjmin)
-    !BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    !BGMCellZmax = MIN(BGMCellZmax,BGMkmax)
-    !BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    !BGMCellZmin = MAX(BGMCellZmin,BGMkmin)      
-    BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmax = MAX(MIN(BGMCellXmax,BGMimax),BGMimin)
-    BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmin = MIN(MAX(BGMCellXmin,BGMimin),BGMimax)
-    BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmax = MAX(MIN(BGMCellYmax,BGMjmax),BGMjmin)
-    BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmin = MIN(MAX(BGMCellYmin,BGMjmin),BGMjmax)
-    BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmax = MAX(MIN(BGMCellZmax,BGMkmax),BGMkmin)
-    BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
-  ELSE
-    ! here fancy stuff, because element could be wide out of element range
-    BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmax = MAX(MIN(BGMCellXmax,BGMimax),BGMimin)
-    BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmin = MIN(MAX(BGMCellXmin,BGMimin),BGMimax)
-    BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmax = MAX(MIN(BGMCellYmax,BGMjmax),BGMjmin)
-    BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmin = MIN(MAX(BGMCellYmin,BGMjmin),BGMjmax)
-    BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmax = MAX(MIN(BGMCellZmax,BGMkmax),BGMkmin)
-    BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
-  END IF
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(ElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(ElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(ElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(ElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(ElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(ElemToBGM(6,iElem),BGMkmax),BGMkmin)
   ! add ecurrent element to number of BGM-elems
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
-         GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1
+      DO iBGM = BGMCellXmin,BGMCellXmax
+         GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1
          ElementFound(iElem) = .TRUE.
       END DO ! kBGM
     END DO ! jBGM
   END DO ! iBGM
 END DO ! iElem
 
+DO iElem=PP_nElems+1,nTotalElems
+  !--- find minimum and maximum BGM cell for current element
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(HaloElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(HaloElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(HaloElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(HaloElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(HaloElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(HaloElemToBGM(6,iElem),BGMkmax),BGMkmin)
+  ! add ecurrent element to number of BGM-elems
+  DO kBGM = BGMCellZmin,BGMCellZmax
+    DO jBGM = BGMCellYmin,BGMCellYmax
+      DO iBGM = BGMCellXmin,BGMCellXmax
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1
+        ElementFound(iElem) = .TRUE.
+      END DO ! kBGM
+    END DO ! jBGM
+  END DO ! iBGM
+END DO ! iElem
+
+
 !--- allocate mapping variable and clean number for mapping (below)
-DO iBGM = BGMimin,BGMimax
+DO kBGM = BGMkmin,BGMkmax
   DO jBGM = BGMjmin,BGMjmax
-    DO kBGM = BGMkmin,BGMkmax
-      ALLOCATE(GEO%FIBGM(iBGM,jBGM,kBGM)%Element(1:GEO%FIBGM(iBGM,jBGM,kBGM)%nElem))
-      GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = 0
+    DO iBGM = BGMimin,BGMimax
+      IF(GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem.EQ.0) CYCLE
+      ALLOCATE(GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(1:GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem))
+      GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
     END DO ! kBGM
   END DO ! jBGM
 END DO ! iBGM
 
 !--- map elements to background cells
-DO iElem=1,nTotalElems
-  xmin = HUGE(1.0)
-  xmax =-HUGE(1.0)
-  ymin = HUGE(1.0)
-  ymax =-HUGE(1.0)
-  zmin = HUGE(1.0)
-  zmax =-HUGE(1.0)
-
-  ! get min,max of BezierControlPoints of Element
-  DO iLocSide = 1,6
-    SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, iElem)
-    IF(DoRefMapping)THEN
-      IF(SideID.GT.0)THEN
-        IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-          BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-        ELSE
-          SELECT CASE(ilocSide)
-          CASE(XI_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(XI_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-          END SELECT
-        END IF
-      ELSE
-        SELECT CASE(ilocSide)
-        CASE(XI_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-        CASE(XI_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ETA_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ETA_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-        CASE(ZETA_MINUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-        CASE(ZETA_PLUS)
-          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-        END SELECT
-      END IF
-    ELSE ! pure tracing
-      BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !IF(SideID.LE.nSides)THEN
-      !  IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-          BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !  ELSE
-      !    SELECT CASE(ilocSide)
-      !    CASE(XI_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(XI_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ETA_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ETA_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ZETA_MINUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-      !    CASE(ZETA_PLUS)
-      !      CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-      !    END SELECT
-      !  END IF
-      !ELSE
-      !  BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-      !END IF
-    END IF
-    xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
-    xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
-    ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
-    ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
-    zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
-    zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
-  END DO ! ilocSide
+DO iElem=1,PP_nElems
+  !--- find minimum and maximum BGM cell for current element
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(ElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(ElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(ElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(ElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(ElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(ElemToBGM(6,iElem),BGMkmax),BGMkmin)
 
-  ! same as above
-  IF(GEO%nPeriodicVectors.EQ.0)THEN
-    !BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    !BGMCellXmax = MIN(BGMCellXmax,BGMimax)
-    !BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    !BGMCellXmin = MAX(BGMCellXmin,BGMimin)
-    !BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    !BGMCellYmax = MIN(BGMCellYmax,BGMjmax)
-    !BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    !BGMCellYmin = MAX(BGMCellYmin,BGMjmin)
-    !BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    !BGMCellZmax = MIN(BGMCellZmax,BGMkmax)
-    !BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    !BGMCellZmin = MAX(BGMCellZmin,BGMkmin)     
-    ! still the fancy stuff
-    BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmax = MAX(MIN(BGMCellXmax,BGMimax),BGMimin)
-    BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmin = MIN(MAX(BGMCellXmin,BGMimin),BGMimax)
-    BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmax = MAX(MIN(BGMCellYmax,BGMjmax),BGMjmin)
-    BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmin = MIN(MAX(BGMCellYmin,BGMjmin),BGMjmax)
-    BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmax = MAX(MIN(BGMCellZmax,BGMkmax),BGMkmin)
-    BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
-  ELSE
-    BGMCellXmax = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmax = MAX(MIN(BGMCellXmax,BGMimax),BGMimin)
-    BGMCellXmin = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    BGMCellXmin = MIN(MAX(BGMCellXmin,BGMimin),BGMimax)
-    BGMCellYmax = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmax = MAX(MIN(BGMCellYmax,BGMjmax),BGMjmin)
-    BGMCellYmin = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    BGMCellYmin = MIN(MAX(BGMCellYmin,BGMjmin),BGMjmax)
-    BGMCellZmax = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmax = MAX(MIN(BGMCellZmax,BGMkmax),BGMkmin)
-    BGMCellZmin = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
-  END IF
   ! add current Element to BGM-Elem
   DO iBGM = BGMCellXmin,BGMCellXmax
     DO jBGM = BGMCellYmin,BGMCellYmax
       DO kBGM = BGMCellZmin,BGMCellZmax
-        GEO%FIBGM(iBGM,jBGM,kBGM)%nElem = GEO%FIBGM(iBGM,jBGM,kBGM)%nElem + 1    
-        GEO%FIBGM(iBGM,jBGM,kBGM)%Element(GEO%FIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1    
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
       END DO ! kBGM
     END DO ! jBGM
   END DO ! iBGM
 END DO ! iElem
+DO iElem=PP_nElems+1,nTotalElems
+  !--- find minimum and maximum BGM cell for current element
+  ! here fancy stuff, because element could be wide out of element range
+  BGMCellXmin = MIN(MAX(HaloElemToBGM(1,iElem),BGMimin),BGMimax)
+  BGMCellXmax = MAX(MIN(HaloElemToBGM(2,iElem),BGMimax),BGMimin)
+  BGMCellYmin = MIN(MAX(HaloElemToBGM(3,iElem),BGMjmin),BGMjmax)
+  BGMCellYmax = MAX(MIN(HaloElemToBGM(4,iElem),BGMjmax),BGMjmin)
+  BGMCellZmin = MIN(MAX(HaloElemToBGM(5,iElem),BGMkmin),BGMkmax)
+  BGMCellZmax = MAX(MIN(HaloElemToBGM(6,iElem),BGMkmax),BGMkmin)
 
+  ! add current Element to BGM-Elem
+  DO iBGM = BGMCellXmin,BGMCellXmax
+    DO jBGM = BGMCellYmin,BGMCellYmax
+      DO kBGM = BGMCellZmin,BGMCellZmax
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1    
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
+      END DO ! kBGM
+    END DO ! jBGM
+  END DO ! iBGM
+END DO ! iElem
 
-DO iElem=1,nTotalElems
+
+DO iElem=1,PP_nElems
   IF(.NOT.ElementFound(iElem))THEN
-    xmin = HUGE(1.0)
-    xmax =-HUGE(1.0)
-    ymin = HUGE(1.0)
-    ymax =-HUGE(1.0)
-    zmin = HUGE(1.0)
-    zmax =-HUGE(1.0)
-
-    ! get min,max of BezierControlPoints of Element
-    DO iLocSide = 1,6
-      SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, iElem)
-      IF(DoRefMapping)THEN
-        IF(SideID.GT.0)THEN
-          IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-            BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-          ELSE
-            SELECT CASE(ilocSide)
-            CASE(XI_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-            CASE(XI_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ETA_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ETA_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ZETA_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-            CASE(ZETA_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-            END SELECT
-          END IF
-        ELSE
-          SELECT CASE(ilocSide)
-          CASE(XI_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(XI_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_MINUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-          CASE(ZETA_PLUS)
-            CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-          END SELECT
-        END IF
-      ELSE ! pure tracing
-        IF(SideID.LE.nSides)THEN
-          IF(PartElemToSide(E2S_FLIP,ilocSide,iElem).EQ.0)THEN
-            BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-          ELSE
-            SELECT CASE(ilocSide)
-            CASE(XI_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,iElem),BezierControlPoints3D_tmp)
-            CASE(XI_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ETA_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ETA_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,iElem),BezierControlPoints3D_tmp)
-            CASE(ZETA_MINUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,iElem),BezierControlPoints3D_tmp)
-            CASE(ZETA_PLUS)
-              CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,iElem),BezierControlPoints3D_tmp)
-            END SELECT
-          END IF
-        ELSE
-          BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
-        END IF
-        IPWRITE(*,*) "ideID,BezierControlPoints3D_tmp",SideID,BezierControlPoints3D_tmp
-      END IF
-      xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
-      xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
-      ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
-      ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
-      zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
-      zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
-    END DO ! ilocSide
+    !--- find minimum and maximum BGM cell for current element
+    ! here fancy stuff, because element could be wide out of element range
+    BGMCellXmin = ElemToBGM(1,iElem)
+    BGMCellXmax = ElemToBGM(2,iElem)
+    BGMCellYmin = ElemToBGM(3,iElem)
+    BGMCellYmax = ElemToBGM(4,iElem)
+    BGMCellZmin = ElemToBGM(5,iElem)
+    BGMCellZmax = ElemToBGM(6,iElem)
+
+    IPWRITE(UNIT_stdOut,*) ' TFIBGM , iElem'
+    IPWRITE(UNIT_stdOut,*) 'xmin',GEO%xmin,xmin
+    IPWRITE(UNIT_stdOut,*) 'xmax',GEO%xmax,xmax
+    IPWRITE(UNIT_stdOut,*) 'ymin',GEO%ymin,ymin
+    IPWRITE(UNIT_stdOut,*) 'ymax',GEO%ymax,ymax
+    IPWRITE(UNIT_stdOut,*) 'zmin',GEO%zmin,zmin
+    IPWRITE(UNIT_stdOut,*) 'zmax',GEO%zmax,zmax
+    IPWRITE(UNIT_stdOut,*) ' BGM , iBGM'
+    IPWRITE(UNIT_stdOut,*) 'xmin', BGMimin,BGMCellXmin
+    IPWRITE(UNIT_stdOut,*) 'xmax', BGMimax,BGMCellXmax
+    IPWRITE(UNIT_stdOut,*) 'ymin', BGMjmin,BGMCellYmin
+    IPWRITE(UNIT_stdOut,*) 'ymax', BGMjmax,BGMCellYmax
+    IPWRITE(UNIT_stdOut,*) 'zmin', BGMkmin,BGMCellYmin
+    IPWRITE(UNIT_stdOut,*) 'zmax', BGMkmax,BGMCellYmax
+    CALL abort(&
+__STAMP__&
+,' Element not located in FIBGM! iElem, myRank',iElem,REAL(PartMPI%MyRank))
+  END IF
+END DO ! iElem
 
-    IPWRITE(UNIT_stdOut,*) ' FIBGM , iElem'
+DO iElem=PP_nElems+1,nTotalElems
+  IF(.NOT.ElementFound(iElem))THEN
+    !--- find minimum and maximum BGM cell for current element
+    ! here fancy stuff, because element could be wide out of element range
+    BGMCellXmin = HaloElemToBGM(1,iElem)
+    BGMCellXmax = HaloElemToBGM(2,iElem)
+    BGMCellYmin = HaloElemToBGM(3,iElem)
+    BGMCellYmax = HaloElemToBGM(4,iElem)
+    BGMCellZmin = HaloElemToBGM(5,iElem)
+    BGMCellZmax = HaloElemToBGM(6,iElem)
+
+    IPWRITE(UNIT_stdOut,*) ' TFIBGM , iElem'
     IPWRITE(UNIT_stdOut,*) 'xmin',GEO%xmin,xmin
     IPWRITE(UNIT_stdOut,*) 'xmax',GEO%xmax,xmax
     IPWRITE(UNIT_stdOut,*) 'ymin',GEO%ymin,ymin
@@ -2837,20 +2554,35 @@ DO iElem=1,nTotalElems
     IPWRITE(UNIT_stdOut,*) 'zmin',GEO%zmin,zmin
     IPWRITE(UNIT_stdOut,*) 'zmax',GEO%zmax,zmax
     IPWRITE(UNIT_stdOut,*) ' BGM , iBGM'
-    IPWRITE(UNIT_stdOut,*) 'xmin', BGMimin,CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    IPWRITE(UNIT_stdOut,*) 'xmax', BGMimax,CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
-    IPWRITE(UNIT_stdOut,*) 'ymin', BGMjmin,CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    IPWRITE(UNIT_stdOut,*) 'ymax', BGMjmax,CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
-    IPWRITE(UNIT_stdOut,*) 'zmin', BGMkmin,CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
-    IPWRITE(UNIT_stdOut,*) 'zmax', BGMkmax,CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
+    IPWRITE(UNIT_stdOut,*) 'xmin', BGMimin,BGMCellXmin
+    IPWRITE(UNIT_stdOut,*) 'xmax', BGMimax,BGMCellXmax
+    IPWRITE(UNIT_stdOut,*) 'ymin', BGMjmin,BGMCellYmin
+    IPWRITE(UNIT_stdOut,*) 'ymax', BGMjmax,BGMCellYmax
+    IPWRITE(UNIT_stdOut,*) 'zmin', BGMkmin,BGMCellYmin
+    IPWRITE(UNIT_stdOut,*) 'zmax', BGMkmax,BGMCellYmax
     CALL abort(&
 __STAMP__&
 ,' Element not located in FIBGM! iElem, myRank',iElem,REAL(PartMPI%MyRank))
   END IF
 END DO ! iElem
 
+
 DEALLOCATE(Elementfound)
 
+! and get max number of bgm-elems
+maxnBGMElems=0
+DO kBGM = GEO%TFIBGMkmin,GEO%TFIBGMkmax
+  DO jBGM = GEO%TFIBGMjmin,GEO%TFIBGMjmax
+    DO iBGM = GEO%TFIBGMimin,GEO%TFIBGMimax
+      !maxnBGMElems=MAX(maxnBGMElems,GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem)
+      maxnBGMElems=MAX(maxnBGMElems,GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem)
+    END DO ! kBGM
+  END DO ! jBGM
+END DO ! iBGM
+ALLOCATE(Distance    (1:maxnBGMElems) &
+        ,ListDistance(1:maxnBGMElems) )
+
+
 END SUBROUTINE AddHALOCellsToFIBGM
 
 
@@ -2865,7 +2597,6 @@ USE MOD_Particle_Mesh_Vars,                 ONLY:ElemBaryNGeo,ElemRadiusNGeo
 USE MOD_Partilce_Periodic_BC,               ONLY:InitPeriodicBC
 USE MOD_Particle_Mesh_Vars,                 ONLY:GEO,nTotalElems
 USE MOD_Particle_Tracking_Vars,             ONLY:Distance,ListDistance
-USE MOD_Particle_MPI,                       ONLY:InitHALOMesh
 USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI
 ! IMPLICIT VARIABLE HANDLING
  IMPLICIT NONE
@@ -2882,6 +2613,8 @@ INTEGER                          :: iBGM,jBGM,kBGM,iElem
 INTEGER                          :: BGMCellXmax,BGMCellXmin
 INTEGER                          :: BGMCellYmax,BGMCellYmin
 INTEGER                          :: BGMCellZmax,BGMCellZmin,maxnBGMElems
+INTEGER                          :: nEntry
+INTEGER, ALLOCATABLE             :: LocalCounter(:,:,:)
 LOGICAL, ALLOCATABLE             :: ElementFound(:)
 !===================================================================================================================================
 
@@ -2947,6 +2680,13 @@ IF (ALLOCSTAT.NE.0) THEN
 __STAMP__&
 ,' ERROR in AddElemsToTFIBGM: Cannot allocate GEO%TFIBGM!')
 END IF
+ALLOCATE(LocalCounter(BGMimin:BGMimax,BGMjmin:BGMjmax,BGMkmin:BGMkmax), STAT=ALLOCSTAT)
+IF (ALLOCSTAT.NE.0) THEN
+    CALL abort(&
+__STAMP__&
+,' ERROR in AddElemsToTFIBGM: Cannot allocate GEO%TFIBGM!')
+END IF
+
 
 ALLOCATE( ElementFound(1:nTotalElems) )
 ElementFound = .FALSE.
@@ -2954,7 +2694,8 @@ ElementFound = .FALSE.
 DO iBGM = BGMimin,BGMimax
   DO jBGM = BGMjmin,BGMjmax
     DO kBGM = BGMkmin,BGMkmax
-       GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
+       !GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
+       LocalCounter(iBGM,jBGM,kBGM)=0
     END DO ! kBGM
   END DO ! jBGM
 END DO ! iBGM
@@ -3012,10 +2753,11 @@ DO iElem=1,nTotalElems
     BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
   END IF
   ! add ecurrent element to number of BGM-elems
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
-         GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1
+      DO iBGM = BGMCellXmin,BGMCellXmax
+         !GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1
+         LocalCounter(iBGM,jBGM,kBGM) = LocalCounter(iBGM,jBGM,kBGM) + 1
          ElementFound(iElem) = .TRUE.
       END DO ! kBGM
     END DO ! jBGM
@@ -3023,11 +2765,14 @@ DO iElem=1,nTotalElems
 END DO ! iElem
 
 !--- allocate mapping variable and clean number for mapping (below)
-DO iBGM = BGMimin,BGMimax
+DO kBGM = BGMkmin,BGMkmax
   DO jBGM = BGMjmin,BGMjmax
-    DO kBGM = BGMkmin,BGMkmax
-      ALLOCATE(GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(1:GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem))
-      GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
+    DO iBGM = BGMimin,BGMimax
+      nEntry = LocalCounter(iBGM,jBGM,kBGM)
+      GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = nEntry
+      ALLOCATE(GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(1:nEntry))
+      !GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = 0
+      LocalCounter(iBGM,jBGM,kBGM) = 0
     END DO ! kBGM
   END DO ! jBGM
 END DO ! iBGM
@@ -3072,11 +2817,14 @@ DO iElem=1,nTotalElems
     BGMCellZmin = MIN(MAX(BGMCellZmin,BGMkmin),BGMkmax)
   END IF
   ! add current Element to BGM-Elem
-  DO iBGM = BGMCellXmin,BGMCellXmax
+  DO kBGM = BGMCellZmin,BGMCellZmax
     DO jBGM = BGMCellYmin,BGMCellYmax
-      DO kBGM = BGMCellZmin,BGMCellZmax
-        GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1    
-        GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem) = iElem
+      DO iBGM = BGMCellXmin,BGMCellXmax
+        !GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem + 1    
+        !nEntry = GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem
+        LocalCounter(iBGM,jBGM,kBGM) = LocalCounter(iBGM,jBGM,kBGM) + 1    
+        nEntry = LocalCounter(iBGM,jBGM,kBGM)
+        GEO%TFIBGM(iBGM,jBGM,kBGM)%Element(nEntry) = iElem
       END DO ! kBGM
     END DO ! jBGM
   END DO ! iBGM
@@ -3118,18 +2866,19 @@ DEALLOCATE(Elementfound)
 
 ! and get max number of bgm-elems
 maxnBGMElems=0
-DO iBGM = GEO%TFIBGMimin,GEO%TFIBGMimax
+DO kBGM = GEO%TFIBGMkmin,GEO%TFIBGMkmax
   DO jBGM = GEO%TFIBGMjmin,GEO%TFIBGMjmax
-    DO kBGM = GEO%TFIBGMkmin,GEO%TFIBGMkmax
-      maxnBGMElems=MAX(maxnBGMElems,GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem)
+    DO iBGM = GEO%TFIBGMimin,GEO%TFIBGMimax
+      !maxnBGMElems=MAX(maxnBGMElems,GEO%TFIBGM(iBGM,jBGM,kBGM)%nElem)
+      maxnBGMElems=MAX(maxnBGMElems,LocalCounter(iBGM,jBGM,kBGM))
     END DO ! kBGM
   END DO ! jBGM
 END DO ! iBGM
 ALLOCATE(Distance    (1:maxnBGMElems) &
         ,ListDistance(1:maxnBGMElems) )
+DEALLOCATE(LocalCounter)
 
 END SUBROUTINE AddSimpleHALOCellsToFIBGM
-#endif /*MPI*/
 
 
 SUBROUTINE InitElemVolumes()
@@ -3450,9 +3199,6 @@ CellY = CEILING((X_in(2)-GEO%yminglob)/GEO%FIBGMdeltas(2))
 CellY = MIN(GEO%FIBGMjmax,CellY) 
 CellZ = CEILING((X_in(3)-GEO%zminglob)/GEO%FIBGMdeltas(3))
 CellZ = MIN(GEO%FIBGMkmax,CellZ)
-!   print*,'cell indices',CellX,CellY,CellZ
-!   print*,'number of cells in bgm',GEO%FIBGM(CellX,CellY,CellZ)%nElem
-!   read*
 
 !--- check all cells associated with this beckground mesh cell
 nBGMElems=GEO%FIBGM(CellX,CellY,CellZ)%nElem
@@ -3568,7 +3314,7 @@ REAL                    :: Lag(1:3,0:NGeo)
 ElemRadiusNGeo=0.
 DO iElem=1,nTotalElems
   ! get point on each side 
-  IF(DoRefMapping)THEN
+  IF(iElem.LE.PP_nElems)THEN
     ! xi plus
     Xi=(/1.0,0.0,0.0/)
     CALL LagrangeInterpolationPolys(Xi(1),NGeo,XiCL_NGeo,wBaryCL_NGeo,Lag(1,:))
@@ -4047,7 +3793,7 @@ USE MOD_Particle_Mesh_Vars,                 ONLY:nTotalSides,IsBCElem,nTotalBCSi
 USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI
 USE MOD_Particle_Mesh_Vars,                 ONLY:PartElemToSide,BCElem,PartSideToElem,PartBCSideList,nTotalBCSides,GEO
 USE MOD_Particle_MPI_Vars,                  ONLY:halo_eps,halo_eps2
-USE MOD_Mesh_Vars,                          ONLY:CurvedElem,XCL_NGeo,nGlobalElems,Vdm_CLNGeo1_CLNGeo
+USE MOD_Mesh_Vars,                          ONLY:CurvedElem,XCL_NGeo,nGlobalElems,Vdm_CLNGeo1_CLNGeo,BC
 USE MOD_ChangeBasis,                        ONLY:changeBasis3D
 USE MOD_Particle_Mesh_Vars,                 ONLY:RefMappingEps,epsOneCell
 #ifdef MPI
@@ -4064,15 +3810,20 @@ IMPLICIT NONE
 ! OUTPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-INTEGER                                  :: iElem, nCurvedElems,nCurvedElemsTot,nLinearElems,nLinearElemsHalo,nBCElemsHalo
-INTEGER                                  :: iSide,p,q, nPlanar,nBilinear,nCurved,nDummy,SideID,TrueSideID,ilocSide,nBCElems
-INTEGER                                  :: nPlanarHalo, nBilinearHalo, nCurvedHalo, nCurvedElemsHalo
+INTEGER                                  :: iElem, nCurvedElems,nCurvedElemsTot
+INTEGER                                  :: iSide,p,q, nDummy,SideID,TrueSideID,ilocSide,nBCElems,nBCelemsTot
+INTEGER                                  :: nPlanarRectangular, nPlanarNonRectangular,nPlanarCurved,nBilinear,nCurved
+INTEGER                                  :: nPlanarRectangularTot, nPlanarNonRectangularTot,nPlanarCurvedTot,nBilinearTot,nCurvedTot
+INTEGER                                  :: nCurvedElemsHalo,nLinearElems,nLinearElemsHalo,nBCElemsHalo
+#ifdef MPI
+INTEGER                                  :: nPlanarRectangularHalo, nPlanarNonRectangularHalo,nPlanarCurvedHalo, &
+                                            nBilinearHalo,nCurvedHalo
+#endif /*MPI*/
 INTEGER                                  :: nSideCount, BCSideID, BCSideID2, s,r
 INTEGER,ALLOCATABLE                      :: SideIndex(:)
 REAL,DIMENSION(1:3)                      :: v1,v2,NodeX,v3
 REAL                                     :: length,eps
 LOGICAL                                  :: isLinear,leave
-INTEGER                                  :: nPlanarTot,nBilinearTot,nCurvedTot,nBCElemsTot
 #if (PP_TimeDiscMethod!=1)&&(PP_TimeDiscMethod!=2)&&(PP_TimeDiscMethod!=6)&&((PP_TimeDiscMethod<501 || PP_TimeDiscMethod>506))
 REAL,DIMENSION(1:3,0:NGeo,0:NGeo) :: xNodes
 #endif
@@ -4105,7 +3856,8 @@ IF(DoRefMapping)THEN
 ELSE
   ALLOCATE( SideType(nTotalSides)        &
           , SideDistance(nTotalSides)    &
-          , SideIsDone(nTotalSides)        &
+          , isBCElem(nTotalElems)        &
+          , SideIsDone(nTotalSides)      &
           , SideNormVec(1:3,nTotalSides) )
 END IF
 SideIsDone=.FALSE.
@@ -4115,16 +3867,23 @@ SideDistance=0.
 SideNormVec=0.
 
 eps=1e-8
-nPlanar=0
-nBilinear=0
-nCurved=0
-nBCElems=0
-nPlanarHalo=0
-nBilinearHalo=0
-nCurvedHalo=0
-nLinearElemsHalo=0
-nCurvedElemsHalo=0
-nBCElemsHalo=0
+
+nPlanarRectangular         = 0
+nPlanarNonRectangular      = 0
+nPlanarCurved              = 0
+nBilinear                  = 0
+nCurved                    = 0
+#ifdef MPI
+nPlanarRectangularHalo     = 0
+nPlanarNonRectangularHalo  = 0
+nPlanarCurvedHalo          = 0
+nBilinearHalo              = 0
+nCurvedHalo                = 0
+#endif /*MPI*/
+nCurvedElemsHalo           = 0
+nLinearElemsHalo           = 0
+nCurvedElemsHalo           = 0
+nBCElemsHalo               = 0
 isBilinear=.FALSE.
 
 NGeo2=(NGeo+1)*(NGeo+1)
@@ -4201,15 +3960,15 @@ DO iElem=1,nLoop
         END IF
         IF(isRectangular)THEN
           SideType(TrueSideID)=PLANAR_RECT
-          IF(TrueSideID.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+          IF(TrueSideID.LE.SideID_Minus_Upper) nPlanarRectangular=nPlanarRectangular+1
 #ifdef MPI
-          IF(TrueSideID.GT.nSides) nPlanarHalo=nPlanarHalo+1
+          IF(TrueSideID.GT.nSides) nPlanarRectangularHalo=nPlanarRectangularHalo+1
 #endif /*MPI*/
         ELSE
           SideType(TrueSideID)=PLANAR_NONRECT
-          IF(SideID.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+          IF(SideID.LE.SideID_Minus_Upper) nPlanarNonRectangular=nPlanarNonRectangular+1
 #ifdef MPI
-          IF(SideID.GT.nSides) nPlanarHalo=nPlanarHalo+1
+          IF(SideID.GT.nSides) nPlanarNonRectangularHalo=nPlanarNonRectangularHalo+1
 #endif /*MPI*/
         END IF
       ELSE
@@ -4243,12 +4002,12 @@ DO iElem=1,nLoop
       END SELECT
       CALL PointsEqual(NGeo2,XCL_NGeoSideNew,XCL_NGeoSideOld,isCurvedSide)
       IF(isCurvedSide)THEn
-        SideType(TrueSideID)=CURVED
-        IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+        IF(BoundingBoxIsEmpty(TrueSideID))THEN
+          SideType(TrueSideID)=PLANAR_CURVED
+          IF(SideID.LE.SideID_Minus_Upper) nPlanarCurved=nPlanarCurved+1
 #ifdef MPI
-        IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+          IF(SideID.GT.nSides) nPlanarCurvedHalo=nPlanarCurvedHalo+1
 #endif /*MPI*/
-        IF(BoundingBoxIsEmpty(TrueSideID))THEN
           v1=(-BezierControlPoints3D(:,0,0   ,TrueSideID)+BezierControlPoints3D(:,NGeo,0   ,TrueSideID)   &
               -BezierControlPoints3D(:,0,NGeo,TrueSideID)+BezierControlPoints3D(:,NGeo,NGeo,TrueSideID) )
           
@@ -4260,6 +4019,12 @@ DO iElem=1,nLoop
                   +BezierControlPoints3D(:,0,NGeo,TrueSideID)  &
                   +BezierControlPoints3D(:,NGeo,NGeo,TrueSideID))
           SideDistance(TrueSideID)=DOT_PRODUCT(v1,SideNormVec(:,TrueSideID))
+        ELSE
+          SideType(TrueSideID)=CURVED
+          IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+#ifdef MPI
+          IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+#endif /*MPI*/
         END IF
       ELSE
         IF(BoundingBoxIsEmpty(TrueSideID))THEN
@@ -4288,15 +4053,15 @@ DO iElem=1,nLoop
           END IF
           IF(isRectangular)THEN
             SideType(TrueSideID)=PLANAR_RECT
-            IF(TrueSideID.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+            IF(TrueSideID.LE.SideID_Minus_Upper) nPlanarRectangular=nPlanarRectangular+1
 #ifdef MPI
-            IF(TrueSideID.GT.nSides) nPlanarHalo=nPlanarHalo+1
+            IF(TrueSideID.GT.nSides) nPlanarRectangularHalo=nPlanarRectangularHalo+1
 #endif /*MPI*/
           ELSE
             SideType(TrueSideID)=PLANAR_NONRECT
-            IF(SideID.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+            IF(SideID.LE.SideID_Minus_Upper) nPlanarNonRectangular=nPlanarNonRectangular+1
 #ifdef MPI
-            IF(SideID.GT.nSides) nPlanarHalo=nPlanarHalo+1
+            IF(SideID.GT.nSides) nPlanarNonRectangularHalo=nPlanarNonRectangularHalo+1
 #endif /*MPI*/
           END IF
         ELSE
@@ -4399,15 +4164,15 @@ IF (.NOT.DoRefMapping)THEN
         END IF
         IF(isRectangular)THEN
           SideType(iSide)=PLANAR_RECT
-          IF(iSide.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+          IF(iSide.LE.SideID_Minus_Upper) nPlanarRectangular=nPlanarRectangular+1
 #ifdef MPI
-          IF(iSide.GT.nSides) nPlanarHalo=nPlanarHalo+1
+          IF(iSide.GT.nSides) nPlanarRectangularHalo=nPlanarRectangularHalo+1
 #endif /*MPI*/
         ELSE
           SideType(iSide)=PLANAR_NONRECT
-          IF(SideID.LE.SideID_Minus_Upper) nPlanar=nPlanar+1
+          IF(SideID.LE.SideID_Minus_Upper) nPlanarNonRectangular=nPlanarNonRectangular+1
 #ifdef MPI
-          IF(SideID.GT.nSides) nPlanarHalo=nPlanarHalo+1
+          IF(SideID.GT.nSides) nPlanarNonRectangularHalo=nPlanarNonRectangularHalo+1
 #endif /*MPI*/
         END IF
       ELSE
@@ -4454,12 +4219,12 @@ IF (.NOT.DoRefMapping)THEN
           IF(SideID.GT.nSides) nBilinearHalo=nBilinearHalo+1
 #endif /*MPI*/
         ELSE ! not bilinear
-          SideType(iSide)=CURVED
-          IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+          IF(BoundingBoxIsEmpty(iSide))THEN
+            SideType(TrueSideID)=PLANAR_CURVED
+            IF(SideID.LE.SideID_Minus_Upper) nPlanarCurved=nPlanarCurved+1
 #ifdef MPI
-          IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+            IF(SideID.GT.nSides) nPlanarCurvedHalo=nPlanarCurvedHalo+1
 #endif /*MPI*/
-          IF(BoundingBoxIsEmpty(iSide))THEN
             v1=(-BezierControlPoints3D(:,0,0   ,iSide)+BezierControlPoints3D(:,NGeo,0   ,iSide)   &
                 -BezierControlPoints3D(:,0,NGeo,iSide)+BezierControlPoints3D(:,NGeo,NGeo,iSide) )
             
@@ -4471,16 +4236,22 @@ IF (.NOT.DoRefMapping)THEN
                     +BezierControlPoints3D(:,0,NGeo,iSide)  &
                     +BezierControlPoints3D(:,NGeo,NGeo,iSide))
             SideDistance(iSide)=DOT_PRODUCT(v1,SideNormVec(:,iSide))
+          ELSE
+            SideType(TrueSideID)=CURVED
+            IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+#ifdef MPI
+            IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+#endif /*MPI*/
           END IF
         END IF
       END IF ! bounding bos is empty
     ELSE  ! non-linear edges
-      SideType(iSide)=CURVED
-      IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+      IF(BoundingBoxIsEmpty(iSide))THEN
+        SideType(iSide)=PLANAR_CURVED
+        IF(SideID.LE.SideID_Minus_Upper) nPlanarCurved=nPlanarCurved+1
 #ifdef MPI
-      IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+        IF(SideID.GT.nSides) nPlanarCurvedHalo=nPlanarCurvedHalo+1
 #endif /*MPI*/
-      IF(BoundingBoxIsEmpty(iSide))THEN
         v1=(-BezierControlPoints3D(:,0,0   ,iSide)+BezierControlPoints3D(:,NGeo,0   ,iSide)   &
             -BezierControlPoints3D(:,0,NGeo,iSide)+BezierControlPoints3D(:,NGeo,NGeo,iSide) )
         
@@ -4492,6 +4263,12 @@ IF (.NOT.DoRefMapping)THEN
                 +BezierControlPoints3D(:,0,NGeo,iSide)  &
                 +BezierControlPoints3D(:,NGeo,NGeo,iSide))
         SideDistance(iSide)=DOT_PRODUCT(v1,SideNormVec(:,iSide))
+      ELSE
+        SideType(iSide)=CURVED
+        IF(SideID.LE.SideID_Minus_Upper) nCurved=nCurved+1
+#ifdef MPI
+        IF(SideID.GT.nSides) nCurvedHalo=nCurvedHalo+1
+#endif /*MPI*/
       END IF
     END IF
   END DO ! iSide=1,nTotalSides
@@ -4524,8 +4301,7 @@ IF(DoRefMapping)THEN
   V1(3) = GEO%zmaxglob-GEO%zminglob
   Distance=DOT_PRODUCT(V1,V1)
   fullMesh=.FALSE.
-  IF(Distance.LE.halo_eps2) fullMesh=.TRUE.
-  ! build list with elements in halo-eps vicinity around bc-elements
+  IF(Distance.LE.halo_eps2) fullMesh=.TRUE.  ! build list with elements in halo-eps vicinity around bc-elements
   ALLOCATE( BCElem(1:nTotalElems) )
   ALLOCATE( SideIndex(1:nTotalSides) )
   ! number of element local BC-Sides
@@ -4687,43 +4463,89 @@ IF(DoRefMapping)THEN
     END DO  ! iSide
     SideIndex=0
   END DO ! iElem
+ELSE
+  ! tracing
+  ! mark only elements with bc-side
+  IsBCElem=.FALSE.
+  nTotalBCElems=0
+  DO iElem=1,nTotalElems
+    DO ilocSide=1,6
+      SideID=PartElemToSide(E2S_SIDE_ID,ilocSide,iElem)
+      IF (SideID.LE.0) CYCLE
+      IF(SideID.LE.nBCSides)THEN ! non-halo elements
+        IF(.NOT.isBCElem(iElem))THEN
+          IsBCElem(iElem)=.TRUE.
+          nTotalBCElems=nTotalBCElems+1
+          IF(SideID.LE.nBCSides)THEN
+            nBCElems=nBCElems+1
+          ELSE
+            nBCElemsHalo=nBCElemsHalo+1
+          END IF
+        END IF ! count only single
+      END IF
+#ifdef MPI
+      IF(SideID.GT.nSides)THEN ! halo elements
+        IF(BC(SideID).NE.0)THEN
+          IF(.NOT.isBCElem(iElem))THEN
+            IsBCElem(iElem)=.TRUE.
+            nTotalBCElems=nTotalBCElems+1
+            IF(SideID.LE.nBCSides)THEN
+              nBCElems=nBCElems+1
+            ELSE
+              nBCElemsHalo=nBCElemsHalo+1
+            END IF
+          END IF ! count only single
+        END IF
+      END IF ! SideID.GT.nSides
+#endif
+    END DO ! ilocSide
+  END DO ! iElem
 END IF
 
 #ifdef MPI
 IF(MPIRoot) THEN
-  CALL MPI_REDUCE(nPlanar,nPlanarTot  ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
-  CALL MPI_REDUCE(nBilinear,nBilinearTot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
-  CALL MPI_REDUCE(nCurved,nCurvedTot  ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nPlanarRectangular   ,nPlanarRectangularTot   ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nPlanarNonRectangular,nPlanarNonRectangularTot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nBilinear            ,nBilinearTot            ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nPlanarCurved        ,nPlanarCurvedTot        ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nCurved              ,nCurvedTot              ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
   CALL MPI_REDUCE(nCurvedElems,nCurvedElemsTot,1,MPI_INTEGER,MPI_SUM,0,PartMPI%COMM,IERROR)
   IF(DoRefMapping) CALL MPI_REDUCE(nBCElems,nBCElemsTot ,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
 ELSE ! no Root
-  CALL MPI_REDUCE(nPlanar  ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
-  CALL MPI_REDUCE(nBilinear,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
-  CALL MPI_REDUCE(nCurved  ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
-  CALL MPI_REDUCE(nCurvedElems,nDummy,1,MPI_INTEGER,MPI_SUM,0,PartMPI%COMM,IERROR)
+  CALL MPI_REDUCE(nPlanarRectangular     ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nPlanarNonRectangular  ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nBilinear              ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nPlanarCurved          ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nCurved                ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
+  CALL MPI_REDUCE(nCurvedElems           ,nDummy,1,MPI_INTEGER,MPI_SUM,0,PartMPI%COMM,IERROR)
   IF(DoRefMapping) CALL MPI_REDUCE(nBCElems  ,nDummy,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
 END IF
 #else
-nPlanarTot=nPlanar
-nBilinearTot=nBilinear
-nCurvedTot=nCurved
-nCurvedElemsTot=nCurvedElems
-nBCElemstot=nBCElems
+nPlanarRectangularTot   =nPlanarRectangularTot
+nPlanarNonRectangularTot=nPlanarNonRectangularTot
+nBilinearTot            =nBilinear
+nPlanarCurvedTot        =nPlanarCurved
+nCurvedTot              =nCurved
+nCurvedElemsTot         =nCurvedElems
+IF(DorefMapping) nBCElemstot=nBCElems
 #endif /*MPI*/
 
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of planar     faces: ', nPlanartot
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of bi-linear  faces: ', nBilineartot
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of curved     faces: ', nCurvedtot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of planar-rectangular     faces: ', nPlanarRectangulartot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of planar-non-rectangular faces: ', nPlanarNonRectangulartot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of bi-linear              faces: ', nBilineartot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of planar-curved          faces: ', nPlanarCurvedtot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of curved                 faces: ', nCurvedtot
 ! and add number of curved elems
 IF(DoRefMapping)THEN
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of BC-adjoined elems: ', nBCElemstot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of BC-adjoined            elems: ', nBCElemstot
 END IF
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of (bi-)linear elems: ', nGlobalElems-nCurvedElemsTot
-SWRITE(UNIT_StdOut,'(A,I8)') ' Number of curved      elems: ', nCurvedElemsTot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of (bi-)linear            elems: ', nGlobalElems-nCurvedElemsTot
+SWRITE(UNIT_StdOut,'(A,I8)') ' Number of curved                 elems: ', nCurvedElemsTot
 SWRITE(UNIT_StdOut,'(132("-"))')
 
 #ifdef MPI
-CALL WriteParticlePartitionInformation(nPlanar,nBilinear,nCurved,nPlanarHalo,nBilinearHalo,nCurvedHalo &
+CALL WriteParticlePartitionInformation(nPlanarRectangular+nPlanarNonRectangular,nBilinear,nCurved+nPlanarCurved,                    &
+                                       nPlanarRectangularHalo+nPlanarNonRectangularHalo,nBilinearHalo,nCurvedHalo+nPlanarCurvedHalo &
                                       ,nBCElems,nLinearElems,nCurvedElems,nBCElemsHalo,nLinearElemsHalo,nCurvedElemsHalo)
 #endif
 
@@ -4748,5 +4570,186 @@ END DO ! iElem=1,nLoop
 
 END SUBROUTINE GetElemAndSideType
 
+SUBROUTINE BGMIndexOfElement(ElemID,ElemToBGM) 
+!===================================================================================================================================
+! computes the element indices of an given element in the BGM-mesh
+!===================================================================================================================================
+! MODULES                                                                                                                          !
+!----------------------------------------------------------------------------------------------------------------------------------!
+USE MOD_ChangeBasis,                        ONLY:ChangeBasis2D
+USE MOD_Particle_Surfaces_Vars,             ONLY:BezierControlPoints3D,sVdm_Bezier
+USE MOD_Particle_Surfaces_Vars,             ONLY:sVdm_Bezier
+USE MOD_Mesh_Vars,                          ONLY:XCL_NGeo
+USE MOD_Mesh_Vars,                          ONLY:nSides,NGeo
+USE MOD_Particle_Mesh_Vars,                 ONLY:GEO,nTotalElems
+USE MOD_Particle_Tracking_Vars,             ONLY:DoRefMapping
+USE MOD_Particle_Mesh_Vars,                 ONLY:PartElemToSide
+!----------------------------------------------------------------------------------------------------------------------------------!
+! IMPLICIT VARIABLE HANDLING
+IMPLICIT NONE
+! INPUT VARIABLES 
+INTEGER,INTENT(IN)        :: ElemID
+!----------------------------------------------------------------------------------------------------------------------------------!
+! OUTPUT VARIABLES
+INTEGER,INTENT(OUT)       :: ElemToBGM(1:6)
+!-----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER                   :: ilocSide, SideID
+REAL                      :: xmin,xmax,ymin,ymax,zmin,zmax
+REAL                      :: BezierControlPoints3D_tmp(1:3,0:NGeo,0:NGeo)
+!===================================================================================================================================
+
+xmin = HUGE(1.0)
+xmax =-HUGE(1.0)
+ymin = HUGE(1.0)
+ymax =-HUGE(1.0)
+zmin = HUGE(1.0)
+zmax =-HUGE(1.0)
+
+! get min,max of BezierControlPoints of Element
+DO iLocSide = 1,6
+  SideID = PartElemToSide(E2S_SIDE_ID, ilocSide, ElemID)
+  IF(DoRefMapping)THEN
+    IF(SideID.GT.0)THEN
+      IF(PartElemToSide(E2S_FLIP,ilocSide,ElemID).EQ.0)THEN
+        BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
+      ELSE
+        SELECT CASE(ilocSide)
+        CASE(XI_MINUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,ElemID),BezierControlPoints3D_tmp)
+        CASE(XI_PLUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,ElemID),BezierControlPoints3D_tmp)
+        CASE(ETA_MINUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,ElemID),BezierControlPoints3D_tmp)
+        CASE(ETA_PLUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,ElemID),BezierControlPoints3D_tmp)
+        CASE(ZETA_MINUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,ElemID),BezierControlPoints3D_tmp)
+        CASE(ZETA_PLUS)
+          CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,ElemID),BezierControlPoints3D_tmp)
+        END SELECT
+      END IF
+    ELSE
+      SELECT CASE(ilocSide)
+      CASE(XI_MINUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:,ElemID),BezierControlPoints3D_tmp)
+      CASE(XI_PLUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:,ElemID),BezierControlPoints3D_tmp)
+      CASE(ETA_MINUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:,ElemID),BezierControlPoints3D_tmp)
+      CASE(ETA_PLUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:,ElemID),BezierControlPoints3D_tmp)
+      CASE(ZETA_MINUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0,ElemID),BezierControlPoints3D_tmp)
+      CASE(ZETA_PLUS)
+        CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo,ElemID),BezierControlPoints3D_tmp)
+      END SELECT
+    END IF
+  ELSE ! pure tracing
+    BezierControlPoints3d_tmp=BezierControlPoints3D(:,:,:,SideID)
+  END IF
+  xmin=MIN(xmin,MINVAL(BezierControlPoints3D_tmp(1,:,:)))
+  xmax=MAX(xmax,MAXVAL(BezierControlPoints3D_tmp(1,:,:)))
+  ymin=MIN(ymin,MINVAL(BezierControlPoints3D_tmp(2,:,:)))
+  ymax=MAX(ymax,MAXVAL(BezierControlPoints3D_tmp(2,:,:)))
+  zmin=MIN(zmin,MINVAL(BezierControlPoints3D_tmp(3,:,:)))
+  zmax=MAX(zmax,MAXVAL(BezierControlPoints3D_tmp(3,:,:)))
+END DO ! ilocSide
+
+ElemToBGM(1) = CEILING((xmin-GEO%xminglob)/GEO%FIBGMdeltas(1))
+ElemToBGM(2) = CEILING((xmax-GEO%xminglob)/GEO%FIBGMdeltas(1))
+ElemToBGM(3) = CEILING((ymin-GEO%yminglob)/GEO%FIBGMdeltas(2))
+ElemToBGM(4) = CEILING((ymax-GEO%yminglob)/GEO%FIBGMdeltas(2))
+ElemToBGM(5) = CEILING((zmin-GEO%zminglob)/GEO%FIBGMdeltas(3))
+ElemToBGM(6) = CEILING((zmax-GEO%zminglob)/GEO%FIBGMdeltas(3))
+
+
+END SUBROUTINE BGMIndexOfElement
+
+
+SUBROUTINE GetFIBGMMinMax() 
+!===================================================================================================================================
+! computes the minimum and maximum value of the FIBGM mesh
+!===================================================================================================================================
+! MODULES                                                                                                                          !
+!----------------------------------------------------------------------------------------------------------------------------------!
+USE MOD_Globals
+USE MOD_Particle_Mesh_Vars,                 ONLY:GEO
+USE MOD_Particle_Mesh_Vars,                 ONLY:GEO,nTotalElems,nTotalSides
+USE MOD_Particle_Surfaces_Vars,             ONLY:BezierControlPoints3D
+#ifdef MPI
+USE MOD_Particle_MPI_Vars,                  ONLY:PartMPI
+#endif /*MPI*/
+!----------------------------------------------------------------------------------------------------------------------------------!
+! IMPLICIT VARIABLE HANDLING
+IMPLICIT NONE
+! INPUT VARIABLES 
+!----------------------------------------------------------------------------------------------------------------------------------!
+! OUTPUT VARIABLES
+!-----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER         :: iSide
+REAL            :: xmin, xmax, ymin, ymax, zmin, zmax
+!===================================================================================================================================
+
+!#ifdef MPI
+!   !--- If this MPI process does not contain particles, step out
+!   IF (PMPIVAR%GROUP.EQ.MPI_GROUP_EMPTY) RETURN
+!#endif
+!--- calc min and max coordinates for mesh
+xmin = HUGE(1.0)
+xmax =-HUGE(1.0)
+ymin = HUGE(1.0)
+ymax =-HUGE(1.0)
+zmin = HUGE(1.0)
+zmax =-HUGE(1.0)
+
+! serch for min,max of BezierControlPoints, e.g. the convec hull of the domain
+! more accurate, XCL_NGeo
+!DO iElem=1,nTotalElems
+!  xmin=MIN(xmin,MINVAL(XCL_NGeo(1,:,:,:,iElem)))
+!  xmax=MAX(xmax,MAXVAL(XCL_NGeo(1,:,:,:,iElem)))
+!  ymin=MIN(ymin,MINVAL(XCL_NGeo(2,:,:,:,iElem)))
+!  ymax=MAX(ymax,MAXVAL(XCL_NGeo(2,:,:,:,iElem)))
+!  zmin=MIN(zmin,MINVAL(XCL_NGeo(3,:,:,:,iElem)))
+!  zmax=MAX(zmax,MAXVAL(XCL_NGeo(3,:,:,:,iElem)))
+!END DO ! iElem
+
+! bounding box!!
+DO iSide=1,nTotalSides
+  xmin=MIN(xmin,MINVAL(BezierControlPoints3D(1,:,:,iSide)))
+  xmax=MAX(xmax,MAXVAL(BezierControlPoints3D(1,:,:,iSide)))
+  ymin=MIN(ymin,MINVAL(BezierControlPoints3D(2,:,:,iSide)))
+  ymax=MAX(ymax,MAXVAL(BezierControlPoints3D(2,:,:,iSide)))
+  zmin=MIN(zmin,MINVAL(BezierControlPoints3D(3,:,:,iSide)))
+  zmax=MAX(zmax,MAXVAL(BezierControlPoints3D(3,:,:,iSide)))
+END DO ! iSide
+
+GEO%xmin=xmin
+GEO%xmax=xmax
+GEO%ymin=ymin
+GEO%ymax=ymax
+GEO%zmin=zmin
+GEO%zmax=zmax
+
+#ifdef MPI
+! get global min, max
+  CALL MPI_ALLREDUCE(GEO%xmin, GEO%xminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
+  CALL MPI_ALLREDUCE(GEO%ymin, GEO%yminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
+  CALL MPI_ALLREDUCE(GEO%zmin, GEO%zminglob, 1, MPI_DOUBLE_PRECISION, MPI_MIN, PartMPI%COMM, IERROR)
+  CALL MPI_ALLREDUCE(GEO%xmax, GEO%xmaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
+  CALL MPI_ALLREDUCE(GEO%ymax, GEO%ymaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
+  CALL MPI_ALLREDUCE(GEO%zmax, GEO%zmaxglob, 1, MPI_DOUBLE_PRECISION, MPI_MAX, PartMPI%COMM, IERROR)
+#else
+  GEO%xminglob=GEO%xmin
+  GEO%yminglob=GEO%ymin
+  GEO%zminglob=GEO%zmin
+  GEO%xmaxglob=GEO%xmax
+  GEO%ymaxglob=GEO%ymax
+  GEO%zmaxglob=GEO%zmax
+#endif   
+
+
+END SUBROUTINE GetFIBGMMinMax
 
 END MODULE MOD_Particle_Mesh
diff --git a/src/particles/particle_mesh/particle_surfaces.f90 b/src/particles/particle_mesh/particle_surfaces.f90
index f8afbeb..49cc7f6 100644
--- a/src/particles/particle_mesh/particle_surfaces.f90
+++ b/src/particles/particle_mesh/particle_surfaces.f90
@@ -493,10 +493,6 @@ INTEGER                           :: p,q
 REAL                              :: tmp(3,0:NGeo,0:NGeo)  
 
 !===================================================================================================================================
-!print*,"SIZE(BezierControlPoints)"
-!print*,SIZE(BezierControlPoints)
-!print*,"SHAPE(BezierControlPoints)"
-!print*,SHAPE(BezierControlPoints)
 ! BCSides, InnerSides and MINE MPISides are filled
 lastSideID  = nBCSides+nInnerSides+nMPISides_MINE
 !IF(DoRefMapping) lastSideID  = nBCSides
@@ -513,43 +509,9 @@ IF(SideID.LE.lastSideID)THEN
         BezierControlPoints3D(1:3,p,q,sideID)=tmp(:,q,p)
       END DO !p
     END DO !q
-    CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+    !CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
   END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,0,:,:),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 2.) XI_PLUS
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -559,43 +521,9 @@ IF(SideID.LE.lastSideID)THEN
     CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:),tmp)
     !print*,'ixi'
     BezierControlPoints3D(:,:,:,SideID)=tmp
-    CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+    !CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
   END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,NGeo,:,:),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 3.) ETA_MINUS
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -603,43 +531,9 @@ SideID=ElemToSide(E2S_SIDE_ID,ETA_MINUS,iElem)
 IF(SideID.LE.lastSideID)THEN
   IF(ElemToSide(E2S_FLIP,ETA_MINUS,iElem).EQ.0) THEN !if flip=0, master side!!
     CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:),BezierControlPoints3D(1:3,:,:,sideID))
-      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+    !CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
    END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,0,:),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 4.) ETA_PLUS
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -653,43 +547,9 @@ IF(SideID.LE.lastSideID)THEN
         BezierControlPoints3D(1:3,p,q,sideID)=tmp(:,NGeo-p,q)
       END DO !p
     END DO !q
-      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+      !CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
   END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,NGeo,:),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 5.) ZETA_MINUS
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -703,43 +563,9 @@ IF(SideID.LE.lastSideID)THEN
         BezierControlPoints3D(1:3,p,q,sideID)=tmp(:,q,p)
       END DO !p
     END DO !q
-      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+    !  CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
   END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,0),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 6.) ZETA_PLUS
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -747,46 +573,13 @@ SideID=ElemToSide(E2S_SIDE_ID,ZETA_PLUS,iElem)
 IF(SideID.LE.lastSideID)THEN
   IF(ElemToSide(E2S_FLIP,ZETA_PLUS,iElem).EQ.0) THEN !if flip=0, master side!!
     CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo),BezierControlPoints3D(1:3,:,:,sideID))
-    CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
+    !CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
   END IF !flip=0
 END IF
-!ELSE ! no master, here has to come the suff with the slave
-!  CALL ChangeBasis2D(3,NGeo,NGeo,sVdm_Bezier,XCL_NGeo(1:3,:,:,NGeo),tmp)
-!  flip= SideToElem(S2E_FLIP,SideID)
-!  SELECT CASE(flip)
-!    CASE(1) ! slave side, SideID=q,jSide=p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,q,p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(2) ! slave side, SideID=N-p,jSide=q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-p,q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(3) ! slave side, SideID=N-q,jSide=N-p
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,NGeo-q,NGeo-p)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!    CASE(4) ! slave side, SideID=p,jSide=N-q
-!      DO q=0,NGeo
-!        DO p=0,NGeo
-!          BezierControlPoints3D(:,p,q,SideID)=tmp(:,p,NGeo-q)
-!        END DO ! p
-!      END DO ! q
-!      CALL GetSideSlabNormalsAndIntervals(NGeo,SideID)
-!  END SELECT
-!END IF
 END SUBROUTINE GetBezierControlPoints3D
 
-SUBROUTINE GetSideSlabNormalsAndIntervals(NGeo,SideID)
+SUBROUTINE GetSideSlabNormalsAndIntervals(BezierControlPoints3D,BezierControlPoints3DElevated &
+                                         ,SideSlabNormals,SideSlabInterVals,BoundingBoxIsEmpty )
 !===================================================================================================================================
 ! computes the oriented-slab box for each bezier basis surface (i.e. 3 slab normals + 3 intervalls)
 ! see article:  
@@ -802,8 +595,10 @@ SUBROUTINE GetSideSlabNormalsAndIntervals(NGeo,SideID)
 USE MOD_Globals
 !USE MOD_Globals_Vars,    ONLY:EpsMach
 USE MOD_Preproc
-USE MOD_Particle_Surfaces_Vars,   ONLY: SideSlabNormals,SideSlabIntervals,BoundingBoxIsEmpty
-USE MOD_Particle_Surfaces_Vars,   ONLY: BezierControlPoints3D,BezierControlPoints3DElevated,BezierElevation
+USE MOD_Mesh_Vars,                ONLY: NGeo,NGeoElevated
+!USE MOD_Particle_Surfaces_Vars,   ONLY: SideSlabNormals,SideSlabIntervals,BoundingBoxIsEmpty
+!USE MOD_Particle_Surfaces_Vars,   ONLY: BezierControlPoints3D,BezierControlPoints3DElevated,BezierElevation
+USE MOD_Particle_Surfaces_Vars,   ONLY: BezierElevation
 USE MOD_Particle_Surfaces_Vars,   ONLY: BezierEpsilonBilinear
 #ifdef CODE_ANALYZE
 USE MOD_Particle_Surfaces_Vars,   ONLY: SideBoundingBoxVolume
@@ -813,10 +608,13 @@ IMPLICIT NONE
 ! INPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
-INTEGER,INTENT(IN) :: SideID,NGeo
-!REAL,INTENT(IN)    :: XCL_NGeo(3,0:NGeo,0:NGeo,0:NGeo)
+REAL,INTENT(IN)     :: BezierControlPoints3D(1:3,0:NGeo,0:NGeo)
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
+REAL,INTENT(OUT)    :: BezierControlPoints3DElevated(1:3,0:NGeoElevated,0:NGeoElevated)
+REAL,INTENT(OUT)    :: SideSlabNormals(1:3,1:3)
+REAL,INTENT(OUT)    :: SideSlabInterVals(1:6)
+LOGICAL,INTENT(OUT) :: BoundingBoxIsEmpty
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
 !INTEGER                           :: lastSideID,flip,SideID
@@ -830,7 +628,8 @@ LOGICAL            :: SideIsCritical
 IF(BezierElevation.EQ.0)THEN
   BezierControlPoints3DElevated=BezierControlPoints3D
 ELSE
-  CALL GetBezierControlPoints3DElevated(NGeo,SideID)
+  CALL GetBezierControlPoints3DElevated(NGeo,NGeoElevated,BezierControlPoints3D(1:3,0:NGeo,0:NGeo)     &
+                                            ,BezierControlPoints3DElevated(1:3,0:NGeoElevated,0:NGeoElevated) )
 END IF
 
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -841,48 +640,44 @@ END IF
 ! 1.) slab normal vectors
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! n_1=V_1+V_2 (V: corner vectors in xi-direction)
-SideSlabNormals(:,1,SideID)=BezierControlPoints3DElevated(:,NGeo+BezierElevation,0,SideID)                      &
-                           -BezierControlPoints3DElevated(:,0,0,SideID)                                         &
-                           +BezierControlPoints3DElevated(:,NGeo+BezierElevation,NGeo+BezierElevation,SideID)   &
-                           -BezierControlPoints3DElevated(:,0,NGeo+BezierElevation,SideID)
-SideSlabNormals(:,1,SideID)=SideSlabNormals(:,1,SideID)/SQRT(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,1,SideID)))
+SideSlabNormals(:,1)=BezierControlPoints3DElevated(:,NGeoElevated,0)                      &
+                           -BezierControlPoints3DElevated(:,0,0)                                         &
+                           +BezierControlPoints3DElevated(:,NGeoElevated,NGeoElevated)   &
+                           -BezierControlPoints3DElevated(:,0,NGeoElevated)
+SideSlabNormals(:,1)=SideSlabNormals(:,1)/SQRT(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,1)))
 ! n_2=n_1 x (U_1+U_2) (U: corner vectors in eta-direction)
-SideSlabNormals(:,2,SideID)=BezierControlPoints3DElevated(:,0,NGeo+BezierElevation,SideID)                      &
-                           -BezierControlPoints3DElevated(:,0,0,SideID)                                         &
-                           +BezierControlPoints3DElevated(:,NGeo+BezierElevation,NGeo+BezierElevation,SideID)   &
-                           -BezierControlPoints3DElevated(:,NGeo+BezierElevation,0,SideID)
+SideSlabNormals(:,2)=BezierControlPoints3DElevated(:,0,NGeoElevated)                      &
+                           -BezierControlPoints3DElevated(:,0,0)                                         &
+                           +BezierControlPoints3DElevated(:,NGeoElevated,NGeoElevated)   &
+                           -BezierControlPoints3DElevated(:,NGeoElevated,0)
 
-!print*,"length(SideSlabNormals(:,1,SideID))",DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,1,SideID))
 !fehlt das?
-!SideSlabNormals(:,2,SideID)=SideSlabNormals(:,2,SideID)/SQRT(DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,2,SideID)))
-SideSlabNormals(:,2,SideID)=CROSSNORM(SideSlabNormals(:,1,SideID),SideSlabNormals(:,2,SideID))
-!print*,"length(SideSlabNormals(:,2,SideID))",DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,2,SideID))
+SideSlabNormals(:,2)=CROSSNORM(SideSlabNormals(:,1),SideSlabNormals(:,2))
 
-!SideSlabNormals(:,2,SideID)=SideSlabNormals(:,2,SideID)/SQRT(DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,2,SideID)))
 ! n_3=n_1 x n_2
-SideSlabNormals(:,3,SideID)=CROSSNORM(SideSlabNormals(:,2,SideID),SideSlabNormals(:,1,SideID))
+SideSlabNormals(:,3)=CROSSNORM(SideSlabNormals(:,2),SideSlabNormals(:,1))
 
 ! check vector length=1
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,1,SideID))-1.)).GT.1.E-6) CALL Abort(&
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,1))-1.)).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 1 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,1,SideID)))
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,2,SideID))-1.)).GT.1.E-6) CALL Abort(&
+,'Side slab normal 1 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,1)))
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,2),SideSlabNormals(:,2))-1.)).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 2 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,2,SideID)))
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,3,SideID),SideSlabNormals(:,3,SideID))-1.)).GT.1.E-6) CALL Abort(&
+,'Side slab normal 2 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,2),SideSlabNormals(:,2)))
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,3),SideSlabNormals(:,3))-1.)).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 3 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,3,SideID),SideSlabNormals(:,3,SideID)))
+,'Side slab normal 3 does not have the length 1 .',1,DOT_PRODUCT(SideSlabNormals(:,3),SideSlabNormals(:,3)))
 
 ! check perpendicularity
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,2,SideID)))).GT.1.E-6) CALL Abort(&
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,2)))).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 1 and 2 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,2,SideID))))
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,3,SideID)))).GT.1.E-6) CALL Abort(&
+,'Side slab normal 1 and 2 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,2))))
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,3)))).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 1 and 3 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,1,SideID),SideSlabNormals(:,3,SideID))))
-IF((ABS(DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,3,SideID)))).GT.1.E-6) CALL Abort(&
+,'Side slab normal 1 and 3 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,1),SideSlabNormals(:,3))))
+IF((ABS(DOT_PRODUCT(SideSlabNormals(:,2),SideSlabNormals(:,3)))).GT.1.E-6) CALL Abort(&
 __STAMP__&
-,'Side slab normal 2 and 3 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,2,SideID),SideSlabNormals(:,3,SideID))))
+,'Side slab normal 2 and 3 are not perpendicular.',0,ABS(DOT_PRODUCT(SideSlabNormals(:,2),SideSlabNormals(:,3))))
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 2.) slab box intervalls beta_1, beta_2, beta_3
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -891,38 +686,38 @@ __STAMP__&
 
 ! Intervall beta_1
 !print*,"SideID",SideID
-SideSlabIntervals(:, SideID)=0.
+SideSlabIntervals(:)=0.
 
-DO q=0,NGeo+BezierElevation
-  DO p=0,NGeo+BezierElevation
+DO q=0,NGeoElevated
+  DO p=0,NGeoElevated
     IF((p.EQ.0).AND.(q.EQ.0))CYCLE
-    skalprod(1)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q,SideID)-&
-                            BezierControlPoints3DElevated(:,0,0,SideID),SideSlabNormals(:,1,SideID))
-    skalprod(2)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q,SideID)-&
-                            BezierControlPoints3DElevated(:,0,0,SideID),SideSlabNormals(:,2,SideID))
-    skalprod(3)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q,SideID)-&
-                            BezierControlPoints3DElevated(:,0,0,SideID),SideSlabNormals(:,3,SideID))
+    skalprod(1)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q)-&
+                            BezierControlPoints3DElevated(:,0,0),SideSlabNormals(:,1))
+    skalprod(2)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q)-&
+                            BezierControlPoints3DElevated(:,0,0),SideSlabNormals(:,2))
+    skalprod(3)=DOT_PRODUCT(BezierControlPoints3DElevated(:,p,q)-&
+                            BezierControlPoints3DElevated(:,0,0),SideSlabNormals(:,3))
     IF    (skalprod(1).LT.0.)THEN
-      SideSlabIntervals(1, SideID)=MIN(SideSlabIntervals(1,SideID),skalprod(1))
+      SideSlabIntervals(1)=MIN(SideSlabIntervals(1),skalprod(1))
     ELSEIF(skalprod(1).GT.0.)THEN
-      SideSlabIntervals(2, SideID)=MAX(SideSlabIntervals(2,SideID),skalprod(1))
+      SideSlabIntervals(2)=MAX(SideSlabIntervals(2),skalprod(1))
     END IF
     IF    (skalprod(2).LT.0.)THEN
-      SideSlabIntervals(3, SideID)=MIN(SideSlabIntervals(3,SideID),skalprod(2))
+      SideSlabIntervals(3)=MIN(SideSlabIntervals(3),skalprod(2))
     ELSEIF(skalprod(2).GT.0.)THEN
-      SideSlabIntervals(4, SideID)=MAX(SideSlabIntervals(4,SideID),skalprod(2))
+      SideSlabIntervals(4)=MAX(SideSlabIntervals(4),skalprod(2))
     END IF
     IF    (skalprod(3).LT.0.)THEN
-      SideSlabIntervals(5, SideID)=MIN(SideSlabIntervals(5,SideID),skalprod(3))
+      SideSlabIntervals(5)=MIN(SideSlabIntervals(5),skalprod(3))
     ELSEIF(skalprod(3).GT.0.)THEN
-      SideSlabIntervals(6, SideID)=MAX(SideSlabIntervals(6,SideID),skalprod(3))
+      SideSlabIntervals(6)=MAX(SideSlabIntervals(6),skalprod(3))
     END IF
   END DO !p
 END DO !q
-!print*,"SideID",SideID," is planar:",SideIsPlanar(SideID)
-dx=ABS(ABS(SideSlabIntervals(2, SideID))-ABS(SideSlabIntervals(1, SideID)))
-dy=ABS(ABS(SideSlabIntervals(4, SideID))-ABS(SideSlabIntervals(3, SideID)))
-dz=ABS(ABS(SideSlabIntervals(6, SideID))-ABS(SideSlabIntervals(5, SideID)))
+
+dx=ABS(ABS(SideSlabIntervals(2))-ABS(SideSlabIntervals(1)))
+dy=ABS(ABS(SideSlabIntervals(4))-ABS(SideSlabIntervals(3)))
+dz=ABS(ABS(SideSlabIntervals(6))-ABS(SideSlabIntervals(5)))
 
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! 3.) Is Side critical? (particle path parallel to the larger surface, therefore numerous intersections are possilbe)
@@ -957,7 +752,7 @@ __STAMP__&
 ,'Bezier side length is degenerated. dx/dMax.LT.BezierEpsilonBilinear ->',0,dx/dMax)
 END IF
 IF(dy/dMax.LT.BezierEpsilonBilinear)THEN
-  SideSlabIntervals(3:4, SideID)=0.
+  SideSlabIntervals(3:4)=0.
   dy=0.
 END IF
 IF(dz/dMax.LT.BezierEpsilonBilinear)THEN
@@ -974,13 +769,13 @@ __STAMP__&
 END IF
 
 IF(ALMOSTZERO(dx*dy*dz))THEN ! bounding box volume is approx zeros
-  BoundingBoxIsEmpty(SideID)=.TRUE.
+  BoundingBoxIsEmpty=.TRUE.
 ELSE
-  BoundingBoxIsEmpty(SideID)=.FALSE.
+  BoundingBoxIsEmpty=.FALSE.
 END IF
 
 #ifdef CODE_ANALYZE
-SideBoundingBoxVolume(SideID)=dx*dy*dz
+SideBoundingBoxVolume=dx*dy*dz
 #endif /*CODE_ANALYZE*/
 END SUBROUTINE GetSideSlabNormalsAndIntervals
 
@@ -1133,44 +928,38 @@ __STAMP__&
 END SUBROUTINE GetElemSlabNormalsAndIntervals
 
 
-SUBROUTINE GetBezierControlPoints3DElevated(NGeo,SideID)
+SUBROUTINE GetBezierControlPoints3DElevated(NGeo,NGeoElevated,BezierControlPoints,BezierControlPointsElevated)
 !===================================================================================================================================
 ! compute the elevated bezier control points (use pre-computed ElevationMatrix with binomial coefficicents)
 ! uses the tensor-product basis and combines two 1-D elevation steps
 !===================================================================================================================================
 ! MODULES
-!USE MOD_Globals
-!USE MOD_Globals_Vars,    ONLY:EpsMach
-!USE MOD_Preproc
-!USE MOD_Particle_Surfaces_Vars,   ONLY:SideSlabNormals,SideSlabIntervals,BezierControlPoints3D,BoundingBoxIsEmpty
-!USE MOD_Particle_Surfaces_Vars,   ONLY:BezierEpsilonBilinear
-USE MOD_Particle_Surfaces_Vars,   ONLY:BezierControlPoints3D,BezierControlPoints3DElevated,BezierElevation
+!USE MOD_Particle_Surfaces_Vars,   ONLY:BezierControlPoints3D,BezierControlPoints3DElevated,BezierElevation
+USE MOD_Particle_Surfaces_Vars,   ONLY:BezierElevation
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
 ! INPUT VARIABLES
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
-INTEGER,INTENT(IN) :: SideID,NGeo
-!REAL,INTENT(IN)    :: XCL_NGeo(3,0:NGeo,0:NGeo,0:NGeo)
+INTEGER,INTENT(IN) :: NGeo,NGeoElevated
+REAL,INTENT(IN)    :: BezierControlPoints(1:3,0:NGeo,0:NGeo)
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
+REAL,INTENT(OUT)   :: BezierControlPointsElevated(1:3,0:NGeoElevated,0:NGeoElevated)
+!-----------------------------------------------------------------------------------------------------------------------------------
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! LOCAL VARIABLES
-!INTEGER                           :: lastSideID,flip,SideID
 INTEGER            :: p,q
-!REAL                              :: tmp(3,0:NGeo,0:NGeo)  
-!REAL               :: skalprod(3),dx,dy,dz,dMax,dMin,w,h,l
-!LOGICAL            :: SideIsCritical
-REAL               :: temp(1:3,0:NGeo+BezierElevation,0:NGeo)
+REAL               :: temp(1:3,0:NGeoElevated,0:NGeo)
 !===================================================================================================================================
 temp=0.
 ! p-direction
 DO q=0,NGeo
-  temp(:,:,q)=ElevateBezierPolynomial(NGeo,BezierControlPoints3D(:,:,q,SideID))
+  temp(:,:,q)=ElevateBezierPolynomial(NGeo,BezierControlPoints(:,:,q))
 END DO
 ! q-direction
-DO p=0,NGeo+BezierElevation
-  BezierControlPoints3DElevated(:,p,:,SideID)=ElevateBezierPolynomial(NGeo,temp(:,p,:))
+DO p=0,NGeoElevated
+  BezierControlPointsElevated(:,p,:)=ElevateBezierPolynomial(NGeo,temp(:,p,:))
 END DO
 END SUBROUTINE GetBezierControlPoints3DElevated
 
diff --git a/src/particles/particle_mpi/particle_mpi.f90 b/src/particles/particle_mpi/particle_mpi.f90
index a4e348b..2a6ab6f 100644
--- a/src/particles/particle_mpi/particle_mpi.f90
+++ b/src/particles/particle_mpi/particle_mpi.f90
@@ -1500,9 +1500,10 @@ SUBROUTINE ExchangeBezierControlPoints3D()
 !----------------------------------------------------------------------------------------------------------------------------------!
 USE MOD_Globals
 USE MOD_MPI_Vars
-USE MOD_Mesh_Vars,                  ONLY:NGeo,nSides,nUniqueSides,NGeo
+USE MOD_Mesh_Vars,                  ONLY:NGeo,NGeoElevated,nSides,nUniqueSides
 USE MOD_Particle_Surfaces,          ONLY:GetSideSlabNormalsAndIntervals
-USE MOD_Particle_Surfaces_vars,     ONLY:BezierControlPoints3D,SideSlabIntervals
+USE MOD_Particle_Surfaces_vars,     ONLY:BezierControlPoints3D,SideSlabIntervals,BezierControlPoints3DElevated &
+                                        ,SideSlabIntervals,SideSlabNormals,BoundingBoxIsEmpty
 !----------------------------------------------------------------------------------------------------------------------------------!
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
@@ -1548,7 +1549,13 @@ END DO !iProc=1,nNBProcs
 
 ! build my slave sides (your master are already built)
 DO iSide=nUniqueSides+1,nSides
-  CALL GetSideSlabNormalsAndIntervals(NGeo,iSide) ! elevation occurs within this routine
+  !CALL GetSideSlabNormalsAndIntervals(iSide) ! elevation occurs within this routine
+  ! elevation occurs within this routine
+  CALL GetSideSlabNormalsAndIntervals(BezierControlPoints3D(1:3,0:NGeo,0:NGeo,iSide)                         &
+                                     ,BezierControlPoints3DElevated(1:3,0:NGeoElevated,0:NGeoElevated,iSide) &
+                                     ,SideSlabNormals(1:3,1:3,iSide)                                         &
+                                     ,SideSlabInterVals(1:6,iSide)                                           &
+                                     ,BoundingBoxIsEmpty(iSide)                                              )
 END DO
 
 DO iSide=1,nSides
diff --git a/src/particles/pic/interpolation/init_BGField.f90 b/src/particles/pic/interpolation/init_BGField.f90
index 86de259..ac08897 100644
--- a/src/particles/pic/interpolation/init_BGField.f90
+++ b/src/particles/pic/interpolation/init_BGField.f90
@@ -38,7 +38,7 @@ USE MOD_ReadInTools,            ONLY:GETSTR,GETINT,GETREAL
 USE MOD_HDF5_Input,             ONLY:OpenDataFile,CloseDataFile,GetDataProps,ReadAttribute,File_ID,ReadArray
 USE MOD_PICInterpolation_Vars,  ONLY:InterpolationType,NBG,BGType,BGField
 USE MOD_PICInterpolation_Vars,  ONLY:BGField_xGP,BGField_wGP,BGField_wBary,BGDataSize
-USE MOD_Interpolation_Vars,     ONLY:StrNodeType
+USE MOD_Interpolation_Vars,     ONLY:NodeType
 ! IMPLICIT VARIABLE HANDLING
  IMPLICIT NONE
 !----------------------------------------------------------------------------------------------------------------------------------
@@ -155,7 +155,7 @@ CASE DEFAULT
 END SELECT
 CALL BarycentricWeights(NBG,BGField_xGP,BGField_wBary)
 
-IF(TRIM(NodeType_BGField).NE.TRIM(StrNodeType))THEN
+IF(TRIM(NodeType_BGField).NE.TRIM(NodeType))THEN
   SWRITE(UNIT_stdOut,'(A)')' WARNING: NodeType of BF-Field does not equal DG-NodeType. No ChangeBasis.'
 END IF
 
diff --git a/src/particles/tracking/particle_intersection.f90 b/src/particles/tracking/particle_intersection.f90
index a31a8e5..a18005d 100644
--- a/src/particles/tracking/particle_intersection.f90
+++ b/src/particles/tracking/particle_intersection.f90
@@ -13,10 +13,6 @@ INTERFACE ComputeBezierIntersection
   MODULE PROCEDURE ComputeBezierIntersection
 END INTERFACE
 
-INTERFACE PartInElemCheck
-  MODULE PROCEDURE PartInElemCheck
-END INTERFACE
-
 INTERFACE ComputeBilinearIntersectionSuperSampled2
   MODULE PROCEDURE ComputeBilinearIntersectionSuperSampled2
 END INTERFACE
@@ -25,8 +21,12 @@ INTERFACE ComputePlanarInterSectionBezier
   MODULE PROCEDURE ComputePlanarInterSectionBezier
 END INTERFACE
 
-INTERFACE ComputePlanarInterSectionBezierRobust
-  MODULE PROCEDURE ComputePlanarInterSectionBezierRobust
+INTERFACE ComputePlanarNonrectIntersection
+  MODULE PROCEDURE ComputePlanarNonrectIntersection
+END INTERFACE
+
+INTERFACE ComputePlanarRectInterSection
+  MODULE PROCEDURE ComputePlanarRectInterSection
 END INTERFACE
 
 INTERFACE ComputeBilinearIntersectionRobust
@@ -42,9 +42,9 @@ PUBLIC::ComputeBezierIntersection
 PUBLIC::ComputeBilinearIntersectionSuperSampled2
 PUBLIC::ComputeBilinearIntersectionRobust
 PUBLIC::ComputePlanarInterSectionBezier
-PUBLIC::ComputePlanarInterSectionBezierRobust
+PUBLIC::ComputePlanarRectInterSection
 PUBLIC::ComputePlanarInterSectionBezierRobust2
-PUBLIC::PartInElemCheck
+PUBLIC::ComputePlanarNonrectIntersection
 !-----------------------------------------------------------------------------------------------------------------------------------
 !-----------------------------------------------------------------------------------------------------------------------------------
 !===================================================================================================================================
@@ -52,142 +52,6 @@ PUBLIC::PartInElemCheck
 CONTAINS
 
 
-SUBROUTINE PartInElemCheck(PartID,ElemID,Check)
-!===================================================================================================================================
-! Compute the intersection with a Bezier surface
-! particle path = LastPartPos+lengthPartTrajectory*PartTrajectory
-!===================================================================================================================================
-! MODULES
-USE MOD_Globals,                ONLY:Almostzero
-USE MOD_Mesh_Vars,              ONLY:NGeo
-USE MOD_Particle_Mesh_Vars,     ONLY:ElemBaryNGeo
-USE MOD_Particle_Vars,          ONLY:PartState,LastPartPos
-USE MOD_Particle_Surfaces_Vars, ONLY:BezierControlPoints3D,SideType,BezierControlPoints3D,SideNormVec
-USE MOD_Particle_Mesh_Vars,     ONLY:PartElemToSide,PartBCSideList
-USE MOD_Particle_Surfaces,      ONLY:CalcNormAndTangBilinear,CalcNormAndTangBezier
-USE MOD_Particle_Tracking_Vars, ONLY:DoRefMapping
-! IMPLICIT VARIABLE HANDLING
-IMPLICIT NONE
-! INPUT VARIABLES
-!-----------------------------------------------------------------------------------------------------------------------------------
-! INPUT VARIABLES
-INTEGER,INTENT(IN)                       :: ElemID,PartID
-!-----------------------------------------------------------------------------------------------------------------------------------
-! OUTPUT VARIABLES
-LOGICAL,INTENT(OUT)                      :: Check
-!-----------------------------------------------------------------------------------------------------------------------------------
-! LOCAL VARIABLES
-INTEGER                                  :: ilocSide,flip,SideID,BCSideID
-REAL                                     :: PartTrajectory(1:3),NormVec(1:3)
-REAL                                     :: lengthPartTrajectory,tmpPos(3),xNodes(1:3,1:4),tmpLastPartPos(1:3)
-LOGICAL                                  :: isHit
-REAL                                     :: alpha,eta,xi
-!===================================================================================================================================
-
-! backup positions
-tmpPos=PartState(PartID,1:3)
-tmpLastPartPos(1:3)=LastPartPos(PartID,1:3)
-! virtual move to element barycenter
-LastPartPos(PartID,1:3)=PartState(PartID,1:3)
-PartState(PartID,1:3)=ElemBaryNGeo(:,ElemID)
-PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
-lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
-                         +PartTrajectory(2)*PartTrajectory(2) &
-                         +PartTrajectory(3)*PartTrajectory(3) )
-IF(ALMOSTZERO(lengthPartTrajectory))THEN
-  Check=.TRUE.
-  PartState(PartID,1:3)   = tmpPos
-  LastPartPos(PartID,1:3) = tmpLastPartPos
-  ! bugfix by Tilman
-  RETURN
-END IF
-PartTrajectory=PartTrajectory/lengthPartTrajectory
-isHit=.FALSE.
-DO ilocSide=1,6
-  !SideID=ElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
-  SideID=PartElemToSide(E2S_SIDE_ID,ilocSide,ElemID) 
-  flip  = PartElemToSide(E2S_FLIP,ilocSide,ElemID)
-  IF(DoRefMapping)THEN
-    IF(SideID.LT.1) CYCLE
-    BCSideID=SideID
-    SideID=PartBCSideList(BCSideID)
-    IF(SideID.LT.1) CYCLE
-  END IF
-  
-  SELECT CASE(SideType(SideID))
-!  CASE(PLANAR_RECT)
-!    CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta  &
-!                                                                            ,PartID,flip,SideID)
-!  CASE(BILINEAR,PLANAR_NONRECT)
-!    xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
-!    xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
-!    xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
-!    xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
-!    CALL ComputeBiLinearIntersectionSuperSampled2(ishit,xNodes &
-!                                                        ,PartTrajectory,lengthPartTrajectory,Alpha &
-!                                                                                      ,xi                       &
-!                                                                                      ,eta                ,PartID,flip,SideID)
-!  CASE(CURVED)
-!    CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,Alpha &
-!                                                                            ,xi                 &
-!                                                                            ,eta                ,PartID,SideID)
-
-
-
-  CASE(PLANAR_RECT)
-
-    CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,alpha &
-                                                                              ,xi,eta ,PartID,flip,SideID)
-    !CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,Alpha &
-    !                                                                              ,xi             &
-    !                                                                              ,eta   ,PartID,flip,SideID)
-  CASE(BILINEAR)
-    xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
-    xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
-    xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
-    xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
-    CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
-                                                 ,PartTrajectory,lengthPartTrajectory,Alpha &
-                                                                                     ,xi       &
-                                                                                     ,eta      &
-                                                                                     ,PartID,flip,SideID)
-
-  CASE(CURVED,PLANAR_NONRECT)
-    CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,Alpha &
-                                                                            ,xi       &
-                                                                            ,eta      ,PartID,SideID)
-
-  END SELECT
-  IF(DoRefMapping)THEN
-    IF(alpha.GT.-1)THEN
-      SELECT CASE(SideType(SideID))
-      CASE(PLANAR_RECT,PLANAR_NONRECT)
-        NormVec=SideNormVec(1:3,SideID)
-      CASE(BILINEAR)
-        CALL CalcNormAndTangBilinear(nVec=NormVec,xi=xi,eta=eta,SideID=SideID)
-      CASE(CURVED)
-        CALL CalcNormAndTangBezier(nVec=NormVec,xi=xi,eta=eta,SideID=SideID)
-      END SELECT 
-      IF(DOT_PRODUCT(NormVec,PartState(PartID,4:6)).LT.0.) alpha=-1.0
-    END IF
-  END IF
-  IF(alpha.GT.-1.0) THEN
-    !IF((ABS(xi).GT.1.0).OR.(ABS(eta).GT.1.0)) THEN
-    !IF((ABS(xi).GT.BezierClipHit).OR.(ABS(eta).GT.BezierClipHit)) THEN
-    !  isHit=.FALSE.
-    !END IF
-    isHit=.TRUE.
-  END IF
-  IF(isHit) EXIT
-END DO ! ilocSide
-Check=.TRUE.
-IF(isHit) Check=.FALSE.
-PartState(PartID,1:3)   = tmpPos
-LastPartPos(PartID,1:3) = tmpLastPartPos
-
-END SUBROUTINE PartInElemCheck
-
-
 SUBROUTINE ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,SideID)
 !===================================================================================================================================
 ! Compute the intersection with a Bezier surface
@@ -198,6 +62,7 @@ USE MOD_Globals_Vars,            ONLY:PI
 USE MOD_Globals,                 ONLY:Cross,abort,UNIT_stdOut,AlmostZero
 USE MOD_Mesh_Vars,               ONLY:NGeo,nBCSides,nSides,BC
 USE MOD_Particle_Vars,           ONLY:PartState,LastPartPos
+USE MOD_Particle_Surfaces_Vars,  ONLY:SideType
 USE MOD_Particle_Surfaces_Vars,  ONLY:SideNormVec,epsilontol,BezierNewtonAngle
 USE MOD_Particle_Surfaces_Vars,  ONLY:BezierControlPoints3D
 USE MOD_Particle_Surfaces_Vars,  ONLY:locXi,locEta,locAlpha
@@ -299,7 +164,7 @@ END DO
 !ELSE
 !END IF
 !IF(.NOT.BezierNewtonAngle)THEN
-IF(PartFaceAngle.LT.BezierNewtonAngle)THEN ! 1 = 0.01745rad: critical side at the moment need: 0.57 angle
+IF((PartFaceAngle.LT.BezierNewtonAngle))THEN ! 1 = 0.01745rad: critical side at the moment need: 0.57 angle
 #ifdef CODE_ANALYZE
 rPerformBezierClip=rPerformBezierClip+1.
 #endif /*CODE_ANALYZE*/
@@ -316,7 +181,7 @@ rPerformBezierClip=rPerformBezierClip+1.
   IF(dXi.LT.dEta) firstClip=.FALSE.
   ! CALL recursive Bezier clipping algorithm
   CALL BezierClip(firstClip,BezierControlPoints2D,PartTrajectory,lengthPartTrajectory&
-                 ,iClipIter,nXiClip,nEtaClip,nInterSections,iPart,SideID)
+                ,iClipIter,nXiClip,nEtaClip,nInterSections,iPart,SideID)
 ELSE!BezierNewtonAngle
 #ifdef CODE_ANALYZE
 rPerformBezierNewton=rPerformBezierNewton+1.
@@ -328,7 +193,7 @@ nEtaClip=0
 nInterSections=0
 firstClip=.TRUE.
 CALL BezierClip(firstClip,BezierControlPoints2D_tmp,PartTrajectory,lengthPartTrajectory&
-               ,iClipIter,nXiClip,nEtaClip,nInterSections,iPart,SideID)
+              ,iClipIter,nXiClip,nEtaClip,nInterSections,iPart,SideID)
 IF(nInterSections.GT.1)THEN
   CALL abort(&
   __STAMP__&
@@ -1347,7 +1212,8 @@ IF(DoCheck)THEN
   !IF((alpha/lengthPartTrajectory.LE.1.0000464802767983).AND.(alpha.GT.MinusEps))THEN
   alphaNorm=alpha/lengthPartTrajectory
 
-  IF((alphaNorm.LE.BezierClipHit).AND.(alphaNorm.GT.-epsilontol))THEN
+  !IF((alphaNorm.LE.BezierClipHit).AND.(alphaNorm.GT.-epsilontol))THEN
+  IF((alphaNorm.LE.1.0).AND.(alphaNorm.GT.-epsilontol))THEN
     ! found additional intersection point
     IF(nInterSections.GE.BezierClipMaxIntersec)THEN
       !nInterSections=nInterSections-1
@@ -1481,7 +1347,8 @@ alpha=DOT_PRODUCT(IntersectionVector,PartTrajectory)
 
 alphaNorm=alpha/lengthPartTrajectory
 
-IF((alphaNorm.LE.BezierClipHit).AND.(alphaNorm.GT.-epsilontol)) RETURN
+!IF((alphaNorm.LE.BezierClipHit).AND.(alphaNorm.GT.-epsilontol)) RETURN
+IF((alphaNorm.LE.1.0).AND.(alphaNorm.GT.-epsilontol)) RETURN
 alpha=-1.0
  
 END SUBROUTINE BezierNewton
@@ -1954,7 +1821,8 @@ END IF ! SidePeriodicType
 
 alphaNorm=alpha/lengthPartTrajectory
 
-IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
+!IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
+IF((alphaNorm.GT.1.0) .OR.(alphaNorm.LT.-epsilontol))THEN
   alpha=-1.0
   RETURN
 END IF
@@ -2019,7 +1887,9 @@ C2=P0(2)+P0(3)
 
 sdet=A1*B2-A2*B1
 IF(ABS(sdet).EQ.0)THEN
-  STOP 'error'
+  CALL abort(& 
+  __STAMP__& 
+  ,' ABS(sdet).EQ.0!')
 END IF
 sdet=1.0/sdet
 
@@ -2042,7 +1912,7 @@ isHit=.TRUE.
 END SUBROUTINE ComputePlanarIntersectionBezier
 
 
-SUBROUTINE ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,flip,SideID)!,doTest)
+SUBROUTINE ComputePlanarRectIntersection(isHit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,flip,SideID)!,doTest)
 !===================================================================================================================================
 ! Compute the Intersection with planar surface
 ! equation of plane: P1*xi + P2*eta+P0
@@ -2164,7 +2034,8 @@ END IF
 alphaNorm=alpha/lengthPartTrajectory
 !IF((alpha.GT.lengthPartTrajectory) .OR.(alpha.LT.-epsilontol))THEN
 
-IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
+!IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
+IF((alphaNorm.GT.1.0) .OR.(alphaNorm.LT.-epsilontol))THEN
 !IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LE.0.))THEN
 !IF((alphaNorm.GE.1.0) .OR.(alphaNorm.LT.0.))THEN
   ishit=.FALSE.
@@ -2186,13 +2057,13 @@ P2=0.25*P2
 Inter1=LastPartPos(iPart,1:3)+alpha*PartTrajectory
 P0=-0.25*P0+Inter1
 
-A1=P1(1)+P1(3)
-B1=P2(1)+P2(3)
-C1=P0(1)+P0(3)
+A1=P1(1)*P1(1)+P1(2)*P1(2)+P1(3)*P1(3)
+B1=P2(1)*P1(1)+P2(2)*P1(2)+P2(3)*P1(3)
+C1=P1(1)*P0(1)+P1(2)*P0(2)+P1(3)*P0(3)
 
-A2=P1(2)+P1(3)
-B2=P2(2)+P2(3)
-C2=P0(2)+P0(3)
+A2=B1
+B2=P2(1)*P2(1)+P2(2)*P2(2)+P2(3)*P2(3)
+C2=P2(1)*P0(1)+P2(2)*P0(2)+P2(3)*P0(3)
 
 !IF((ABS(P2(1)).GE.ABS(P2(2))).AND.(ABS(P2(1))).GE.ABS(P2(3)))THEN
 !  xi1= P1(2)-P2(2)/P2(1)*P1(1)
@@ -2269,13 +2140,15 @@ C2=P0(2)+P0(3)
 
 sdet=A1*B2-A2*B1
 IF(ABS(sdet).EQ.0)THEN
-  STOP 'error'
+  CALL abort(& 
+  __STAMP__& 
+  ,' ABS(sdet).EQ.0!')
 END IF
 sdet=1.0/sdet
 epsLoc=1.0+100.*epsMach
 
 
-xi=(b2*c1-b1*c2)*sdet
+xi=(B2*C1-B1*C2)*sdet
 !IF(ABS(xi).GT.BezierClipHit)THEN
 
 IF(ABS(xi).GT.epsLoc)THEN
@@ -2285,7 +2158,7 @@ IF(ABS(xi).GT.epsLoc)THEN
 END IF
 
 !eta=-((A1+A2)*xi+C1+C2)/(B1+B2)
-eta=(-a2*c1+a1*c2)*sdet
+eta=(-A2*C1+A1*C2)*sdet
 !IF(ABS(eta).GT.BezierClipHit)THEN
 IF(ABS(eta).GT.epsLoc)THEN
   alpha=-1.0
@@ -2293,8 +2166,140 @@ IF(ABS(eta).GT.epsLoc)THEN
 END IF
 isHit=.TRUE.
 
-END SUBROUTINE ComputePlanarIntersectionBezierRobust
+END SUBROUTINE ComputePlanarRectIntersection
+
+
+SUBROUTINE ComputePlanarNonrectIntersection(isHit,PartTrajectory,lengthPartTrajectory,alpha,xi,eta,iPart,flip,SideID)
+!===================================================================================================================================
+! Compute the intersection with a planar non rectangular face
+! particle path = LastPartPos+lengthPartTrajectory*PartTrajectory
+!===================================================================================================================================
+! MODULES
+USE MOD_Globals_Vars,            ONLY:PI
+USE MOD_Globals,                 ONLY:Cross,abort,UNIT_stdOut,AlmostZero
+USE MOD_Mesh_Vars,               ONLY:NGeo,nBCSides,nSides,BC
+USE MOD_Particle_Vars,           ONLY:PartState,LastPartPos
+USE MOD_Particle_Surfaces_Vars,  ONLY:SideType
+USE MOD_Particle_Surfaces_Vars,  ONLY:SideNormVec,epsilontol,BezierNewtonAngle
+USE MOD_Particle_Surfaces_Vars,  ONLY:BezierControlPoints3D
+USE MOD_Particle_Surfaces_Vars,  ONLY:locXi,locEta,locAlpha
+USE MOD_Particle_Surfaces_Vars,  ONLY:SideSlabNormals,epsilonTol
+USE MOD_Utils,                   ONLY:InsertionSort !BubbleSortID
+USE MOD_Particle_Tracking_Vars,  ONLY:DoRefMapping
+#ifdef CODE_ANALYZE
+USE MOD_Particle_Surfaces_Vars,  ONLY:BezierClipTolerance,BezierClipMaxIntersec,BezierClipMaxIter
+USE MOD_Globals,                 ONLY:myrank
+USE MOD_Particle_Surfaces_Vars,  ONLY:rBoundingBoxChecks,rPerformBezierClip,rPerformBezierNewton
+#endif /*CODE_ANALYZE*/
+! IMPLICIT VARIABLE HANDLING
+IMPLICIT NONE
+! INPUT VARIABLES
+!-----------------------------------------------------------------------------------------------------------------------------------
+! INPUT VARIABLES
+REAL,INTENT(IN),DIMENSION(1:3)           :: PartTrajectory
+REAL,INTENT(IN)                          :: lengthPartTrajectory
+INTEGER,INTENT(IN)                       :: iPart,SideID
+INTEGER,INTENT(IN)                       :: flip
+!-----------------------------------------------------------------------------------------------------------------------------------
+! OUTPUT VARIABLES
+REAL,INTENT(OUT)                         :: alpha,xi,eta
+LOGICAL,INTENT(OUT)                      :: isHit
+!-----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+REAL                                     :: n1(3),n2(3)
+INTEGER                                  :: nInterSections,iInter,p,q
+INTEGER                                  :: iClipIter,nXiClip,nEtaClip
+REAL                                     :: BezierControlPoints2D(2,0:NGeo,0:NGeo)
+#ifdef CODE_ANALYZE
+REAL                                     :: BezierControlPoints2D_tmp(2,0:NGeo,0:NGeo)
+#endif /*CODE_ANALYZE*/
+INTEGER,ALLOCATABLE,DIMENSION(:)         :: locID!,realInterID
+LOGICAL                                  :: firstClip
+INTEGER                                  :: realnInter,isInter
+REAL                                     :: XiNewton(2)
+REAL                                     :: PartFaceAngle,dXi,dEta
+!REAL                                     :: Interval1D,dInterVal1D
+!===================================================================================================================================
+!PartTrajectory = PartTrajectory
+! set alpha to minus 1, asume no intersection
+alpha=-1.0
+Xi   = 2.0
+Eta  = 2.0
+isHit=.FALSE.
+
+#ifdef CODE_ANALYZE
+rBoundingBoxChecks=rBoundingBoxChecks+1.
+#endif /*CODE_ANALYZE*/
 
+IF(DoRefMapping)THEN
+  IF(DOT_PRODUCT(SideNormVec(1:3,SideID),PartTrajectory).LT.0.)RETURN
+ELSE
+  ! dependend on master/slave flip
+  IF(flip.EQ.0)THEN
+    IF(DOT_PRODUCT(SideNormVec(1:3,SideID),PartTrajectory).LT.0.)RETURN
+  ELSE
+    IF(DOT_PRODUCT(SideNormVec(1:3,SideID),PartTrajectory).GT.0.)RETURN
+  END IF
+END IF
+! 1.) Check if LastPartPos or PartState are within the bounding box. If yes then compute a Bezier intersection problem
+IF(.NOT.InsideBoundingBox(LastPartPos(iPart,1:3),SideID))THEN ! the old particle position is not inside the bounding box
+  IF(.NOT.InsideBoundingBox(PartState(iPart,1:3),SideID))THEN ! the new particle position is not inside the bounding box
+    IF(.NOT.BoundingBoxIntersection(PartTrajectory,lengthPartTrajectory,iPart,SideID)) RETURN ! the particle does not intersect the 
+                                                                                              ! bounding box
+  END IF
+END IF
+
+! 2.) Bezier intersection: transformation of bezier patch 3D->2D
+!PartTrajectory = PartTrajectoryOrig + epsilontol !move minimal in arb. dir. for preventing collapsing BezierControlPoints2D
+IF(ABS(PartTrajectory(3)).LT.epsilontol)THEN
+  n1=(/ -PartTrajectory(2)-PartTrajectory(3)  , PartTrajectory(1) ,PartTrajectory(1) /)
+ELSE
+  n1=(/ PartTrajectory(3) , PartTrajectory(3) , -PartTrajectory(1)-PartTrajectory(2) /)
+END IF
+
+! check angle to boundingbox (height normal vector)
+PartFaceAngle=ABS(0.5*PI - ACOS(DOT_PRODUCT(PartTrajectory,SideSlabNormals(:,2,SideID))))
+IF(ALMOSTZERO(PartFaceAngle*180/ACOS(-1.)))THEN
+  n1=n1 +epsilontol
+END IF
+
+n1=n1/SQRT(DOT_PRODUCT(n1,n1))
+n2(:)=(/ PartTrajectory(2)*n1(3)-PartTrajectory(3)*n1(2) &
+       , PartTrajectory(3)*n1(1)-PartTrajectory(1)*n1(3) &
+       , PartTrajectory(1)*n1(2)-PartTrajectory(2)*n1(1) /)
+n2=n2/SQRT(DOT_PRODUCT(n2,n2))
+
+DO q=0,NGeo
+  DO p=0,NGeo
+    BezierControlPoints2D(1,p,q)=DOT_PRODUCT(BezierControlPoints3D(:,p,q,SideID)-LastPartPos(iPart,1:3),n1)
+    BezierControlPoints2D(2,p,q)=DOT_PRODUCT(BezierControlPoints3D(:,p,q,SideID)-LastPartPos(iPart,1:3),n2)
+  END DO
+END DO
+
+XiNewton=0.
+CALL BezierNewton(locAlpha(1),XiNewton,BezierControlPoints2D,PartTrajectory,lengthPartTrajectory,iPart,SideID)
+nInterSections=0
+IF(locAlpha(1).GT.-1) nInterSections=1
+locXi (1)=XiNewton(1)
+locEta(1)=XiNewton(2)
+
+SELECT CASE(nInterSections)
+CASE(0)
+  RETURN
+CASE(1)
+  alpha=locAlpha(1)
+  xi =locXi (1)
+  eta=loceta(1)
+  isHit=.TRUE.
+  RETURN
+CASE DEFAULT
+  CALL abort(&
+__STAMP__&
+,' The code should never go here')
+END SELECT
+
+
+END SUBROUTINE ComputePlanarNonrectIntersection
 
 SUBROUTINE ComputeBiLinearIntersectionSuperSampled2(isHit,xNodes,PartTrajectory,lengthPartTrajectory,alpha,xitild,etatild &
                                                    ,iPart,flip,SideID)
@@ -2614,8 +2619,8 @@ IF (nRoot.EQ.1) THEN
    ! xi(1)=ComputeXi(a1,a2,eta(1))
     IF(ABS(xi(1)).LT.BezierClipHit)THEN
       alphaNorm=t(1)/lengthPartTrajectory
-      IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
-      !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GE.0.))THEN
+      !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
+      IF((alphaNorm.LE.1.0) .AND.(alphaNorm.GT.-epsilontol))THEN
       !IF((t(1).GE.-epsilontol).AND.(t(1).LE.lengthPartTrajectory))THEN
         alpha=t(1)!/LengthPartTrajectory
         xitild=xi(1)
@@ -2674,7 +2679,8 @@ ELSE
     IF(ABS(xi(1)).LT.BezierCliphit)THEN
       alphaNorm=t(1)/lengthPartTrajectory
       !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GE.0.))THEN
-      IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
+      !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
+      IF((alphaNorm.LE.1.0) .AND.(alphaNorm.GT.-epsilontol))THEN
         nInter=nInter+1
         isHit=.TRUE.
         t(1)=t(1)
@@ -2716,7 +2722,8 @@ ELSE
     IF(ABS(xi(2)).LT.BezierClipHit)THEN
       alphaNorm=t(2)/lengthPartTrajectory
       !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GE.0.))THEN
-      IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
+      !IF((alphaNorm.LT.OnePlusEps) .AND.(alphaNorm.GT.-epsilontol))THEN
+      IF((alphaNorm.LE.1.0) .AND.(alphaNorm.GT.-epsilontol))THEN
         t(2)=t(2)!/lengthPartTrajectory
         isHit=.TRUE.
         nInter=nInter+2
@@ -3114,8 +3121,8 @@ END IF
 
 alphaNorm=alpha/lengthPartTrajectory
 !IF((alpha.GT.lengthPartTrajectory) .OR.(alpha.LT.-epsilontol))THEN
-IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
-!IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LE.0.))THEN
+!IF((alphaNorm.GT.OnePlusEps) .OR.(alphaNorm.LT.-epsilontol))THEN
+IF((alphaNorm.GT.1.0) .OR.(alphaNorm.LT.-epsilontol))THEN
   alpha=-1.0
   RETURN
 END IF
diff --git a/src/particles/tracking/particle_tracking.f90 b/src/particles/tracking/particle_tracking.f90
index bc7d3f9..628a0e3 100644
--- a/src/particles/tracking/particle_tracking.f90
+++ b/src/particles/tracking/particle_tracking.f90
@@ -9,21 +9,15 @@ MODULE MOD_Particle_Tracking
 IMPLICIT NONE
 PUBLIC
 
-!INTERFACE ParticleTracking
-!  MODULE PROCEDURE ParticleTracking
-!END INTERFACE
-
-INTERFACE ParticleTrackingCurved
-  MODULE PROCEDURE ParticleTrackingCurved
+INTERFACE ParticleTracing
+  MODULE PROCEDURE ParticleTracing
 END INTERFACE
 
 INTERFACE ParticleRefTracking
-  MODULE PROCEDURE ParticleRefTrackingFast
-  !MODULE PROCEDURE ParticleRefTrackingSLOW
+  MODULE PROCEDURE ParticleRefTracking
 END INTERFACE
 
-!PUBLIC::ParticleTracking,ParticleTrackingCurved
-PUBLIC::ParticleTrackingCurved
+PUBLIC::ParticleTracing
 PUBLIC::ParticleRefTracking
 !-----------------------------------------------------------------------------------------------------------------------------------
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -31,31 +25,33 @@ PUBLIC::ParticleRefTracking
 
 CONTAINS
 
-SUBROUTINE ParticleTrackingCurved(doParticle_In)
+SUBROUTINE ParticleTracing(doParticle_In)
 !===================================================================================================================================
-! read required parameters
+! Routine for tracing moving particles, calculate intersection and boundary interaction
+! in case of no reference tracking (dorefmapping = false)
 !===================================================================================================================================
 ! MODULES
 USE MOD_Preproc
 USE MOD_Globals
-USE MOD_Mesh_Vars,                   ONLY:NGeo!,NormVec
+USE MOD_Mesh_Vars,                   ONLY:NGeo,BC!,NormVec
 USE MOD_Particle_Vars,               ONLY:PEM,PDM
 USE MOD_Particle_Vars,               ONLY:PartState,LastPartPos
 USE MOD_Particle_Surfaces_Vars,      ONLY:SideType
 USE MOD_Particle_Surfaces_Vars,      ONLY:BezierControlPoints3D
-USE MOD_Particle_Mesh_Vars,          ONLY:PartElemToSide
+USE MOD_Particle_Mesh_Vars,          ONLY:PartElemToSide,isBCElem
 USE MOD_Particle_Boundary_Condition, ONLY:GetBoundaryInteraction
 USE MOD_Utils,                       ONLY:BubbleSortID,InsertionSort
 USE MOD_Particle_Tracking_vars,      ONLY:ntracks,nCurrentParts
-USE MOD_Particle_Mesh,               ONLY:SingleParticleToExactElementNoMap
+USE MOD_Particle_Mesh,               ONLY:SingleParticleToExactElementNoMap,PartInElemCheck
 USE MOD_Particle_Intersection,       ONLY:ComputeBezierIntersection,ComputeBiLinearIntersectionSuperSampled2 &
-                                         ,ComputePlanarIntersectionBezier,PartInElemCheck
-USE MOD_Particle_Intersection,       ONLY:ComputePlanarIntersectionBezierRobust,ComputeBiLinearIntersectionRobust
+                                         ,ComputePlanarIntersectionBezier
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarRectInterSection,ComputeBiLinearIntersectionRobust
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarNonrectIntersection
+USE MOD_Mesh_Vars,                   ONLY:OffSetElem
+USE MOD_Eval_xyz,                    ONLY:eval_xyz_elemcheck
 #ifdef MPI
 USE MOD_Particle_MPI_Vars,           ONLY:PartHaloElemToProc
 USE MOD_LoadBalance_Vars,            ONLY:ElemTime
-USE MOD_Mesh_Vars,                   ONLY:OffSetElem
-USE MOD_Eval_xyz,                    ONLY:eval_xyz_elemcheck
 USE MOD_MPI_Vars,                    ONLY:offsetElemMPI
 #endif /*MPI*/
 ! IMPLICIT VARIABLE HANDLING
@@ -71,12 +67,14 @@ LOGICAL,INTENT(IN),OPTIONAL   :: doParticle_In(1:PDM%ParticleVecLength)
 LOGICAL                       :: doParticle(1:PDM%ParticleVecLength)
 INTEGER                       :: iPart,ElemID,flip,OldElemID
 INTEGER                       :: ilocSide,SideID, locSideList(1:6), hitlocSide,nInterSections,nLoc
-LOGICAL                       :: PartisDone,dolocSide(1:6),isHit,markTol
+LOGICAL                       :: PartisDone,dolocSide(1:6),isHit,markTol,Reflected,SwitchedElement
+INTEGER                       :: Collision
 REAL                          :: localpha(1:6),xi(1:6),eta(1:6),refpos(1:3)
 !INTEGER                       :: lastlocSide
 REAL                          :: PartTrajectory(1:3),lengthPartTrajectory,xNodes(1:3,1:4)
 #ifdef MPI
-REAL                          :: tLBStart,tLBEnd, inElem
+REAL                          :: tLBStart,tLBEnd
+INTEGER                       :: inElem
 #endif /*MPI*/
 !===================================================================================================================================
 
@@ -104,15 +102,23 @@ DO iPart=1,PDM%ParticleVecLength
       PartisDone=.TRUE.
       CYCLE
     END IF
-    PartTrajectory=PartTrajectory/lengthPartTrajectory!+epsilontol
-    !PartTrajectory=PartTrajectory/(lengthPartTrajectory+epsilontol)
-    lengthPartTrajectory=lengthPartTrajectory!+epsilontol
+    PartTrajectory=PartTrajectory/lengthPartTrajectory
+#ifdef CODE_ANALYZE
+    CALL PartInElemCheck(LastPartPos(iPart,1:3),iPart,ElemID,isHit)
+    IF(.NOT.isHit)THEN 
+     IPWRITE(UNIT_stdOut,*) ' LastPartPos not inside of element, ElemID=',ElemID
+     CALL abort(&
+     __STAMP__ &
+     ,'iPart=. ',iPart)
+    END IF
+#endif /*CODE_ANALYZE*/
+    !lengthPartTrajectory=lengthPartTrajectory
     ! track particle vector until the final particle position is achieved
     dolocSide=.TRUE.
     DO WHILE (.NOT.PartisDone)
       locAlpha=-1.
       nInterSections=0
-      markTol=.FALSE.
+      markTol =.FALSE.
       DO ilocSide=1,6
         locSideList(ilocSide)=ilocSide
         IF(.NOT.dolocSide(ilocSide)) CYCLE
@@ -121,47 +127,24 @@ DO iPart=1,PDM%ParticleVecLength
         flip  = PartElemToSide(E2S_FLIP,ilocSide,ElemID)
         SELECT CASE(SideType(SideID))
         CASE(PLANAR_RECT)
-          CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+          CALL ComputePlanarRectInterSection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                                        ,xi (ilocSide)      &
+                                                                                        ,eta(ilocSide)   ,iPart,flip,SideID)
+        CASE(PLANAR_NONRECT)
+          CALL ComputePlanarNonrectIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                                         ,xi (ilocSide)      &
                                                                                         ,eta(ilocSide)   ,iPart,flip,SideID)
-
-!          CALL ComputePlanarIntersectionBezier(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                                        ,xi (ilocSide)      &
-!                                                                                        ,eta(ilocSide)   ,iPart,flip,SideID)
-!                                                                              !,doTest=.TRUE.)
-!                                                                                  !,eta(ilocSide)   ,iPart,ilocSide,SideID,ElemID)
-
         CASE(BILINEAR)
           xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,SideID)
           xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,SideID)
           xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,SideID)
           xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,SideID)
-          !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,xNodes &
-          !                                                    ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-          !                                                                                  ,xi (ilocSide)      &
-          !                                                                                  ,eta(ilocSide)      &
-          !                                                                                  ,iPart,flip,SideID)
           CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
                                                 ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                                             ,xi (ilocSide)      &
                                                                                             ,eta(ilocSide)      &
                                                                                             ,iPart,flip,SideID)
-
-          !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,[BezierControlPoints3D(1:3,0   ,0   ,SideID)  &
-          !                                                    ,BezierControlPoints3D(1:3,NGeo,0   ,SideID)  &
-          !                                                    ,BezierControlPoints3D(1:3,NGeo,NGeo,SideID)  &
-          !                                                    ,BezierControlPoints3D(1:3,0   ,NGeo,SideID)] &
-          !                                                    ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-          !                                                                                  ,xi (ilocSide)      &
-          !                                                                                  ,eta(ilocSide)      &
-          !                                                                                  ,iPart,flip,SideID)
-!                                                                                            !ilocSide,iPart,SideID)
-!          CALL ComputeBezierIntersection(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                            ,xi (ilocSide)      &
-!                                                                            ,eta(ilocSide)      ,iPart,SideID)
-!
-
-        CASE(CURVED,PLANAR_NONRECT)
+        CASE(CURVED,PLANAR_CURVED)
           CALL ComputeBezierIntersection(ishit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                                   ,xi (ilocSide)      &
                                                                                   ,eta(ilocSide)      ,iPart,SideID)
@@ -172,8 +155,8 @@ DO iPart=1,PDM%ParticleVecLength
         END SELECT
         IF(isHit) THEN
           nInterSections=nInterSections+1
-          IF((ABS(xi(ilocSide)).GE.1.0).OR.(ABS(eta(ilocSide)).GE.1.0)) markTol=.TRUE.
-          IF(ALMOSTZERO(locAlpha(ilocSide))) markTol=.TRUE.
+          IF((ABS(xi(ilocSide)).GE.0.99).OR.(ABS(eta(ilocSide)).GE.0.99)) markTol=.TRUE.
+          !IF(ALMOSTZERO(locAlpha(ilocSide))) markTol=.TRUE.
           !IF((ABS(xi(ilocSide)).GE.0.99).OR.(ABS(eta(ilocSide)).GE.0.99)) markTol=.TRUE.
           !IF(locAlpha(ilocSide)/lengthPartTrajectory.GE.0.99) markTol=.TRUE.
         END IF
@@ -185,86 +168,128 @@ DO iPart=1,PDM%ParticleVecLength
         PartisDone=.TRUE.
       CASE(1) ! one intersection
         ! get intersection side
+        SwitchedElement=.FALSE.
         DO ilocSide=1,6
           IF(locAlpha(ilocSide).GT.-1.0) THEN
             hitlocSide=ilocSide
-            EXIT
-          END IF
-        END DO ! ilocSide
-        SideID=PartElemToSide(E2S_SIDE_ID,hitlocSide,ElemID)
-        OldElemID=ElemID
-        CALL SelectInterSectionType(PartIsDone,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
-                                         ,xi(hitlocSide),eta(hitlocSide),localpha(ilocSide),iPart,SideID,ElemID)
-        IF(ElemID.NE.OldElemID)THEN
+            SideID=PartElemToSide(E2S_SIDE_ID,hitlocSide,ElemID)
+            OldElemID=ElemID
+            CALL SelectInterSectionType(PartIsDone,reflected,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
+                                             ,xi(hitlocSide),eta(hitlocSide),localpha(ilocSide),iPart,SideID,ElemID)
+            IF(ElemID.NE.OldElemID)THEN
+              ! particle moves in new element, do not check yet, because particle may encounter a boundary condition 
+              ! remark: maybe a storage value has to be set to drow?
+              markTol=.FALSE.
+              SwitchedElement=.TRUE.
 #ifdef MPI
-          IF(OldElemID.LE.PP_nElems)THEN
-            tLBEnd = LOCALTIME() ! LB Time End
-            ElemTime(OldELemID)=ElemTime(OldElemID)+tLBEnd-tLBStart
-            tLBStart = LOCALTIME() ! LB Time Start
-          END IF
+              IF(OldElemID.LE.PP_nElems)THEN
+                tLBEnd = LOCALTIME() ! LB Time End
+                ElemTime(OldELemID)=ElemTime(OldElemID)+tLBEnd-tLBStart
+                tLBStart = LOCALTIME() ! LB Time Start
+              END IF
 #endif /*MPI*/
-        END IF
-      CASE DEFAULT ! two or more hits
-        ! take last possible intersection, furthest
-        !CALL BubbleSortID(locAlpha,locSideList,6)
-        CALL InsertionSort(locAlpha,locSideList,6)
-!        IF((ipart.eq.40).AND.(iter.GE.68)) THEN
-!        END IF
-        nloc=0
-        DO ilocSide=6,1,-1
-          IF(locAlpha(ilocSide).GT.-1.0)THEN
-            !nloc=nloc+1
-            hitlocSide=locSideList(ilocSide)
-            EXIT
-            !IF(nloc.EQ.nInterSections) EXIT
+              EXIT
+            END IF
+            IF(Reflected) EXIT
           END IF
         END DO ! ilocSide
-        SideID=PartElemToSide(E2S_SIDE_ID,hitlocSide,ElemID)
-        OldElemID=ElemID
-        CALL SelectInterSectionType(PartIsDone,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
-                                         ,xi(hitlocSide),eta(hitlocSide),localpha(ilocSide),iPart,SideID,ElemID)
-        IF(ElemID.NE.OldElemID)THEN
-#ifdef MPI
-          tLBEnd = LOCALTIME() ! LB Time End
-          ElemTime(OldELemID)=ElemTime(OldElemID)+tLBEnd-tLBStart
-          tLBStart = LOCALTIME() ! LB Time Start
-#endif /*MPI*/
+        IF((.NOT.Reflected).AND.(.NOT.SwitchedElement)) THEN
+          PartIsDone=.TRUE.
+          EXIT 
         END IF
-        markTol=.TRUE.
+      CASE DEFAULT ! two or more hits
+        ! more careful witEh bc elems
+!        IF(isBCElem(ElemID))THEN
+!          CALL InsertionSort(locAlpha,locSideList,6)
+!          DO ilocSide=1,6
+!            SideID=PartElemToSide(E2S_SIDE_ID,ilocSide,ElemID)
+!            IF(BC(SideID).NE.0)THEN
+!              IF(locAlpha(ilocSide).GT.-1.0)THEN
+!                ! perform boundary interaction
+!                CALL SelectInterSectionType(PartIsDone,doLocSide,ilocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
+!                                                 ,xi(ilocSide),eta(ilocSide),localpha(ilocSide),iPart,SideID,ElemID)
+!                EXIT
+!              END IF
+!            END IF
+!          END DO
+!          markTol=.TRUE.
+!        ELSE
+          ! take last possible intersection, furthest
+          CALL InsertionSort(locAlpha,locSideList,6)
+          nloc=0
+          SwitchedElement=.FALSE.
+          DO ilocSide=1,6
+            IF(locAlpha(ilocSide).GT.-1.0)THEN
+              !nloc=nloc+1
+              hitlocSide=locSideList(ilocSide)
+
+              SideID=PartElemToSide(E2S_SIDE_ID,hitlocSide,ElemID)
+              OldElemID=ElemID
+              CALL SelectInterSectionType(PartIsDone,reflected,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
+                                               ,xi(hitlocSide),eta(hitlocSide),localpha(ilocSide),iPart,SideID,ElemID)
+              IF(ElemID.NE.OldElemID)THEN
+                markTol=.FALSE.
+                SwitchedElement=.TRUE.
+#ifdef MPI    
+                tLBEnd = LOCALTIME() ! LB Time End
+                ElemTime(OldELemID)=ElemTime(OldElemID)+tLBEnd-tLBStart
+                tLBStart = LOCALTIME() ! LB Time Start
+#endif /*MPI*/
+                EXIT
+              END IF
+              IF(Reflected) EXIT
+            END IF
+          END DO ! ilocSide
+          IF((.NOT.Reflected).AND.(.NOT.SwitchedElement)) THEN
+            PartIsDone=.TRUE.
+            EXIT 
+          END IF
+         ! particle moves close to an edge or corner. this is a critical movement because of possible tolerance issues
+!        END IF
       END SELECT
-      IF(markTol)THEN
-        CALL PartInElemCheck(iPart,ElemID,isHit)
-        !print*,'partid',ipart,'in elem',isHit
-        !print*,'old elem',ElemID
-        !print*,'ipart,loc',ipart,localpha
-        PEM%Element(iPart)=ElemID
-        IF(.NOT.isHit) CALL SingleParticleToExactElementNoMap(iPart,doHALO=.TRUE.)!debug=.TRUE.)
-!        print*,'new elem',PEM%Element(ipart)
-        PartIsDone=.TRUE.
-        IF(.NOT.PDM%ParticleInside(iPart))THEN
-          IPWRITE(UNIT_stdOut,*) ' Tolerance Issue during tracing! '
-          IPWRITE(UNIT_stdOut,*) ' Lost particle with id', ipart
-          IPWRITE(UNIT_stdOut,*) ' LastPartPos: ',LastPartPos(ipart,1:3)
-          IPWRITE(UNIT_stdOut,*) ' PartState: ',PartState(ipart,1:3)
-          IPWRITE(UNIT_stdOut,*) ' Compuing PartPosRef of ... '
-          CALL Eval_xyz_ElemCheck(LastPartPos(iPart,1:3),refpos(1:3),PEM%lastElement(ipart))
-          IPWRITE(UNIT_stdOut,*) ' LastPartRefPos: ',refpos
-          CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),refpos(1:3),PEM%lastElement(ipart))
-          IPWRITE(UNIT_stdOut,*) '     PartRefPos: ',refpos
+    END DO ! PartisDone=.FALSE.
+    IF(markTol)THEN
+      IF(.NOT.PDM%ParticleInside(iPart))THEN
+        CYCLE !particle is outside cell
+      END IF
+      CALL PartInElemCheck(PartState(iPart,1:3),iPart,ElemID,isHit)
+      PEM%Element(iPart)=ElemID
+      IF(.NOT.isHit) CALL SingleParticleToExactElementNoMap(iPart,doHALO=.TRUE.)!debug=.TRUE.)
+      PartIsDone=.TRUE.
+      IF(.NOT.PDM%ParticleInside(iPart))THEN
+        IPWRITE(UNIT_stdOut,*) ' Tolerance Issue during tracing! '
+        IPWRITE(UNIT_stdOut,*) ' Lost particle with id', ipart
+        IPWRITE(UNIT_stdOut,*) ' LastPartPos: ',LastPartPos(ipart,1:3)
+        IPWRITE(UNIT_stdOut,*) ' PartState: ',PartState(ipart,1:3)
+        IPWRITE(UNIT_stdOut,*) ' Compuing PartPosRef of ... '
+        CALL Eval_xyz_ElemCheck(LastPartPos(iPart,1:3),refpos(1:3),PEM%lastElement(ipart))
+        IPWRITE(UNIT_stdOut,*) ' LastPartRefPos: ',refpos
+        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),refpos(1:3),PEM%lastElement(ipart))
+        IPWRITE(UNIT_stdOut,*) '     PartRefPos: ',refpos
 #ifdef MPI
-          InElem=PEM%Element(iPart)
-          IF(InElem.LE.PP_nElems)THEN
-            IPWRITE(UNIT_stdOut,*) ' ElemID       ', InElem+offSetElem
-          ELSE
-            IPWRITE(UNIT_stdOut,*) ' ElemID       ', offSetElemMPI(PartHaloElemToProc(NATIVE_PROC_ID,InElem)) &
-                                                   + PartHaloElemToProc(NATIVE_ELEM_ID,InElem)
-          END IF
+        InElem=PEM%Element(iPart)
+        IF(InElem.LE.PP_nElems)THEN
+          IPWRITE(UNIT_stdOut,*) ' ElemID       ', InElem+offSetElem
+        ELSE
+          IPWRITE(UNIT_stdOut,*) ' ElemID       ', offSetElemMPI(PartHaloElemToProc(NATIVE_PROC_ID,InElem)) &
+                                                 + PartHaloElemToProc(NATIVE_ELEM_ID,InElem)
+        END IF
 #else
-          IPWRITE(UNIT_stdOut,*) ' ElemID         ', ElemID+offSetElem
+        IPWRITE(UNIT_stdOut,*) ' ElemID         ', ElemID+offSetElem
 #endif
+#ifdef MPI
+        InElem=PEM%LastElement(iPart)
+        IF(InElem.LE.PP_nElems)THEN
+          IPWRITE(UNIT_stdOut,*) ' Last-ElemID  ', InElem+offSetElem
+        ELSE
+          IPWRITE(UNIT_stdOut,*) ' Last-ElemID  ', offSetElemMPI(PartHaloElemToProc(NATIVE_PROC_ID,InElem)) &
+                                                 + PartHaloElemToProc(NATIVE_ELEM_ID,InElem)
         END IF
-      END IF ! markTol
-    END DO ! PartisDone=.FALSE.
+#else
+        IPWRITE(UNIT_stdOut,*) ' Last-ElemID    ', ElemID+offSetElem
+#endif
+      END IF
+    END IF ! markTol
 #ifdef MPI
     tLBEnd = LOCALTIME() ! LB Time End
     IF(PEM%Element(iPart).LE.PP_nElems) ElemTime(PEM%Element(iPart))=ElemTime(PEM%Element(iPart))+tLBEnd-tLBStart
@@ -281,620 +306,12 @@ DO iPart=1,PDM%ParticleVecLength
   END IF ! Part inside
 END DO ! iPart
 
-END SUBROUTINE ParticleTrackingCurved
+END SUBROUTINE ParticleTracing
 
 
-SUBROUTINE ParticleBCTrackingfast(ElemID,firstSide,LastSide,nlocSides,PartId,PartisDone,PartisMoved)
+SUBROUTINE ParticleRefTracking(doParticle_In)
 !===================================================================================================================================
-! read required parameters
-!===================================================================================================================================
-! MODULES
-USE MOD_Preproc
-USE MOD_Globals
-USE MOD_Mesh_Vars,                   ONLY:NGeo!,NormVec
-USE MOD_Particle_Vars,               ONLY:PEM,PDM
-USE MOD_Particle_Vars,               ONLY:PartState,LastPartPos
-USE MOD_Particle_Surfaces_Vars,      ONLY:SideType
-USE MOD_Particle_Surfaces_Vars,      ONLY:BezierControlPoints3D
-USE MOD_Particle_Mesh_Vars,          ONLY:PartBCSideList
-USE MOD_Particle_Boundary_Condition, ONLY:GetBoundaryInteractionRef
-USE MOD_Particle_Mesh_Vars,          ONLY:BCElem,GEO
-USE MOD_Utils,                       ONLY:BubbleSortID,InsertionSort
-USE MOD_Particle_Intersection,       ONLY:ComputeBezierIntersection,ComputeBiLinearIntersectionSuperSampled2 &
-                                         ,ComputePlanarIntersectionBezier,ComputePlanarIntersectionBezierRobust2
-USE MOD_Particle_Intersection,       ONLY:ComputePlanarIntersectionBezierRobust,ComputeBiLinearIntersectionRobust
-! IMPLICIT VARIABLE HANDLING
-IMPLICIT NONE
-! INPUT VARIABLES
-!-----------------------------------------------------------------------------------------------------------------------------------
-! INPUT/OUTPUT VARIABLES
-INTEGER,INTENT(IN)            :: PartID,ElemID,firstSide,LastSide,nlocSides
-LOGICAL,INTENT(INOUT)         :: PartisDone
-!-----------------------------------------------------------------------------------------------------------------------------------
-! OUTPUT VARIABLES!
-LOGICAL,INTENT(INOUT)         :: PartisMoved
-!-----------------------------------------------------------------------------------------------------------------------------------
-! LOCAL VARIABLES
-INTEGER                       :: ilocSide,SideID, locSideList(firstSide:lastSide), hitlocSide
-LOGICAL                       :: ishit
-REAL                          :: localpha(firstSide:lastSide),xi(firstSide:lastSide),eta(firstSide:lastSide)
-INTEGER                       :: nInter,flip,BCSideID
-REAL                          :: PartTrajectory(1:3),lengthPartTrajectory,xNodes(1:3,1:4)
-LOGICAL                       :: DoTracing,PeriMoved
-!===================================================================================================================================
-
-
-PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
-lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
-                         +PartTrajectory(2)*PartTrajectory(2) &
-                         +PartTrajectory(3)*PartTrajectory(3) )
-
-IF(ALMOSTZERO(lengthPartTrajectory))THEN
-  PEM%Element(PartID)=ElemID
-  PartIsDone=.TRUE.
-  RETURN
-END IF
-
-PartTrajectory=PartTrajectory/lengthPartTrajectory
-
-PartisMoved=.FALSE.
-DoTracing=.TRUE.
-DO WHILE(DoTracing)
-  IF(GEO%nPeriodicVectors.GT.0)THEN
-    ! call here function for mapping of partpos and lastpartpos
-    CALL PeriodicMovement(PartID,PeriMoved)
-  ELSE
-    PeriMoved=.FALSE.
-  END IF
-  locAlpha=-1.0
-  nInter=0
-  !nlocSides=lastSide-firstSide+1
-  DO iLocSide=firstSide,LastSide
-    ! track particle vector until the final particle position is achieved
-    SideID=BCElem(ElemID)%BCSideID(ilocSide)
-    BCSideID=PartBCSideList(SideID)
-    locSideList(ilocSide)=ilocSide
-    ! get correct flip
-    flip  = 0 
-    SELECT CASE(SideType(BCSideID))
-    CASE(PLANAR_RECT)
-
-      !CALL ComputePlanarIntersectionBezier(ishit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-      !                                                                              ,xi (ilocSide)            &
-      !                                                                              ,eta(ilocSide)   ,PartID,flip,BCSideID)
-
-      !CALL ComputePlanarIntersectionBezier(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-      CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                                    ,xi (ilocSide)            &
-                                                                                    ,eta(ilocSide)   ,PartID,flip,BCSideID)
-    CASE(BILINEAR)
-      xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,BCSideID)
-      xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,BCSideID)
-      xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,BCSideID)
-      xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,BCSideID)
-      CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
-                                                   ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                                       ,xi (ilocSide)      &
-                                                                                       ,eta(ilocSide)      &
-                                                                                       ,PartID,flip,BCSideID)
-    CASE(CURVED,PLANAR_NONRECT)
-      CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                              ,xi (ilocSide)      &
-                                                                              ,eta(ilocSide)      ,PartID,BCSideID)
-    END SELECT
-    IF(locAlpha(ilocSide).GT.-1.0)THEN
-      nInter=nInter+1
-    END IF
-  END DO ! ilocSide
-  
-  IF(nInter.EQ.0)THEN
-    IF(.NOT.PeriMoved) DoTracing=.FALSE. 
-  ELSE
-    ! take first possible intersection
-    !CALL BubbleSortID(locAlpha,locSideList,6)
-    PartIsMoved=.TRUE.
-    CALL InsertionSort(locAlpha,locSideList,nlocSides)
-    ilocSide=LastSide-nInter+1
-    hitlocSide=locSideList(ilocSide)
-    SideID=BCElem(ElemID)%BCSideID(hitlocSide)
-    BCSideID=PartBCSideList(SideID)
-    CALL GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                      ,xi(hitlocSide)     &
-                                                                      ,eta(hitlocSide)    &
-                                                                      ,PartId,SideID)
-    IF(.NOT.PDM%ParticleInside(PartID)) THEN
-      PartisDone = .TRUE.
-       RETURN
-     END IF
-  END IF ! nInter>0
-END DO
-
-END SUBROUTINE ParticleBCTrackingfast
-
-
-SUBROUTINE ParticleBCTracking(ElemID,firstSide,LastSide,nlocSides,PartId,PartisDone)
-!===================================================================================================================================
-! read required parameters
-!===================================================================================================================================
-! MODULES
-USE MOD_Preproc
-USE MOD_Globals
-USE MOD_Mesh_Vars,                   ONLY:NGeo!,NormVec
-USE MOD_Particle_Vars,               ONLY:PEM,PDM
-USE MOD_Particle_Vars,               ONLY:PartState,LastPartPos
-USE MOD_Particle_Surfaces_Vars,      ONLY:SideType
-USE MOD_Particle_Surfaces_Vars,      ONLY:BezierControlPoints3D
-USE MOD_Particle_Mesh_Vars,          ONLY:PartBCSideList
-USE MOD_Particle_Boundary_Condition, ONLY:GetBoundaryInteractionRef
-USE MOD_Particle_Mesh_Vars,          ONLY:BCElem
-USE MOD_Utils,                       ONLY:BubbleSortID,InsertionSort
-USE MOD_Particle_Intersection,       ONLY:ComputeBezierIntersection,ComputeBiLinearIntersectionSuperSampled2 &
-                                         ,ComputePlanarIntersectionBezier,ComputePlanarIntersectionBezierRobust2
-USE MOD_Particle_Intersection,       ONLY:ComputePlanarIntersectionBezierRobust,ComputeBiLinearIntersectionRobust
-! IMPLICIT VARIABLE HANDLING
-IMPLICIT NONE
-! INPUT VARIABLES
-!-----------------------------------------------------------------------------------------------------------------------------------
-! INPUT/OUTPUT VARIABLES
-INTEGER,INTENT(IN)            :: PartID,ElemID,firstSide,LastSide,nlocSides
-LOGICAL,INTENT(INOUT)         :: PartisDone
-!-----------------------------------------------------------------------------------------------------------------------------------
-! OUTPUT VARIABLES
-!-----------------------------------------------------------------------------------------------------------------------------------
-! LOCAL VARIABLES
-INTEGER                       :: ilocSide,SideID, locSideList(firstSide:lastSide), hitlocSide
-LOGICAL                       :: dolocSide(firstSide:lastSide),ishit
-REAL                          :: localpha(firstSide:lastSide),xi(firstSide:lastSide),eta(firstSide:lastSide)
-INTEGER                       :: nInter,flip,BCSideID
-REAL                          :: PartTrajectory(1:3),lengthPartTrajectory,xNodes(1:3,1:4)
-!===================================================================================================================================
-
-IF(LastSide.EQ.0) RETURN
-
-PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
-lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
-                         +PartTrajectory(2)*PartTrajectory(2) &
-                         +PartTrajectory(3)*PartTrajectory(3) )
-
-IF(ALMOSTZERO(lengthPartTrajectory))THEN
-  PEM%Element(PartID)=ElemID
-  PartIsDone=.TRUE.
-  RETURN
-END IF
-
-PartTrajectory=PartTrajectory/lengthPartTrajectory
-!lengthPartTrajectory=lengthPartTrajectory!+epsilontol
-
-locAlpha=-1.0
-nInter=0
-dolocSide=.TRUE.
-!nlocSides=lastSide-firstSide+1
-DO iLocSide=firstSide,LastSide
-  ! track particle vector until the final particle position is achieved
-  SideID=BCElem(ElemID)%BCSideID(ilocSide)
-  BCSideID=PartBCSideList(SideID)
-  locSideList(ilocSide)=ilocSide
-  ! get correct flip
-  flip  = 0 
-  SELECT CASE(SideType(BCSideID))
-  CASE(PLANAR_RECT)
-    !CALL ComputePlanarIntersectionBezier(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-    CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                                  ,xi (ilocSide)            &
-                                                                                  ,eta(ilocSide)   ,PartID,flip,BCSideID)
-
-!    CALL ComputePlanarIntersectionBezierRobust2(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                                  ,xi (ilocSide)      &
-!                                                                                  ,eta(ilocSide)   ,PartID,flip,BCSideID)
-!
-!                                                                            !,eta(ilocSide)   ,PartID,ilocSide,SideID,ElemID)
-  CASE(BILINEAR)
-    xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,BCSideID)
-    xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,BCSideID)
-    xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,BCSideID)
-    xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,BCSideID)
-    !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,xNodes &
-    CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
-                                                 ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                                     ,xi (ilocSide)      &
-                                                                                     ,eta(ilocSide)      &
-                                                                                     ,PartID,flip,BCSideID)
-
-    !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,[BezierControlPoints3D(1:3,0   ,0   ,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,NGeo,0   ,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,NGeo,NGeo,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,0   ,NGeo,SideID)] &
-    !                                                    ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-    !                                                                                        ,xi (ilocSide)      &
-    !                                                                                        ,eta(ilocSide)  ,PartID,flip,SideID)
-!    CALL ComputeBezierIntersection(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                      ,xi (ilocSide)      &
-!                                                                      ,eta(ilocSide)      ,PartID,SideID)
-
-  CASE(CURVED,PLANAR_NONRECT)
-    CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                            ,xi (ilocSide)      &
-                                                                            ,eta(ilocSide)      ,PartID,BCSideID)
-  END SELECT
-  IF(locAlpha(ilocSide).GT.-1.0)THEN
-    nInter=nInter+1
-  END IF
-END DO ! ilocSide
-
-IF(nInter.EQ.0) THEN
-  RETURN
-ELSE
-  ! take first possible intersection
-  !CALL BubbleSortID(locAlpha,locSideList,6)
-  CALL InsertionSort(locAlpha,locSideList,nlocSides)
-  ilocSide=LastSide-nInter+1
-  hitlocSide=locSideList(ilocSide)
-  SideID=BCElem(ElemID)%BCSideID(hitlocSide)
-  BCSideID=PartBCSideList(SideID)
-  CALL GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-                                                                    ,xi(hitlocSide)     &
-                                                                    ,eta(hitlocSide)    &
-                                                                    ,PartId,SideID)
-  IF(.NOT.PDM%ParticleInside(PartID)) PartisDone = .TRUE.
-  RETURN
-  !DO ilocSide=firstSide,LastSide
-  !DO ilocSide=LastSide
-  !  IF(locAlpha(ilocSide).GT.-1.0)THEN
-  !    hitlocSide=locSideList(ilocSide)
-  !    !SideID=PartElemToSide(E2S_SIDE_ID,hitlocSide,ElemID)
-  !    SideID=BCElem(ElemID)%BCSideID(hitlocSide)
-  !    BCSideID=PartBCSideList(SideID)
-  !    CALL GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-  !                                                                      ,xi(hitlocSide)     &
-  !                                                                      ,eta(hitlocSide)    &
-  !                                                                      ,PartId,SideID)
-  !    IF(.NOT.PDM%ParticleInside(PartID)) PartisDone = .TRUE.
-  !    RETURN
-  !  END IF ! locAlpha>-1.0
-  !END DO ! ilocSide
-END IF ! nInter>0
-
-END SUBROUTINE ParticleBCTracking
-
-
-SUBROUTINE ParticleRefTrackingSlow(doParticle_In)
-!===================================================================================================================================
-! Compute the intersection with a Bezier surface
-! particle path = LastPartPos+lengthPartTrajectory*PartTrajectory
-!===================================================================================================================================
-! MODULES
-USE MOD_Preproc
-USE MOD_Globals!,                 ONLY:Cross,abort
-USE MOD_Particle_Vars,           ONLY:PDM,PEM,PartState,PartPosRef,LastpartPOs
-USE MOD_Mesh_Vars,               ONLY:OffSetElem
-USE MOD_Eval_xyz,                ONLY:eval_xyz_elemcheck
-USE MOD_Particle_Tracking_Vars,  ONLY:nTracks
-USE MOD_Particle_Mesh_Vars,      ONLY:Geo,IsBCElem,BCElem,epsInCell,epsOneCell
-USE MOD_Utils,                   ONLY:BubbleSortID,InsertionSort
-USE MOD_Particle_Mesh_Vars,      ONLY:ElemBaryNGeo,ElemRadius2NGeo
-USE MOD_Particle_Mesh,           ONLY:SingleParticleToExactElement
-USE MOD_Eval_xyz,                ONLY:Eval_XYZ_Poly
-#ifdef MPI
-USE MOD_MPI_Vars,                ONLY:offsetElemMPI
-USE MOD_Particle_MPI_Vars,       ONLY:PartHaloElemToProc
-USE MOD_LoadBalance_Vars,        ONLY:ElemTime,nTracksPerElem,tTracking
-#endif
-! IMPLICIT VARIABLE HANDLING
-IMPLICIT NONE
-!-----------------------------------------------------------------------------------------------------------------------------------
-! INPUT VARIABLES
-LOGICAL,INTENT(IN),OPTIONAL      :: doParticle_In(1:PDM%ParticleVecLength)
-!-----------------------------------------------------------------------------------------------------------------------------------
-! OUTPUT VARIABLES
-!-----------------------------------------------------------------------------------------------------------------------------------
-! LOCAL VARIABLES
-LOGICAL                          :: doParticle(1:PDM%ParticleVecLength)
-INTEGER                          :: iPart, ElemID,oldElemID,iElem, newElemID
-INTEGER                          :: CellX,CellY,CellZ,iBGMElem,nBGMElems
-REAL,ALLOCATABLE                 :: Distance(:)
-REAL                             :: oldXi(3),newXi(3), LastPos(3),epsLowOne
-INTEGER,ALLOCATABLE              :: ListDistance(:)
-!REAL                             :: epsOne
-#ifdef MPI
-INTEGER                          :: InElem
-#endif
-INTEGER                          :: TestElem
-LOGICAL                          :: ParticleFound(1:PDM%ParticleVecLength),PartisDone
-!LOGICAL                          :: HitBC(1:PDM%ParticleVecLength)
-! load balance
-#ifdef MPI
-REAL                               :: tLBStart,tLBEnd
-#endif /*MPI*/
-!===================================================================================================================================
-
-IF(PRESENT(DoParticle_IN))THEN
-  DoParticle=PDM%ParticleInside(1:PDM%ParticleVecLength).AND.DoParticle_In
-ELSE
-  DoParticle(1:PDM%ParticleVecLength)=PDM%ParticleInside(1:PDM%ParticleVecLength)
-END IF
-
-ParticleFound=.FALSE.
-!HitBC=.FALSE.
-epsLowOne=1.0-2.0*epsInCell
-! first step, reuse Elem cache, therefore, check if particle are still in element, if not, search later
-DO iElem=1,PP_nElems ! loop only over internal elems, if particle is already in HALO, it shall not be found here
-#ifdef MPI
-  tLBStart = LOCALTIME() ! LB Time Start
-#endif /*MPI*/
-  DO iPart=1,PDM%ParticleVecLength
-    IF(DoParticle(iPart))THEN
-      ElemID = PEM%lastElement(iPart)
-      IF(ElemID.NE.iElem) CYCLE
-      nTracks=nTracks+1
-      ! sanity check
-      !IF(PartState(iPart,3).GE.0.089)THEN
-      !  IPWRITE(UNIT_stdOut,*) ' Part out of area, z,ipart', PartState(iPart,3),iPart
-      !END IF
-      IF(IsBCElem(ElemID))THEN
-#if defined(LSERK)
-        CALL ParticleBCTracking(ElemID,1,BCElem(ElemID)%lastSide,BCElem(ElemID)%lastSide,iPart,ParticleFound(iPart))
-        IF(ParticleFound(iPart)) CYCLE
-        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID)
-        IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.epsOneCell(ElemID)) THEN ! particle is inside 
-        !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.1.0) THEN ! particle is inside 
-          PEM%lastElement(iPart)=ElemID
-          ParticleFound(iPart)=.TRUE.
-          CYCLE
-        END IF
-#else
-        ! simple and stupid
-        LastPos=PartState(iPart,1:3)
-        IF(GEO%nPeriodicVectors.GT.0)THEN
-          ! call here function for mapping of partpos and lastpartpos
-          CALL PeriodicMovement(iPart)
-        END IF
-        CALL ParticleBCTracking(ElemID,1,BCElem(ElemID)%lastSide,BCElem(ElemID)%lastSide,iPart,ParticleFound(iPart))
-        IF(ParticleFound(iPart)) CYCLE
-        DO WHILE ( .NOT.ALMOSTEQUAL(LastPos(1),PartState(iPart,1)) &
-            .OR.   .NOT.ALMOSTEQUAL(LastPos(2),PartState(iPart,2)) &
-            .OR.   .NOT.ALMOSTEQUAL(LastPos(3),PartState(iPart,3)) )
-          LastPos=PartState(iPart,1:3)
-          IF(GEO%nPeriodicVectors.GT.0)THEN
-            ! call here function for mapping of partpos and lastpartpos
-            CALL PeriodicMovement(iPart)
-          END IF
-          ! unfortunately, here all sides
-          CALL ParticleBCTracking(ElemID,1,BCElem(ElemID)%lastSide &
-              ,BCElem(ElemID)%lastSide,iPart,ParticleFound(iPart))
-          IF(ParticleFound(iPart)) EXIT
-        END DO
-        IF(ParticleFound(iPart)) CYCLE
-        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID)
-        IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.epsOneCell(ElemID)) THEN ! particle is inside 
-        !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.1.0) THEN ! particle is inside 
-          ParticleFound(iPart)=.TRUE.
-          CYCLE
-        END IF
-
-#endif /*TIMEDISCS*/
-      ELSE ! no bc elem, therefore, no bc ineraction possible
-        IF(GEO%nPeriodicVectors.GT.0)THEN
-          ! call here function for mapping of partpos and lastpartpos
-          LastPos=PartState(iPart,1:3)
-          CALL PeriodicMovement(iPart)
-          IF(.NOT.IsBCElem(ElemID))THEN
-            DO WHILE ( .NOT.ALMOSTEQUAL(LastPos(1),PartState(iPart,1)) &
-                .OR.   .NOT.ALMOSTEQUAL(LastPos(2),PartState(iPart,2)) &
-                .OR.   .NOT.ALMOSTEQUAL(LastPos(3),PartState(iPart,3)) )
-              LastPos=PartState(iPart,1:3)
-              ! call here function for mapping of partpos and lastpartpos
-              CALL PeriodicMovement(iPart)
-            END DO
-          END IF
-        END IF
-#if (PP_TimeDiscMethod==1)||(PP_TimeDiscMethod==2)||(PP_TimeDiscMethod==6)||(PP_TimeDiscMethod>=501 && PP_TimeDiscMethod<=506)
-        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID,DoReUseMap=.TRUE.)
-#else
-        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID)
-#endif
-        IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.epsOneCell(ElemID)) THEN ! particle inside
-        !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.1.0) THEN ! particle inside
-          PEM%Element(iPart)  = ElemID
-          ParticleFound(iPart)=.TRUE.
-        !  IPWRITE(UNIT_stdOut,*) ' partposref to large!',iPart
-        END IF
-      END IF ! initial check
-    ELSE
-      ! caution: dummy, because particle is not inside and such a particle sould not be searched for in 
-      ! the next loop
-      ParticleFound(iPart)=.TRUE.
-    END IF
-  END DO ! iPart
-#ifdef MPI
-  tLBEnd = LOCALTIME() ! LB Time End
-  ElemTime(iElem)=ElemTime(iElem)+tLBEnd-tLBStart
-#endif /*MPI*/
-END DO ! iElem
-
-! now, locate not all found particle
-#ifdef MPI
-tLBStart = LOCALTIME() ! LB Time Start
-#endif /*MPI*/
-DO iPart=1,PDM%ParticleVecLength
-  IF(ParticleFound(iPart)) CYCLE
-  ! relocate particle
-  oldElemID = PEM%lastElement(iPart) ! this is not!  a possible elem
-  ! get background mesh cell of particle
-  CellX = CEILING((PartState(iPart,1)-GEO%xminglob)/GEO%FIBGMdeltas(1)) 
-  CellX = MAX(MIN(GEO%TFIBGMimax,CellX),GEO%TFIBGMimin)
-  CellY = CEILING((PartState(iPart,2)-GEO%yminglob)/GEO%FIBGMdeltas(2))
-  CellY = MAX(MIN(GEO%TFIBGMjmax,CellY),GEO%TFIBGMjmin)
-  CellZ = CEILING((PartState(iPart,3)-GEO%zminglob)/GEO%FIBGMdeltas(3))
-  CellZ = MAX(MIN(GEO%TFIBGMkmax,CellZ),GEO%TFIBGMkmin)
-        
-  ! check all cells associated with this beckground mesh cell
-  nBGMElems=GEO%TFIBGM(CellX,CellY,CellZ)%nElem
-  !SDEALLOCATE( Distance)
-  !SDEALLOCATE( ListDistance)
-  ALLOCATE( Distance(1:nBGMElems) &
-          , ListDistance(1:nBGMElems) )
- 
-  ! get closest element barycenter
-  Distance=0.
-  ListDistance=0
-  DO iBGMElem = 1, nBGMElems
-    ElemID = GEO%TFIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
-    ListDistance(iBGMElem)=ElemID
-    IF(ElemID.EQ.-1)CYCLE
-    IF(ElemID.EQ.OldElemID)THEN
-      Distance(iBGMElem)=-1.0
-    ELSE
-      Distance(iBGMElem)=    ((PartState(iPart,1)-ElemBaryNGeo(1,ElemID))*(PartState(iPart,1)-ElemBaryNGeo(1,ElemID)) &
-                             +(PartState(iPart,2)-ElemBaryNGeo(2,ElemID))*(PartState(iPart,2)-ElemBaryNGeo(2,ElemID)) &
-                             +(PartState(iPart,3)-ElemBaryNGeo(3,ElemID))*(PartState(iPart,3)-ElemBaryNGeo(3,ElemID)) )
-
-      IF(Distance(iBGMElem).GT.ElemRadius2NGeo(ElemID))THEN
-        Distance(iBGMElem)=-1.0
-      END IF
-    END IF
-  END DO ! nBGMElems
-
-  !CALL BubbleSortID(Distance,ListDistance,nBGMElems)
-  CALL InsertionSort(Distance,ListDistance,nBGMElems)
-
-  OldXi=PartPosRef(1:3,iPart)
-  newXi=HUGE(1.0)
-  newElemID=-1
-  ! loop through sorted list and start by closest element  
-  DO iBGMElem=1,nBGMElems
-    IF(ALMOSTEQUAL(Distance(iBGMELem),-1.0)) CYCLE
-    ElemID=ListDistance(iBGMElem)
-#ifdef MPI
-    IF(ElemID.LE.PP_nElems) nTracksPerElem(ElemID)=nTracksPerElem(ElemID)+1
-#endif /*MPI*/
-    CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID)
-    !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LE.BezierClipHit) THEN ! particle inside
-    IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LE.epsOneCell(ElemID)) THEN ! particle inside
-    !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.1.0) THEN ! particle inside
-      PEM%Element(iPart) = ElemID
-      ParticleFound(iPart)=.TRUE.
-      EXIT
-    END IF
-    IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LT.MAXVAL(ABS(newXi))) THEN
-      newXi=PartPosRef(1:3,iPart)
-      newElemID=ElemID
-    END IF
-  END DO ! iBGMElem
-
-  IF(.NOT.ParticleFound(iPart))THEN
-    ! use best xi
-    !IPWRITE(UNIT_stdOut,*) ' recover particle', iPart
-    IF(MAXVAL(ABS(oldXi)).LT.MAXVAL(ABS(newXi)))THEN
-      PartPosRef(1:3,iPart)=OldXi
-      PEM%Element(iPart)   =oldElemID
-      ElemID               =oldElemID
-    ELSE
-      PartPosRef(1:3,iPart)=NewXi
-      PEM%Element(iPart)   =NewElemID
-      oldElemID            =NewElemID
-      ElemID               =NewElemID
-    END IF
-  
-    !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).GT.1.05) THEN
-    IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).GT.1.0) THEN
-      PartIsDone=.FALSE.
-      TestElem=ElemID
-      IF(.NOT.IsBCElem(TestElem))THEN
-        ! ausgabe
-        IPWRITE(UNIT_stdOut,*) ' Tolerance Issue with internal element '
-        IPWRITE(UNIT_stdOut,*) ' xi          ', PartPosRef(1:3,iPart)
-        IPWRITE(UNIT_stdOut,*) ' epsOneCell  ', epsOneCell(ElemID)
-        IPWRITE(UNIT_stdOut,*) ' oldxi       ', oldXi
-        IPWRITE(UNIT_stdOut,*) ' newxi       ', newXi
-        IPWRITE(UNIT_stdOut,*) ' ParticlePos ', PartState(iPart,1:3)
-#ifdef MPI
-        InElem=PEM%Element(iPart)
-        IF(InElem.LE.PP_nElems)THEN
-          IPWRITE(UNIT_stdOut,*) ' ElemID       ', InElem+offSetElem
-        ELSE
-          IPWRITE(UNIT_stdOut,*) ' ElemID       ', offSetElemMPI(PartHaloElemToProc(NATIVE_PROC_ID,InElem)) &
-                                                 + PartHaloElemToProc(NATIVE_ELEM_ID,InElem)
-        END IF
-#else
-        IPWRITE(UNIT_stdOut,*) ' ElemID       ', PEM%Element(iPart)+offSetElem
-#endif
-        CALL abort(&
-        __STAMP__ &
-        ,'Particle Not inSide of Element, iPart',iPart)
-      ELSE ! BCElem
-        !CALL ComputeFaceIntersection(TestElem,1,BCElem(TestElem)%nInnerSides,BCElem(TestElem)%nInnerSides,iPart)
-        CALL ComputeFaceIntersection(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart)
-        LastPos=PartState(iPart,1:3)
-        CALL ParticleBCTracking(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart,PartIsDone)
-        ! check inner sides
-        DO WHILE ( .NOT.ALMOSTEQUAL(LastPos(1),PartState(iPart,1)) &
-            .OR.   .NOT.ALMOSTEQUAL(LastPos(2),PartState(iPart,2)) &
-            .OR.   .NOT.ALMOSTEQUAL(LastPos(3),PartState(iPart,3)) )
-          LastPos=PartState(iPart,1:3)
-          ! unfortunately, here all sides
-          CALL ParticleBCTracking(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart,PartIsDone)
-          IF(PartIsDone) EXIT
-          IF(GEO%nPeriodicVectors.GT.0)THEN
-            ! call here function for mapping of partpos and lastpartpos
-            CALL PeriodicMovement(iPart)
-          END IF
-        END DO ! While
-        IF(PartIsDone) THEN
-          DEALLOCATE( Distance)
-          DEALLOCATE( ListDistance)
-          CYCLE
-        END IF
-        CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),TestElem)
-        ! false, reallocate particle
-        !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).GT.1.0)THEN
-        IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).GT.epsOneCell(TestElem))THEN
-          IPWRITE(UNIT_stdOut,*) ' Tolerance Issue with BC element, relocating!! '
-          CALL SingleParticleToExactElement(iPart,doHalo=.TRUE.)                                                             
-          IF(.NOT.PDM%ParticleInside(iPart)) THEN
-            IPWRITE(UNIT_stdOut,*) ' Tolerance Issue with BC element '
-            IPWRITE(UNIT_stdOut,*) ' xi          ', partposref(1:3,ipart)
-            IPWRITE(UNIT_stdOut,*) ' epsonecell  ', epsonecell
-            IPWRITE(UNIT_stdOut,*) ' oldxi       ', oldxi
-            IPWRITE(UNIT_stdOut,*) ' newxi       ', newxi
-            IPWRITE(UNIT_stdOut,*) ' particlepos ', partstate(ipart,1:3)
-            IPWRITE(UNIT_stdOut,*) ' velocity    ', partstate(ipart,4:6)
-            IPWRITE(UNIT_stdOut,*) ' lastpartpos ', LastPartPos(ipart,1:3)
-#ifdef MPI
-            inelem=PEM%Element(ipart)
-            IF(inelem.LE.PP_nElems)THEN
-              IPWRITE(UNIT_stdout,*) ' elemid       ', inelem+offsetelem
-            ELSE
-              IPWRITE(UNIT_stdOut,*) ' elemid       ', offsetelemmpi(PartHaloElemToProc(NATIVE_PROC_ID,inelem)) &
-                                                       + PartHaloElemToProc(NATIVE_ELEM_ID,inelem)
-            END IF
-#else
-            IPWRITE(UNIt_stdOut,*) ' elemid       ', pem%element(ipart)+offsetelem
-#endif
-CALL abort(&
-__STAMP__ &
-,' Particle not inside of element, ipart',ipart)
-          END IF ! inside
-        END IF ! epsCell
-      END IF ! BCElem
-    END IF ! inner eps to large
-  END IF ! not found
-  ParticleFound(iPart)=.TRUE.
-  DEALLOCATE( Distance)
-  DEALLOCATE( ListDistance)
-
-END DO ! iPart
-#ifdef MPI
-tLBEnd = LOCALTIME() ! LB Time End
-tTracking = tTracking +tLBEnd-tLBStart
-#endif /*MPI*/
-
-END SUBROUTINE ParticleRefTrackingSlow
-
-
-SUBROUTINE ParticleRefTrackingFast(doParticle_In)
-!===================================================================================================================================
-! Compute the intersection with a Bezier surface
-! particle path = LastPartPos+lengthPartTrajectory*PartTrajectory
+! Reference Tracking for particle without treatment of each inner faces
 !===================================================================================================================================
 ! MODULES
 USE MOD_Preproc
@@ -906,7 +323,7 @@ USE MOD_Particle_Tracking_Vars,  ONLY:nTracks,Distance,ListDistance
 USE MOD_Particle_Mesh_Vars,      ONLY:Geo,IsBCElem,BCElem,epsOneCell
 USE MOD_Utils,                   ONLY:BubbleSortID,InsertionSort
 USE MOD_Particle_Mesh_Vars,      ONLY:ElemBaryNGeo,ElemRadius2NGeo
-USE MOD_Particle_Mesh,           ONLY:SingleParticleToExactElement
+USE MOD_Particle_Mesh,           ONLY:SingleParticleToExactElement,PartInElemCheck
 USE MOD_Eval_xyz,                ONLY:Eval_XYZ_Poly
 #ifdef MPI
 USE MOD_MPI_Vars,                ONLY:offsetElemMPI
@@ -959,7 +376,7 @@ DO iPart=1,PDM%ParticleVecLength
     ! sanity check
     PartIsDone=.FALSE.
     IF(IsBCElem(ElemID))THEN
-      CALL ParticleBCTrackingfast(ElemID,1,BCElem(ElemID)%lastSide,BCElem(ElemID)%lastSide,iPart,PartIsDone,PartIsMoved)
+      CALL ParticleBCTracking(ElemID,1,BCElem(ElemID)%lastSide,BCElem(ElemID)%lastSide,iPart,PartIsDone,PartIsMoved)
       IF(PartIsDone) CYCLE
       IF(PartIsMoved)THEN
         CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),ElemID)
@@ -979,7 +396,7 @@ DO iPart=1,PDM%ParticleVecLength
 #endif /*MPI*/
         CYCLE
       END IF
-    ELSE ! no bc elem, therefore, no bc ineraction possible
+    ELSE ! no bc elem, therefore, no bc interaction possible
       IF(GEO%nPeriodicVectors.GT.0)THEN
         ! call here function for mapping of partpos and lastpartpos
         LastPos=PartState(iPart,1:3)
@@ -1126,10 +543,10 @@ CALL abort(&
 __STAMP__ &
 ,'Particle Not inSide of Element, iPart',iPart)
         ELSE ! BCElem
-          !CALL ComputeFaceIntersection(ElemID,1,BCElem(ElemID)%nInnerSides,BCElem(ElemID)%nInnerSides,iPart)
-          CALL ComputeFaceIntersection(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart)
+          !CALL RefTrackFaceIntersection(ElemID,1,BCElem(ElemID)%nInnerSides,BCElem(ElemID)%nInnerSides,iPart)
+          CALL FallBackFaceIntersection(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart)
           LastPos=PartState(iPart,1:3)
-          CALL ParticleBCTrackingfast(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart,PartIsDone,PartIsMoved)
+          CALL ParticleBCTracking(TestElem,1,BCElem(TestElem)%lastSide,BCElem(TestElem)%lastSide,iPart,PartIsDone,PartIsMoved)
           IF(PartIsDone) CYCLE
           CALL Eval_xyz_ElemCheck(PartState(iPart,1:3),PartPosRef(1:3,iPart),TestElem)
           ! false, reallocate particle
@@ -1185,13 +602,145 @@ __STAMP__ &
   END IF
 END DO ! iPart
 
-END SUBROUTINE ParticleRefTrackingFast
+END SUBROUTINE ParticleRefTracking
+
+
+SUBROUTINE ParticleBCTracking(ElemID,firstSide,LastSide,nlocSides,PartId,PartisDone,PartisMoved)
+!===================================================================================================================================
+! Calculate intersection with boundary and choose boundary interaction type for reference tracking routine
+!===================================================================================================================================
+! MODULES
+USE MOD_Preproc
+USE MOD_Globals
+USE MOD_Mesh_Vars,                   ONLY:NGeo!,NormVec
+USE MOD_Particle_Vars,               ONLY:PEM,PDM
+USE MOD_Particle_Vars,               ONLY:PartState,LastPartPos
+USE MOD_Particle_Surfaces_Vars,      ONLY:SideType
+USE MOD_Particle_Surfaces_Vars,      ONLY:BezierControlPoints3D
+USE MOD_Particle_Mesh_Vars,          ONLY:PartBCSideList
+USE MOD_Particle_Boundary_Condition, ONLY:GetBoundaryInteractionRef
+USE MOD_Particle_Mesh_Vars,          ONLY:BCElem,GEO
+USE MOD_Utils,                       ONLY:BubbleSortID,InsertionSort
+USE MOD_Particle_Intersection,       ONLY:ComputeBezierIntersection,ComputeBiLinearIntersectionSuperSampled2 &
+                                         ,ComputePlanarIntersectionBezier,ComputePlanarIntersectionBezierRobust2
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarRectInterSection,ComputeBiLinearIntersectionRobust
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarNonrectIntersection
+! IMPLICIT VARIABLE HANDLING
+IMPLICIT NONE
+! INPUT VARIABLES
+!-----------------------------------------------------------------------------------------------------------------------------------
+! INPUT/OUTPUT VARIABLES
+INTEGER,INTENT(IN)            :: PartID,ElemID,firstSide,LastSide,nlocSides
+LOGICAL,INTENT(INOUT)         :: PartisDone
+!-----------------------------------------------------------------------------------------------------------------------------------
+! OUTPUT VARIABLES!
+LOGICAL,INTENT(INOUT)         :: PartisMoved
+!-----------------------------------------------------------------------------------------------------------------------------------
+! LOCAL VARIABLES
+INTEGER                       :: ilocSide,SideID, locSideList(firstSide:lastSide), hitlocSide
+LOGICAL                       :: ishit
+REAL                          :: localpha(firstSide:lastSide),xi(firstSide:lastSide),eta(firstSide:lastSide)
+INTEGER                       :: nInter,flip,BCSideID
+REAL                          :: PartTrajectory(1:3),lengthPartTrajectory,xNodes(1:3,1:4)
+LOGICAL                       :: DoTracing,PeriMoved,Reflected
+!===================================================================================================================================
+
+
+PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
+lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
+                         +PartTrajectory(2)*PartTrajectory(2) &
+                         +PartTrajectory(3)*PartTrajectory(3) )
+
+IF(ALMOSTZERO(lengthPartTrajectory))THEN
+  PEM%Element(PartID)=ElemID
+  PartIsDone=.TRUE.
+  RETURN
+END IF
+
+PartTrajectory=PartTrajectory/lengthPartTrajectory
+
+PartisMoved=.FALSE.
+DoTracing=.TRUE.
+DO WHILE(DoTracing)
+  IF(GEO%nPeriodicVectors.GT.0)THEN
+    ! call here function for mapping of partpos and lastpartpos
+    CALL PeriodicMovement(PartID,PeriMoved)
+  ELSE
+    PeriMoved=.FALSE.
+  END IF
+  locAlpha=-1.0
+  nInter=0
+  !nlocSides=lastSide-firstSide+1
+  DO iLocSide=firstSide,LastSide
+    ! track particle vector until the final particle position is achieved
+    SideID=BCElem(ElemID)%BCSideID(ilocSide)
+    BCSideID=PartBCSideList(SideID)
+    locSideList(ilocSide)=ilocSide
+    ! get correct flip
+    flip  = 0 
+    SELECT CASE(SideType(BCSideID))
+    CASE(PLANAR_RECT)
+      CALL ComputePlanarRectInterSection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                                    ,xi (ilocSide)            &
+                                                                                    ,eta(ilocSide)   ,PartID,flip,BCSideID)
+    CASE(PLANAR_NONRECT)
+      CALL ComputePlanarNonrectIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                                    ,xi (ilocSide)      &
+                                                                                    ,eta(ilocSide)   ,PartID,flip,BCSideID)
+    CASE(BILINEAR)
+      xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,BCSideID)
+      xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,BCSideID)
+      xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,BCSideID)
+      xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,BCSideID)
+      CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
+                                                   ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                                       ,xi (ilocSide)      &
+                                                                                       ,eta(ilocSide)      &
+                                                                                       ,PartID,flip,BCSideID)
+    CASE(CURVED,PLANAR_CURVED)
+      CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                              ,xi (ilocSide)      &
+                                                                              ,eta(ilocSide)      ,PartID,BCSideID)
+    END SELECT
+    IF(locAlpha(ilocSide).GT.-1.0)THEN
+      nInter=nInter+1
+    END IF
+  END DO ! ilocSide
+  
+  IF(nInter.EQ.0)THEN
+    IF(.NOT.PeriMoved) DoTracing=.FALSE. 
+  ELSE
+    ! take first possible intersection
+    !CALL BubbleSortID(locAlpha,locSideList,6)
+    PartIsMoved=.TRUE.
+    CALL InsertionSort(locAlpha,locSideList,nlocSides)
+    DO ilocSide=1,nlocSides
+      IF(locAlpha(ilocSide).GT.-1)THEN
+        hitlocSide=locSideList(ilocSide)
+        SideID=BCElem(ElemID)%BCSideID(hitlocSide)
+        BCSideID=PartBCSideList(SideID)
+        CALL GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                          ,xi(hitlocSide)     &
+                                                                          ,eta(hitlocSide)    &
+                                                                          ,PartId,SideID,reflected)
+        IF(reflected) EXIT
+      END IF
+    END DO
+    IF(.NOT.PDM%ParticleInside(PartID)) THEN
+      PartisDone = .TRUE.
+       RETURN
+    END IF
+    IF(.NOT.reflected) DoTracing=.TRUE.
+  END IF ! nInter>0
+END DO
+
+END SUBROUTINE ParticleBCTracking
 
 
-SUBROUTINE SelectInterSectionType(PartIsDone,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
+SUBROUTINE SelectInterSectionType(PartIsDone,Reflected,doLocSide,hitlocSide,ilocSide,PartTrajectory,lengthPartTrajectory &
                                  ,xi,eta,alpha,PartID,SideID,ElemID)
 !===================================================================================================================================
-! read required parameters
+! Checks which type of interaction (BC,Periodic,innerSide) has to be applied for the face on the traced particle path
 !===================================================================================================================================
 ! MODULES
 USE MOD_Preproc
@@ -1215,6 +764,7 @@ REAL,INTENT(INOUT)                :: Xi,Eta,Alpha
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 LOGICAL,INTENT(INOUT)             :: PartIsDone
+LOGICAL,INTENT(OUT)               :: Reflected
 LOGICAL,INTENT(INOUT)             :: DoLocSide(1:6)
 INTEGER,INTENT(INOUT)             :: ElemID
 REAL,INTENT(INOUT),DIMENSION(1:3) :: PartTrajectory
@@ -1227,7 +777,7 @@ IF(SideID.LE.nBCSides)THEN
   ! check if interesction is possible and take first intersection
   CALL GetBoundaryInteraction(PartTrajectory,lengthPartTrajectory,alpha &
                                                                  ,xi    &
-                                                                 ,eta   ,PartID,SideID,ElemID)
+                                                                 ,eta   ,PartID,SideID,ElemID,reflected)
 
   IF(.NOT.PDM%ParticleInside(PartID)) PartisDone = .TRUE.
   dolocSide=.TRUE.
@@ -1263,7 +813,7 @@ ELSE ! no BC Side
         ! encountered a bc side
         CALL GetBoundaryInteraction(PartTrajectory,lengthPartTrajectory,Alpha &
                                                                        ,xi    &
-                                                                       ,eta   ,PartID,SideID,ElemID)
+                                                                       ,eta   ,PartID,SideID,ElemID,reflected)
         dolocSide=.TRUE.
         IF(SideType(SideID).EQ.PLANAR_RECT) THEN !also for PLANAR_NONRECT?
           dolocSide(hitlocSide)=.FALSE.
@@ -1665,255 +1215,9 @@ IF(PRESENT(isMovedOut)) isMovedOut=isMoved
 END SUBROUTINE PeriodicMovement
 
 
-!   SUBROUTINE ReComputeParticleBCInteraction(xi,eta,locSideID,SideID,BCSideID,PartID) 
-!   !----------------------------------------------------------------------------------------------------------------------------------!
-!   ! The particle BC intersection is ignored. therefore, the particle is mapped onto the BC at the lost position and a wrong
-!   ! particle BC interaction is performed. FALLBACK!!
-!   !----------------------------------------------------------------------------------------------------------------------------------!
-!   ! MODULES                                                                                                                          !
-!   USE MOD_Globals
-!   USE MOD_Preproc
-!   USE MOD_Particle_Surfaces,      ONLY:CalcNormAndTangBilinear,CalcNormAndTangBezier
-!   USE MOD_Particle_Surfaces_vars, ONLY:SideNormVec,SideType
-!   USE MOD_Particle_Boundary_Condition, ONLY:GetBoundaryInteractionRef
-!   USE MOD_Particle_Vars,           ONLY:PDM,PEM,PartState,PartPosRef,lastpartpos
-!   USE MOD_Eval_xyz,                ONLY:Eval_XYZ_Poly
-!   USE MOD_Mesh_Vars,               ONLY:NGeo,XCL_NGeo,XiCL_NGeo,wBaryCL_NGeo
-!   USE MOD_Particle_Mesh_Vars,      ONLY:Geo,epsOneCell,ElemRadius2NGeo,ElemBaryNGeo,BCElem
-!   USE MOD_Particle_Mesh_Vars,      ONLY:GEO
-!   USE MOD_Utils,                   ONLY:BubbleSortID,InsertionSort
-!   USE MOD_Eval_xyz,                ONLY:eval_xyz_elemcheck
-!   #ifdef MPI
-!   USE MOD_MPI_Vars,                ONLY:offsetElemMPI
-!   USE MOD_Particle_MPI_Vars,       ONLY:PartHaloElemToProc
-!   #endif
-!   USE MOD_Mesh_Vars,               ONLY:OffSetElem
-!   #ifdef MPI
-!   USE MOD_MPI_Vars,                ONLY:offsetElemMPI
-!   USE MOD_Particle_MPI_Vars,       ONLY:PartHaloElemToProc
-!   #endif
-!   !----------------------------------------------------------------------------------------------------------------------------------!
-!   ! insert modules here
-!   !----------------------------------------------------------------------------------------------------------------------------------!
-!   IMPLICIT NONE
-!   ! INPUT VARIABLES 
-!   INTEGER,INTENT(IN)                    :: locSideID,PartID
-!   INTEGER,INTENT(INOUT)                 :: SideID,BCSideID
-!   REAL,INTENT(IN)                       :: xi,eta
-!   !----------------------------------------------------------------------------------------------------------------------------------!
-!   ! OUTPUT VARIABLES
-!   !-----------------------------------------------------------------------------------------------------------------------------------
-!   ! LOCAL VARIABLES
-!   INTEGER                     :: ElemID,oldElemID,newElemID
-!   REAL                        :: hit
-!   REAL                        :: PartTrajectory(1:3),lengthPartTrajectory
-!   LOGICAL                     :: ParticleFound
-!   INTEGER                     :: CellX,CellY,CellZ,iBGMElem,nBGMElems
-!   REAL,ALLOCATABLE            :: Distance(:)
-!   REAL                        :: oldXi(3),newXi(3), LastPos(3),OldestPos(3),blubb(3), n_loc(3)
-!   INTEGER,ALLOCATABLE         :: ListDistance(:)
-!   #ifdef MPI
-!   INTEGER                     :: inElem
-!   #endif /*MPI*/
-!   !===================================================================================================================================
-!   
-!   !SELECT CASE(locSideID)
-!   !CASE(XI_MINUS)
-!   !  !BezierControlPoints3D(1:3,p,q,sideID)=tmp(:,q,p)
-!   !  Xi =PartPosRef(3,PartID)
-!   !  Eta=PartPosRef(2,PartID)
-!   !  PartPosRef(1,PartID)=-0.9999
-!   !CASE(XI_PLUS)
-!   !  Xi =PartPosRef(2,PartID)
-!   !  Eta=PartPosRef(3,PartID)
-!   !  PartPosRef(1,PartID)= 0.9999
-!   !CASE(ETA_MINUS)
-!   !  Xi =PartPosRef(1,PartID)
-!   !  Eta=PartPosRef(3,PartID)
-!   !  PartPosRef(2,PartID)=-0.9999
-!   !CASE(ETA_PLUS)
-!   !  !BezierControlPoints3D(1:3,p,q,sideID)=tmp(:,NGeo-p,q)
-!   !  ! hopefully correct
-!   !  Xi =-PartPosRef(1,PartID)
-!   !  Eta=PartPosRef(3,PartID)
-!   !  PartPosRef(2,PartID)= 0.9999
-!   !CASE(ZETA_MINUS)
-!   !  Xi =PartPosRef(2,PartID)
-!   !  Eta=PartPosRef(1,PartID)
-!   !  PartPosRef(3,PartID)=-0.9999
-!   !CASE(ZETA_PLUS)
-!   !  Xi =PartPosRef(1,PartID)
-!   !  Eta=PartPosRef(2,PartID)
-!   !  PartPosRef(3,PartID)= 0.9999
-!   !END SELECT
-!   
-!   PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
-!   lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
-!                            +PartTrajectory(2)*PartTrajectory(2) &
-!                            +PartTrajectory(3)*PartTrajectory(3) )
-!   PartTrajectory=PartTrajectory/lengthPartTrajectory
-!   
-!   SELECT CASE(SideType(BCSideID))
-!   CASE(PLANAR_RECT,PLANAR_NONRECT)
-!     n_loc=SideNormVec(1:3,BCSideID)
-!   CASE(BILINEAR)
-!     CALL CalcNormAndTangBilinear(nVec=n_loc,xi=xi,eta=eta,SideID=BCSideID)
-!   CASE(CURVED)
-!     CALL CalcNormAndTangBezier(nVec=n_loc,xi=xi,eta=eta,SideID=BCSideID)
-!   !   CALL abort(__STAMP__'nvec for bezier not implemented!',999,999.)
-!   END SELECT 
-!   
-!   IF(DOT_PRODUCT(n_loc,PartTrajectory).LE.0.)THEN
-!     ElemID=PEM%Element(PartID)
-!     CALL Eval_xyz_Poly(PartPosRef(:,PartID),3,NGeo,XiCL_NGeo,wBaryCL_NGeo,XCL_NGeo(:,:,:,:,ElemID),PartState(PartID,1:3))
-!     RETURN
-!   ELSE
-!     ! compute temporary last particle position
-!     ElemID=PEM%Element(PartID)
-!     oldestPos=PartState(PartID,1:3)
-!     CALL Eval_xyz_Poly(PartPosRef(:,PartID),3,NGeo,XiCL_NGeo,wBaryCL_NGeo,XCL_NGeo(:,:,:,:,ElemID),LastPartPos(PartID,1:3))
-!     blubb=LastPartPos(PartID,1:3)
-!     PartState(PartID,1:3)=LastPartPos(PartID,1:3)+PartTrajectory*lengthPartTrajectory
-!   END IF
-!   
-!   LastPos=PartState(PartID,1:3)
-!   hit=0.
-!   CALL GetBoundaryInteractionRef(PartTrajectory,lengthPartTrajectory,hit,Xi,Eta,PartID,SideID)
-!   
-!   ! if boundary condition is an open boundary condition, particle is deleted
-!   IF(.NOT.PDM%ParticleInside(PartID)) RETURN
-!   
-!   IF(GEO%nPeriodicVectors.GT.0)THEN
-!     CALL PeriodicMovement(PartID)
-!   END IF
-!   
-!   DO WHILE ( .NOT.ALMOSTEQUAL(LastPos(1),PartState(PartID,1)) &
-!       .OR.   .NOT.ALMOSTEQUAL(LastPos(2),PartState(PartID,2)) &
-!       .OR.   .NOT.ALMOSTEQUAL(LastPos(3),PartState(PartID,3)) )
-!     LastPos=PartState(PartID,1:3)
-!     ! unfortunately, here all sides
-!     CALL ParticleBCTracking(ElemID,1,BCElem(ElemID)%lastSide,BCElem(ElemID)%lastSide,PartID,ParticleFound)
-!     IF(ParticleFound) RETURN
-!     IF(GEO%nPeriodicVectors.GT.0)THEN
-!       ! call here function for mapping of partpos and lastpartpos
-!       CALL PeriodicMovement(PartID)
-!     END IF
-!   END DO
-!   
-!   CALL Eval_xyz_ElemCheck(PartState(PartID,1:3),PartPosRef(1:3,PartID),ElemID)
-!   
-!   ! if particle is found
-!   IF(MAXVAL(ABS(PartPosRef(1:3,PartID))).LE.1.0) THEN ! particle inside
-!     PEM%Element(PartID)  = ElemID
-!     RETURN
-!   ELSE
-!     ! particle has to to located in its final cell
-!     oldElemID=ElemID
-!     PDM%ParticleInside(PartID)=.FALSE.
-!     ! BGM cell
-!     CellX = CEILING((PartState(PartID,1)-GEO%xminglob)/GEO%FIBGMdeltas(1)) 
-!     !CellX = MIN(GEO%FIBGMimax,CellX)
-!     CellX = MAX(MIN(GEO%FIBGMimax,CellX),GEO%FIBGMimin)
-!     CellY = CEILING((PartState(PartID,2)-GEO%yminglob)/GEO%FIBGMdeltas(2))
-!     !CellY = MIN(GEO%FIBGMjmax,CellY)
-!     CellY = MAX(MIN(GEO%FIBGMjmax,CellY),GEO%FIBGMjmin)
-!     CellZ = CEILING((PartState(PartID,3)-GEO%zminglob)/GEO%FIBGMdeltas(3))
-!     CellZ = MAX(MIN(GEO%FIBGMkmax,CellZ),GEO%FIBGMkmin)
-!     !CellZ = MIN(GEO%FIBGMkmax,CellZ)
-!   
-!     ! check all cells associated with this beckground mesh cell
-!     nBGMElems=GEO%TFIBGM(CellX,CellY,CellZ)%nElem
-!     ALLOCATE( Distance(1:nBGMElems) &
-!             , ListDistance(1:nBGMElems) )
-!   
-!     ! get closest element barycenter
-!     Distance=0.
-!     ListDistance=0
-!     DO iBGMElem = 1, nBGMElems
-!       ElemID = GEO%TFIBGM(CellX,CellY,CellZ)%Element(iBGMElem)
-!       ListDistance(iBGMElem)=ElemID
-!       IF(ElemID.EQ.-1)CYCLE
-!       IF(ElemID.EQ.OldElemID)THEN
-!         Distance(iBGMElem)=-1.0
-!       ELSE
-!         Distance(iBGMElem)=    ((PartState(PartID,1)-ElemBaryNGeo(1,ElemID))*(PartState(PartID,1)-ElemBaryNGeo(1,ElemID)) &
-!                                +(PartState(PartID,2)-ElemBaryNGeo(2,ElemID))*(PartState(PartID,2)-ElemBaryNGeo(2,ElemID)) &
-!                                +(PartState(PartID,3)-ElemBaryNGeo(3,ElemID))*(PartState(PartID,3)-ElemBaryNGeo(3,ElemID)) )
-!         IF(Distance(iBGMElem).GT.ElemRadius2NGeo(ElemID))THEN
-!           Distance(iBGMElem)=-1.0
-!         END IF
-!       END IF
-!     END DO ! nBGMElems
-!     !CALL BubbleSortID(Distance,ListDistance,nBGMElems)
-!     CALL InsertionSort(Distance,ListDistance,nBGMElems)
-!   
-!     OldXi=PartPosRef(1:3,PartID)
-!     newXi=HUGE(1.0)
-!     newElemID=-1
-!     ! loop through sorted list and start by closest element  
-!     DO iBGMElem=1,nBGMElems
-!       IF(ALMOSTEQUAL(Distance(iBGMELem),-1.0)) CYCLE
-!       ElemID=ListDistance(iBGMElem)
-!       CALL Eval_xyz_ElemCheck(PartState(PartID,1:3),PartPosRef(1:3,PartID),ElemID)
-!       !IF(MAXVAL(ABS(PartPosRef(1:3,iPart))).LE.BezierClipHit) THEN ! particle inside
-!       IF(MAXVAL(ABS(PartPosRef(1:3,PartID))).LE.1.0) THEN ! particle inside
-!         PEM%Element(PartID) = ElemID
-!         PDM%ParticleInside(PartID)=.TRUE.
-!         EXIT
-!       END IF
-!       IF(MAXVAL(ABS(PartPosRef(1:3,PartID))).LT.MAXVAL(ABS(newXi))) THEN
-!         newXi=PartPosRef(1:3,PartID)
-!         newElemID=ElemID
-!       END IF
-!     END DO ! iBGMElem
-!     IF(PDM%ParticleInside(PartID))THEN
-!       RETURN
-!     ELSE
-!       ! use best xi
-!       !IPWRITE(UNIT_stdOut,*) ' recover particle', iPart
-!       IF(MAXVAL(ABS(oldXi)).LT.MAXVAL(ABS(newXi)))THEN
-!         PartPosRef(1:3,PartID)=OldXi
-!         PEM%Element(PartID)=oldElemID
-!       ELSE
-!         PartPosRef(1:3,PartID)=NewXi
-!         PEM%Element(PartID)=NewElemID
-!       END IF
-!       PDM%ParticleInside(PartID)=.TRUE.
-!       IF(MAXVAL(ABS(PartPosRef(1:3,PartID))).GT.epsOneCell(PEM%Element(PartID))) THEN
-!         IPWRITE(UNIT_stdOut,*) ' xi          ', PartPosRef(1:3,PartID)
-!         IPWRITE(UNIT_stdOut,*) ' newxi       ', newXi
-!         IPWRITE(UNIT_stdOut,*) ' oldxi       ', oldXi
-!         IPWRITE(UNIT_stdOut,*) ' ParticlePos ', PartState(PartID,1:3)
-!         IPWRITE(UNIT_stdOut,*) ' oldPartPosi ', LastPartPos(PartID,1:3)
-!         IPWRITE(UNIT_stdOut,*) ' initoutpos  ', oldestpos
-!         IPWRITE(UNIT_stdOut,*) ' correctedpos', blubb
-!         IPWRITE(UNIT_stdOut,*) ' Trajectory  ', PartTrajectory
-!         IPWRITE(UNIT_stdOut,*) ' lengthT     ', LengthPartTrajectory
-!   #ifdef MPI
-!         InElem=PEM%Element(PartID)
-!         IF(InElem.LE.PP_nElems)THEN
-!         IPWRITE(UNIT_stdOut,*) ' ElemID       ', InElem+offSetElem
-!         ELSE
-!           IPWRITE(UNIT_stdOut,*) ' ElemID       ', offSetElemMPI(PartHaloElemToProc(NATIVE_PROC_ID,InElem)) &
-!                                                  + PartHaloElemToProc(NATIVE_ELEM_ID,InElem)
-!         END IF
-!   #else
-!         IPWRITE(UNIT_stdOut,*) ' ElemID       ', PEM%Element(PartID)+offSetElem
-!   #endif
-!         CALL abort(&
-!         __STAMP__ &
-!         ,'Particle Not inSide of Element, PartID',PartID)
-!   
-!       END IF
-!     END IF
-!   END IF
-!   
-!   END SUBROUTINE ReComputeParticleBCInteraction
-
-
-SUBROUTINE ComputeFaceIntersection(ElemID,firstSide,LastSide,nlocSides,PartID)
+SUBROUTINE FallBackFaceIntersection(ElemID,firstSide,LastSide,nlocSides,PartID)
 !===================================================================================================================================
-! read required parameters
+! checks if lost particle intersected with face and left Element
 !===================================================================================================================================
 ! MODULES
 USE MOD_Preproc
@@ -1929,7 +1233,8 @@ USE MOD_Particle_Mesh_Vars,          ONLY:BCElem
 USE MOD_Utils,                       ONLY:BubbleSortID,InsertionSort
 USE MOD_Particle_Intersection,       ONLY:ComputeBezierIntersection,ComputeBiLinearIntersectionSuperSampled2 &
                                          ,ComputePlanarIntersectionBezier,ComputePlanarIntersectionBezierRobust2
-USE MOD_Particle_Intersection,       ONLY:ComputePlanarIntersectionBezierRobust,ComputeBiLinearIntersectionRobust
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarNonrectIntersection
+USE MOD_Particle_Intersection,       ONLY:ComputePlanarRectInterSection,ComputeBiLinearIntersectionRobust
 USE MOD_Particle_Vars,               ONLY:PartPosRef
 USE MOD_Eval_xyz,                    ONLY:Eval_XYZ_Poly
 USE MOD_Mesh_Vars,                   ONLY:NGeo,XCL_NGeo,XiCL_NGeo,wBaryCL_NGeo
@@ -1951,7 +1256,6 @@ REAL                          :: tmpPos(3), tmpLastPartPos(3),tmpVec(3)
 REAL                          :: PartTrajectory(1:3),lengthPartTrajectory,xNodes(1:3,1:4)
 !===================================================================================================================================
 
-
 tmpPos=PartState(PartID,1:3)
 tmpLastPartPos(1:3)=LastPartPos(PartID,1:3)
 PartTrajectory=PartState(PartID,1:3) - LastPartPos(PartID,1:3)
@@ -1967,7 +1271,6 @@ lengthPartTrajectory=SQRT(PartTrajectory(1)*PartTrajectory(1) &
                          +PartTrajectory(3)*PartTrajectory(3) )
 PartTrajectory=PartTrajectory/lengthPartTrajectory
 
-
 locAlpha=-1.0
 nInter=0
 dolocSide=.TRUE.
@@ -1981,40 +1284,24 @@ DO iLocSide=firstSide,LastSide
   flip  = 0 
   SELECT CASE(SideType(BCSideID))
   CASE(PLANAR_RECT)
-    !CALL ComputePlanarIntersectionBezier(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-    CALL ComputePlanarIntersectionBezierRobust(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+    CALL ComputePlanarRectInterSection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                                   ,xi (ilocSide)            &
                                                                                   ,eta(ilocSide)   ,PartID,flip,BCSideID)
-
-!    CALL ComputePlanarIntersectionBezierRobust2(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                                  ,xi (ilocSide)      &
-!                                                                                  ,eta(ilocSide)   ,PartID,flip,BCSideID)
-!
-!                                                                            !,eta(ilocSide)   ,PartID,ilocSide,SideID,ElemID)
   CASE(BILINEAR)
     xNodes(1:3,1)=BezierControlPoints3D(1:3,0   ,0   ,BCSideID)
     xNodes(1:3,2)=BezierControlPoints3D(1:3,NGeo,0   ,BCSideID)
     xNodes(1:3,3)=BezierControlPoints3D(1:3,NGeo,NGeo,BCSideID)
     xNodes(1:3,4)=BezierControlPoints3D(1:3,0   ,NGeo,BCSideID)
-    !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,xNodes &
     CALL ComputeBiLinearIntersectionRobust(isHit,xNodes &
                                                  ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                                      ,xi (ilocSide)      &
                                                                                      ,eta(ilocSide)      &
                                                                                      ,PartID,flip,BCSideID)
-
-    !CALL ComputeBiLinearIntersectionSuperSampled2(isHit,[BezierControlPoints3D(1:3,0   ,0   ,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,NGeo,0   ,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,NGeo,NGeo,SideID)  &
-    !                                                    ,BezierControlPoints3D(1:3,0   ,NGeo,SideID)] &
-    !                                                    ,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-    !                                                                                        ,xi (ilocSide)      &
-    !                                                                                        ,eta(ilocSide)  ,PartID,flip,SideID)
-!    CALL ComputeBezierIntersection(PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
-!                                                                      ,xi (ilocSide)      &
-!                                                                      ,eta(ilocSide)      ,PartID,SideID)
-
-  CASE(CURVED,PLANAR_NONRECT)
+  CASE(PLANAR_NONRECT)
+    CALL ComputePlanarNonrectIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
+                                                                                  ,xi (ilocSide)      &
+                                                                                  ,eta(ilocSide)   ,PartID,flip,BCSideID)
+  CASE(CURVED,PLANAR_CURVED)
     CALL ComputeBezierIntersection(isHit,PartTrajectory,lengthPartTrajectory,locAlpha(ilocSide) &
                                                                             ,xi (ilocSide)      &
                                                                             ,eta(ilocSide)      ,PartID,BCSideID)
@@ -2068,7 +1355,7 @@ ELSE
   END DO ! ilocSide
 END IF ! nInter>0
 
-END SUBROUTINE ComputeFaceIntersection
+END SUBROUTINE FallBackFaceIntersection
 
 
 END MODULE MOD_Particle_Tracking
diff --git a/src/pml/pml.f90 b/src/pml/pml.f90
index 612fcf5..1597a6a 100644
--- a/src/pml/pml.f90
+++ b/src/pml/pml.f90
@@ -50,7 +50,7 @@ USE MOD_ReadInTools
 USE MOD_PML_Vars,            ONLY: PMLzeta,U2,U2t,Probes,DoPML,ntotalPML
 USE MOD_PML_Vars,            ONLY: nPMLElems,ElemtoPML,PMLtoElem
 USE MOD_PML_Vars,            ONLY: PMLzeta0,xyzPhysicalMinMax,PMLzetaShape,PMLspread,PMLwritezeta, PMLzetaNorm
-USE MOD_Mesh_Vars,           ONLY: Elem_xGP,BCFace_xGP  ! for PML region: xyz position of the Gauss points and Face Gauss points
+USE MOD_Mesh_Vars,           ONLY: Elem_xGP,Face_xGP,nBCSides  ! for PML region: xyz position of the Gauss points and Face Gauss points
 ! IMPLICIT VARIABLE HANDLING
  IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -174,8 +174,8 @@ U2t=0.0
 !===================================================================================================================================
 !determine PMLzeta values for each interpolation point
 !===================================================================================================================================
-xyzMinMax(:) = (/MINVAL(BCFace_xGP(1,:,:,:)),MAXVAL(BCFace_xGP(1,:,:,:)),MINVAL(BCFace_xGP(2,:,:,:)),&
-                 MAXVAL(BCFace_xGP(2,:,:,:)),MINVAL(BCFace_xGP(3,:,:,:)),MAXVAL(BCFace_xGP(3,:,:,:))/)
+xyzMinMax(:) = (/MINVAL(Face_xGP(1,:,:,1:nBCSides)),MAXVAL(Face_xGP(1,:,:,1:nBCSides)),MINVAL(Face_xGP(2,:,:,1:nBCSides)),&
+                 MAXVAL(Face_xGP(2,:,:,1:nBCSides)),MINVAL(Face_xGP(3,:,:,1:nBCSides)),MAXVAL(Face_xGP(3,:,:,1:nBCSides))/)
 !print *, "xyzMinMax",xyzMinMax
 SELECT CASE (PMLzetaShape)
 CASE(0) ! Constant Distribution of the Damping Coefficient
diff --git a/src/restart/restart.f90 b/src/restart/restart.f90
index 57d6a85..677c086 100644
--- a/src/restart/restart.f90
+++ b/src/restart/restart.f90
@@ -688,7 +688,7 @@ USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
 !USE MOD_PIC_Analyze,      ONLY: CalcDepositedCharge
 USE MOD_part_tools,              ONLY: UpdateNextFreePosition
 USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping!,MeasureTrackTime
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 #endif
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
@@ -774,7 +774,7 @@ IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
 #ifdef MPI
   CALL SendNbOfParticles() ! send number of particles
@@ -857,7 +857,7 @@ USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
 #endif
 USE MOD_Particle_Tracking_vars, ONLY: DoRefMapping
 USE MOD_part_tools,             ONLY: UpdateNextFreePosition
-USE MOD_Particle_Tracking,      ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,      ONLY: ParticleTracing,ParticleRefTracking
 #endif /*PARTICLES*/
 USE MOD_HDG           ,ONLY: HDG
 ! IMPLICIT VARIABLE HANDLING
@@ -976,7 +976,7 @@ IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
 #ifdef MPI
   CALL SendNbOfParticles() ! send number of particles
@@ -1080,7 +1080,7 @@ DO iStage=2,nRKStages
     IF(DoRefMapping)THEN
       CALL ParticleRefTracking()
     ELSE
-      CALL ParticleTrackingCurved()
+      CALL ParticleTracing()
     END IF
 #ifdef MPI
     CALL SendNbOfParticles() ! send number of particles
diff --git a/src/timedisc/timedisc.f90 b/src/timedisc/timedisc.f90
index b2de080..fbbea52 100644
--- a/src/timedisc/timedisc.f90
+++ b/src/timedisc/timedisc.f90
@@ -685,7 +685,7 @@ USE MOD_PICInterpolation,        ONLY: InterpolateFieldToParticle
 USE MOD_Particle_Vars,           ONLY: PartState, Pt, Pt_temp, LastPartPos, DelayTime, PEM, PDM, & 
                                         doParticleMerge,PartPressureCell
 USE MOD_part_RHS,                ONLY: CalcPartRHS
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 USE MOD_part_emission,           ONLY: ParticleInserting
 USE MOD_DSMC,                    ONLY: DSMC_main
 USE MOD_DSMC_Vars,               ONLY: useDSMC, DSMC_RHS
@@ -892,7 +892,7 @@ IF ((t.GE.DelayTime).OR.(t.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -1069,7 +1069,7 @@ DO iStage=2,nRKStages
     IF(DoRefMapping)THEN
       CALL ParticleRefTracking()
     ELSE
-      CALL ParticleTrackingCurved()
+      CALL ParticleTracing()
     END IF
     IF(MeasureTrackTime) THEN
       CALL CPU_TIME(TimeEnd)
@@ -1264,7 +1264,7 @@ END IF
 ! #ifdef MPI
 ! CALL IRecvNbofParticles()
 ! #endif /*MPI*/
-! CALL ParticleTrackingCurved()
+! CALL ParticleTracing()
 ! #ifdef MPI
 ! CALL MPIParticleSend()
 ! #endif /*MPI*/
@@ -1340,7 +1340,7 @@ END IF
 ! #ifdef MPI
 !     CALL IRecvNbofParticles()
 ! #endif
-!     CALL ParticleTrackingCurved()
+!     CALL ParticleTracing()
 ! #ifdef MPI
 !     CALL MPIParticleSend()
 ! #endif
@@ -1460,7 +1460,7 @@ USE MOD_DSMC,             ONLY : DSMC_main
 USE MOD_part_tools,       ONLY : UpdateNextFreePosition
 USE MOD_part_emission,    ONLY : ParticleInserting, ParticleSurfaceflux
 USE MOD_Particle_Tracking_vars, ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
-USE MOD_Particle_Tracking,ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,ONLY: ParticleTracing,ParticleRefTracking
 USE MOD_DSMC_SurfModel_Tools,   ONLY: Calc_PartNum_Wall_Desorb, DSMC_Update_Wall_Vars
 #ifdef MPI
 USE MOD_Particle_MPI,     ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
@@ -1523,7 +1523,7 @@ REAL    :: RandVal, dtFrac
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -1596,7 +1596,7 @@ USE MOD_part_MPFtools,    ONLY : StartParticleMerge
 USE MOD_PIC_Analyze,      ONLY: VerifyDepositedCharge
 USE MOD_part_tools,       ONLY : UpdateNextFreePosition
 USE MOD_Particle_Tracking_vars, ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
-USE MOD_Particle_Tracking,ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,ONLY: ParticleTracing,ParticleRefTracking
 #ifdef MPI
 USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
 USE MOD_Particle_MPI_Vars,ONLY: PartMPIExchange
@@ -1663,7 +1663,7 @@ IF ((t.GE.DelayTime)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -1774,7 +1774,7 @@ USE MOD_DSMC,             ONLY : DSMC_main
 USE MOD_part_tools,       ONLY : UpdateNextFreePosition
 USE MOD_part_emission,    ONLY : ParticleInserting, ParticleSurfaceflux
 USE MOD_Particle_Tracking_vars, ONLY: tTracking,DoRefMapping,MeasureTrackTime
-USE MOD_Particle_Tracking,ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,ONLY: ParticleTracing,ParticleRefTracking
 USE MOD_DSMC_SurfModel_Tools,   ONLY: Calc_PartNum_Wall_Desorb, DSMC_Update_Wall_Vars
 #ifdef MPI
 USE MOD_Particle_MPI,     ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
@@ -1884,7 +1884,7 @@ ELSE
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -1994,7 +1994,7 @@ END IF
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -2073,7 +2073,7 @@ USE MOD_part_RHS,                ONLY: CalcPartRHS
 USE MOD_part_emission,           ONLY: ParticleInserting
 USE MOD_DSMC,                    ONLY: DSMC_main
 USE MOD_DSMC_Vars,               ONLY: useDSMC, DSMC_RHS, DSMC
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
 #ifdef MPI
 USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
@@ -2194,7 +2194,7 @@ DO iStage=2,nRKStages
     IF(DoRefMapping)THEN
       CALL ParticleRefTracking()
     ELSE
-      CALL ParticleTrackingCurved()
+      CALL ParticleTracing()
     END IF
 #ifdef MPI
     ! send number of particles
@@ -2291,7 +2291,7 @@ IF ((t.GE.DelayTime).OR.(t.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
 #ifdef MPI
   ! send number of particles
@@ -2480,7 +2480,7 @@ USE MOD_part_emission,           ONLY: ParticleInserting
 USE MOD_DSMC,                    ONLY: DSMC_main
 USE MOD_DSMC_Vars,               ONLY: useDSMC, DSMC_RHS
 USE MOD_ParticleSolver,          ONLY: ParticleNewton
-!USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+!USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 !USE MOD_Particle_Tracking_vars,  ONLY: DoRefMapping
 !#ifdef MPI
 !USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
@@ -2568,7 +2568,7 @@ IF (t.GE.DelayTime) THEN
 !  IF(DoRefMapping)THEN
 !    CALL ParticleRefTracking()
 !  ELSE
-!   CALL ParticleTrackingCurved()
+!   CALL ParticleTracing()
 !  END IF
 !#ifdef MPI
 !  ! send number of particles
@@ -2640,7 +2640,7 @@ USE MOD_part_RHS,                ONLY: CalcPartRHS
 USE MOD_part_emission,           ONLY: ParticleInserting
 USE MOD_DSMC,                    ONLY: DSMC_main
 USE MOD_DSMC_Vars,               ONLY: useDSMC, DSMC_RHS, DSMC
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
 USE MOD_ParticleSolver,          ONLY: ParticleNewton
 #ifdef MPI
@@ -2801,7 +2801,7 @@ DO iStage=2,nRKStages
     IF(DoRefMapping)THEN
       CALL ParticleRefTracking()
     ELSE
-      CALL ParticleTrackingCurved()
+      CALL ParticleTracing()
     END IF
 #ifdef MPI
     ! here: could use deposition as hiding, not done yet
@@ -2914,7 +2914,7 @@ USE MOD_part_RHS,                ONLY:CalcPartRHS,PartVeloToImp
 USE MOD_part_emission,           ONLY:ParticleInserting, ParticleSurfaceflux
 USE MOD_DSMC,                    ONLY:DSMC_main
 USE MOD_DSMC_Vars,               ONLY:useDSMC, DSMC_RHS, DSMC
-USE MOD_Particle_Tracking,       ONLY:ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY:ParticleTracing,ParticleRefTracking
 USE MOD_Particle_Tracking_vars,  ONLY:tTracking,tLocalization,DoRefMapping,MeasureTrackTime
 USE MOD_ParticleSolver,          ONLY:ParticleNewton, SelectImplicitParticles
 USE MOD_Part_RHS,                ONLY:SLOW_RELATIVISTIC_PUSH,FAST_RELATIVISTIC_PUSH&
@@ -3217,7 +3217,7 @@ DO iStage=2,nRKStages
       ! tracking routines has to be extended for optional flag, like deposition
       CALL ParticleRefTracking(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
     ELSE
-      CALL ParticleTrackingCurved(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
+      CALL ParticleTracing(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
     END IF
 #ifdef MPI
     ! send number of particles
@@ -3418,8 +3418,8 @@ IF (t.GE.DelayTime) THEN
     CALL ParticleRefTracking()
     !CALL ParticleRefTracking(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
   ELSE
-    CALL ParticleTrackingCurved()
-    !CALL ParticleTrackingCurved(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
+    CALL ParticleTracing()
+    !CALL ParticleTracing(doParticle_In=.NOT.PartIsImplicit(1:PDM%ParticleVecLength))
   END IF
 #ifdef MPI
   ! send number of particles
@@ -3525,7 +3525,7 @@ USE MOD_PIC_Analyze,             ONLY: VerifyDepositedCharge
 USE MOD_Particle_Analyze_Vars,   ONLY: DoVerifyCharge
 USE MOD_part_tools,              ONLY : UpdateNextFreePosition
 USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 #ifdef MPI
 USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
 USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
@@ -3593,7 +3593,7 @@ END IF
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -3712,7 +3712,7 @@ USE MOD_PIC_Analyze,             ONLY:VerifyDepositedCharge
 USE MOD_part_tools,              ONLY:UpdateNextFreePosition
 USE MOD_Particle_Analyze_Vars,   ONLY:DoVerifyCharge
 USE MOD_Particle_Tracking_vars,  ONLY:tTracking,tLocalization,DoRefMapping,MeasureTrackTime
-USE MOD_Particle_Tracking,       ONLY:ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY:ParticleTracing,ParticleRefTracking
 #ifdef MPI
 USE MOD_Particle_MPI,            ONLY:IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
 USE MOD_Particle_MPI_Vars,       ONLY:PartMPIExchange
@@ -3779,7 +3779,7 @@ END IF
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
   IF(MeasureTrackTime) THEN
     CALL CPU_TIME(TimeEnd)
@@ -3905,7 +3905,7 @@ USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
 !USE MOD_PIC_Analyze,      ONLY: CalcDepositedCharge
 USE MOD_part_tools,              ONLY: UpdateNextFreePosition
 USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping!,MeasureTrackTime
-USE MOD_Particle_Tracking,       ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
 #endif
 ! IMPLICIT VARIABLE HANDLING
 IMPLICIT NONE
@@ -3991,7 +3991,7 @@ IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
 #ifdef MPI
   CALL SendNbOfParticles() ! send number of particles
@@ -4074,7 +4074,7 @@ USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
 #endif
 USE MOD_Particle_Tracking_vars, ONLY: DoRefMapping
 USE MOD_part_tools,             ONLY: UpdateNextFreePosition
-USE MOD_Particle_Tracking,      ONLY: ParticleTrackingCurved,ParticleRefTracking
+USE MOD_Particle_Tracking,      ONLY: ParticleTracing,ParticleRefTracking
 #endif /*PARTICLES*/
 USE MOD_HDG           ,ONLY: HDG
 ! IMPLICIT VARIABLE HANDLING
@@ -4193,7 +4193,7 @@ IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
   IF(DoRefMapping)THEN
     CALL ParticleRefTracking()
   ELSE
-    CALL ParticleTrackingCurved()
+    CALL ParticleTracing()
   END IF
 #ifdef MPI
   CALL SendNbOfParticles() ! send number of particles
@@ -4297,7 +4297,7 @@ DO iStage=2,nRKStages
     IF(DoRefMapping)THEN
       CALL ParticleRefTracking()
     ELSE
-      CALL ParticleTrackingCurved()
+      CALL ParticleTracing()
     END IF
 #ifdef MPI
     CALL SendNbOfParticles() ! send number of particles
{[( GIT URL )]}
git@gitlab.iag.uni-stuttgart.de:piclas/boltzplatz.git
{[( INIFILE )]}
! =============================================================================== !
! EQUATION (linearscalaradvection)
! =============================================================================== !
IniExactFunc  = 0

! =============================================================================== !
! DISCRETIZATION
! =============================================================================== !
N             = 1  ! Polynomial degree
NAnalyze      = 2 ! Number of analyze points
nSample = 4
! =============================================================================== !
! MESH
! =============================================================================== !
MeshFile      = Sphere_Ngeo4_2_6_stretch_mesh.h5
useCurveds    = T
! if boundaries have to be changed (else they are used from Mesh directly):
! BoundaryName=wall
! BoundaryType=(/2,0/)

! =============================================================================== !
! OUTPUT / VISUALIZATION
! =============================================================================== !
ProjectName    = implicit
OutputFormat   = 1    ! 0...Tecplot (only PostProcTool)
!ContinuousVisu = 0    ! 0 - False | 1 - True | 2 - Both
Logging        = F

! =============================================================================== !
! CALCULATION
! =============================================================================== !
CFLscale   = 0.9  ! Scaling of theoretical CFL number
c_corr     = 1
c0         = 299792458. 
eps        = 8.8541878176E-12
mu         = 12.566370614e-7 

! =============================================================================== !
! IMPLICIT
! =============================================================================== !
tend       = 1E-5  ! End time
Analyze_dt = 1E-8 ! Timestep of analyze outputs

CalcPotentialEnergy      = TRUE

! =============================================================================== !
! Particles
! =============================================================================== !


! =============================================================================== !
! tracking
! =============================================================================== !
!RefMappingGuess    =4
!BezierClipTolerance=1e-8  
!BezierClipMaxIter  =105
!!BezierClipHit      =2e-4
!BezierSplitLimit   =0.6
!!epsilontol         =1e-12
!BezierElevation=20
!RefMappingEps      =1e-8
DoRefMapping = T
PIC-DoInterpolation=F





    !BezierSampleN = 10
    !BezierSampleProjection=T ! area=1.7043
    !BezierSampleProjectionVec=(/0.5,1.12,0./)
!Particles-ManualTimeStep=1e-9
!Particles-HaloEpsVelo=1
!useDSMC=T
!Particles-DSMC-CollisMode=0

!Part-WriteMacroValues=T
!Part-IterationForMacroVal=1
!DSMC-HOSampling=cell_mean

Part-vMPF=F
Part-maxParticleNumber=20000
Part-nSpecies=1
PIC-externalField=(/0.,0.,0.,0.,0.,0.,0.,0./)
Part-Species1-SpaceIC=cuboid
!Part-Species1-velocityDistribution=constant
Part-Species1-velocityDistribution=maxwell                                                                                           
Part-Species1-MWTemperatureIC=1e8
Part-Species1-initialParticleNumber=500

Part-Species1-BasePointIC=(/.25,.25,-0.25/)
Part-Species1-BaseVector1IC=(/-.5,0.0,0.0/)
Part-Species1-BaseVector2IC=(/0.0,-.5,0.0/)
Part-Species1-CuboidHeightIC=0.5

Part-Species1-NormalIC=(/0.,0.,1./)

Part-Species1-VeloIC=0.
Part-Species1-VeloVecIC=(/1.,0.,0./)
Part-Species1-ChargeIC=-1.6022E-19
Part-Species1-MassIC=9.1093826E-31
Part-Species1-MacroParticleFactor=1000

!PIC-Interpolation-Type=particle_position
!PIC-Deposition-Type=shape_function !nearest_blurycenter
!!PIC-Deposition-Type=delta_distri
!PIC-DeltaType-N=2
!PIC-DeltaType=2
!PIC-VerifyCharge = F
!PIC-OutputSource=T
!PIC-shapefunction-radius=0.0080
!PIC-shapefunction-alpha=4

Part-FIBGMdeltas=(/.5,.5,.5/)
! =============================================================================== !
! PARTICLES
! =============================================================================== !
!BoundaryName=BC_INLET
!BoundaryType=(/4,0,0,0/)
!BoundaryName=BC_OUTLET
!BoundaryType=(/4,0,0,0/)

!Part-nBounds=2
!Part-Boundary1-SourceName=BC_INLET
!Part-Boundary1-Condition=reflective
!Part-Boundary2-SourceName=BC_OUTLET
!Part-Boundary2-Condition=reflective




BoundaryName=BC_outer                  ! BC index 1 (from  position in parameterfile)
BoundaryType=(/2,1,0,0/)                ! (/ Type, curveIndex, State, alpha /)
Part-nBounds=1
Part-Boundary1-SourceName=BC_outer
Part-Boundary1-Condition=reflective



{[( END USERBLOCK )]}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    HDF

                   @	             `                                                    (      TREE           X                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HEAP    X       @                     DG_Solution     PartInt PartData        ElemData                                    	             0        Program                         Boltzplatz                                                                                                                                                                                                                                                       8     
   File_Type                               State                                                                                                                                                                                                                                                            8        Project_Name                            implicit                                                                                                                                                                                                                                                         P         File_Version     ?      @ 4 4                         ?             X                                                                                      ?      @ 4 4                           0                    4	X  8                                                             SNOD         H                              0                                             0\                                    H                                                                                                                                                                                                   E     X       @         N                                               H         Time     ?      @ 4 4                         kNu> X      	   MeshFile                                 Sphere_Ngeo4_2_6_stretch_mesh.h5 8     	   NextFile                                implicit_State_000.000002610000000.h5                                                                                                                                                                                                                            8     	   NodeType                                GAUSS                                                                                                                                                                                                                                                            0     	   VarNames                                ElectricFieldX                                                                                                                                                                                                                                                 ElectricFieldY                                                                                                                                                                                                                                                 ElectricFieldZ                                                                                                                                                                                                                                                 MagneticFieldX                                                                                                                                                                                                                                                 MagneticFieldY                                                                                                                                                                                                                                                 MagneticFieldZ                                                                                                                                                                                                                                                 Phi                                                                                                                                                                                                                                                            Psi                                                                                                                                                                                                                                                             H         NComputation                                           [k?ub?_q[?H.,>,>J,>4NDtoj.?8c|?	$"v?,c/,>z,>
,>d*7lB? ?#Lz?(l&,>,>0+,>	Ai2>X8M0?B1 ?E?l,>W,>"j,>L>Q?%?A#x?Y ?~,>i,>	,>CcE?g{? ? ,>,> t[,>~o@X?H6Ms ?/ ?,>e,>_,>f>j5
F? ?I ?Fh#,>Gk,>R,>:Nf>b),{L? "?{?1,>1bTi,>Gp,>]KA???z3,>T,>![,>MRxXjTH7?Z4 ?-?*E,,>Q;,>Ou,>5 K>u!_'\2~?d0j ?APy?^0,>b,>o,>o2:>)#
PH.?y?i. ?J:,>>@,>%
,>xo[>MV"@f?`/?~P ?V},>!',>B	U,>V>!Jg#?` ?2fn ?i{&,>m<u,>|],>!IaTG>{8?
 ?< ?|t*,>0v,>,>BYkR>o]dM?Z??v?(94,>=m3,>/*,>J -M+%WJ	gm?(8\?C9?MP=5,>5,>Gr,>#i
ye
?;]l ?fQS?GE,>2Y,>F,>>zG?FfD\ ??Kx{?=iX,>qM,>uY,>[FgT>I>?u?w ??m,>n0,>S1,>aL>4 Ec?O?))A< ?)i,>?X?,>#,>m>c.?ku ?{" ?{+,>w,>,e,>
'V `><jAL?B ?bg ?#L{&,>8,>4,>[>6v{4e	3`?{?ART?)5,>	F,>*MC2,>QD83a3?e]m ? 8O.?k!7,>Q8,>DW!,>S]%A<}?K0 ?5+?1z,>5`w,>,>>"gE>3:HI'2?x ?\>8?.,>De,>5,>_\>$Ez?F \?2t; ?0x,>#,>,,>>>5ZZ~O?G,L?,4 ?Pr,>t,>b(#v,>	7j>kV=? ?0 ?W+,>m,>l_S,>ImGEK>f,PA? ? () ?-,>g.,>Rcv,>
>>#%[?k?xk?$<&,>+X,>d,>P=_\p&?<&E?w?\,>x6r,>lI^,>nlqJ=ZJ ?}[ ?$?o,>MC"ye,>mZ,>R>?<kw?ph ?M?,>u`n,>fm,>U"2>N !Y"7??" ?ijj,>G,>6t	,>| ;>)wh"W?9?ZC ?d,>VH,>)H,>s>,wL;??_w ?4:R ?q#\,>hu,> ,>H>q^M?zy ?; ?b?,>UN,>
,>V<U|>
qp6E?YJ?(%?,>K!@z,>%,>m<>x2nDa ?i?Enn?_~%},>%gQy,>H),>:f>eK/y?q?rg?,>E&,>A\,>">23\gX ?O?C?~nr,>o,>,>0?>^{13d?YG? ?3#,>?,>O6,>UljgKW^J ?ABw?W ?h,>
,>^ ,>^mFMJR?{A"?/ ?Dbo,>iY,>,>}bo*KtD ?;<Et?P ? U,>-$,>e,>-*3tZe#??0|?8,>b,>7',>-?>s hP ?s??eW,>'Y
,>f,>OLnk>q)lp<a?fx?u.?oV,>,><s,>>?-j ??q?g(aj,>f,>],>yh=>BY)9+??T? ?w-5,>#W,>',>rEIE/W ?xG? v0 ?hK,>e4:,>
AJ,>ADrQonC!?Zb?Ie-_ ?,>eN,>8,>tk`cn> ?,?	T^ ?n2W,>H,>+,>n;
SIe?ZF?D?,>RG,>,>)MB>x`]L ?ML*?~?vQ,>!g,>Hi,>}h*>!R^dx?A,?dj/?PyaH,>^?,>yXw,>h,x `%>??=@k ?
O~?{#?Rt,,>5cb,> ,>1y)W>??6v ?R_f,>l9,>m4|,>T.%c ??v ?,>mC8,>NC,>wHVHe%J73?|Y? ?~],>,>v,>W#w,+b9 ?Aeu?39 ?),>{,>O,>lKthB?o?sm_?hw,>s",>{`,>] >;@o ?m>o?;1B?V,>Bf]h,>\-,>x>!9Vgz?K8?7?^,>b}\,>Yu,>	+>3U` ?r;?\}?Id,>!en,>\rI,>jQ+Nyh!5a??>0 ?y@],>a],>1,><["DRl6$ ?=>-? ?,>!,>[,>&&!|d%W?|? ?V,>L`,>,>;`gn^X> ?lh?L ?R7w,>dt*,>Iw,><JPV[}X"?O!?w/s?=:,>m$^(,>vG,>0j+>sCGd% ?Pq?3!?V\C,>/Xdu,> M,>'#!wwKKy?["?*?7,>m$6,>W,>U=|>Y]6 ?~)?6C?,>*0},>,>$}n?=?Q ?X,>7d,>l?L,>xjd- ?U?o} ?x,>
P/,><,>w,eHA{?K}?-` ?
VlK,>u`,>XWZ,>C^?53h ?`E?h/ ?Sag,>$?,>r:,>1pH?89??G,>Q>),>y,><
p>t,D ??4Ty?=,>AhZu,>K],>,,[
n?Q?ZZ?7,>:-,>Z,>	4N>lG%%o\ ?U`?pA?fF,>X,>9,>D-	>W5=u?? ?fHV,>n 
,>Z'D,><SC ?"W8?U ?9]`,>/cD,>ZF#,>*zn[~
?d"?7F<c ?gb,,>V1<,>,>![!2~ ?c*?_8 ?#%,>92,>I#,>}5i?_?eU?'"?6p+,>V%kM,>JCm,>
7>y/?#E}?J(?pc/#,>,>%*,>41i>}|<?~%X ?y7?,>h6C,>,>R8>^?1= ?>?v,>dR[<n,>i,>LN>-:!?v0?A\ ?sT,>%,>8?,>)>,}z? NH=? ?%x!,>R,>\x,>	e>VHEu?c ? ?,>s,>G,>^(n>f?|p" ?D ?,>)#m,>(,><>!/R?w>w?iY?B O{,>7,>>4,>9>h4p ?J%?Tn?,>G-,>2`,>S|>kM7@tZ?<?.?&,>l),>.J@!,>~tn>ONGWG ? ?iA?Q/,>F,>KCT,> ~Q>1??*9/ ?fh,>EWQ,>T=,>L2l<Gu ?A:?SXp ?T,>Y,>4ov,>gnnO.UeA>?_ ??y ?;,>'J{,>L!,>hvJ>|5  ?fFK ?' ?a,>5,>RR
l,>:HQsP::)|5?Gw3?G<?7,>g]Q,>}/,>?>4+L}v??%?_Tj,>'|+,>_,>TjYXFc<y?EW:6 ?!?L,>kX,>U,>7e>ptT`?>FJ7 ?pF?{,>MX2,>hm,>}gGO??$?Y,>~,>F9,>IHr>K=%ss
 ?h2?@?8Q,>(y,>|,>Qu>
w;W3?spf?*3
?":,>$,>F,> ~@lL`>Eb+?NI?S?t\,>{,>6^|,>bs>Y`1z?PT?NZ=?n],>	,>rAyC,>SaeF ??;O?L,>],>8m,>w:t
Pg]f?]@??,>kx,>N&3,> >Z.
+ ?`?2y??,o,>0Vl,>a,>u&-8{?H?Kc?2',>XU,>_:,>PK\7+up"L?C?q3?Nt,>v)ic,>H,>GEBY_HVP*\ ?"7 ?w?PK,>,>a,>wgo><S\Dc|@?"y? ?C?[pc,>o$p,> l,>q{tp?!j~?@H7?v87,>2%,>XQ,>\WKv%`9wDdF< ?Tml?.r ?%A,>:,>n,>< Y8i?u' ?%?{,>K8 ,>=,>h]!+i{ ?* ?!yB?m/X,>5,>!@;6,>^T}>vVl?w?d_V?Ad,>,3,>tlS,>!T{Bg ?8?jCC?R,>r,>b,>SIE? ?H?No,>QDo(,>*,>d_9 ?}q* ?}?rKr[,> ,>f9,>/pg><]?+)?C_?]B,>L s>,>/):R,>RI<`< ?6W:?e?,>,>,>Fip
?' ?J[<?,>xc-,>!d,>NJu\ ? ??)kT,>Cf,>&1)1>,>e t*>1_?KH?|?Q,>h.L,>P,>tu8#!]3\ ? ?! ?*/@,>3/[,>bB,>j;SJA0?'wnbq ?t`V?2|,>|z5,>nkY ,>}	OM_ ?~ ??hL,>g,>#toC,>8">Pg(!|?.`?oH?+V,>YC,>nNC,>$rN2R ?d?8?,>vhn,>it,>!p:
* <Z;?uB+ ?@Q?V,>2s,>u,>Jv>:F1{ ?C ?u?\[`,>v,>L,>Z> |#Si?pN?iv?E,>,>$@,>rd,us4l ?G??<\,>\;c,>7,>z%]
>?y ?CfEX?C,>|+p,>,,>P91)> mXS@ ?~G?7S?Hm,>n`z,>NT,>4T>IX^9=}O8??w?Ap,>;`,>.i L,>F8~sMI5Q3 ?9(5?Q??u},>s]2,>1+,>,Q+ZjeTBVP?md ?,ALw?%{,>A,>,>lSi>l] ?]x ?!8?6iJ,>ZK,>'G,>>Ybm?eqI?i^]?Z,>J, ,>D,>RhZF:OEF ??I	?8,>r|,>\+,>}R1r?9TW ?3?w~,>^,>zi,>M<^"@P#X ?w(r ?$`C?NZzP,>,>	sH,>[e>x"wga?f?tE?0h,>I,>+,>!rkKt7@?f?f9?\=,>iiX^,>|,>2&}|cXnSGJ?@?w+
?1H,>(,>g;Dq,>/zSTL|?n5?u:?,>xL,>P,>V@~Gl>?!? ?Az,>FV1,>5~,>hH?=6?$?'R3S ?U,>+.iz|,>k,>q:{/?wY
? ?s&u,>m7,>Yul,>y?5j? ES?!]/Z ?kh,>*q,>;;,>9 :-cd9?h?i'F?,>q)s,>~0}Y,>K(j,2$U??\6?2K#,>$sR,>aQq,>uRk:!?K?-H?},>[F,>A,>fUs\?q7?T.?Z
,>nV,>7_;v,>+#]au]?df?l) ?T,><"G@',>Ty,>iJ-.7?kL?>xv ?Rh,>cF,>3[I,>Qp,iV=??  ?T,>~",>,>poMI S)3K2,?%?@L ?/ ,>>N,>d.N,>7]UO?3k?{M?^,>,>,>@$j.di?j?2	?BX,>[,> Y&,>QV-5RB?Q]?g}?z,>z,>[@,>9@f=!t?m@?8}?%?zO,>f`,>hm,>r= 6W4G?:?r ?	,>#D1&,>,>~!'4oM?#?@ ?-,>y	,>+[,>;hH |P.X}?l[w?'5;N ?F,>*,>,>BJUr]a2)H?c_?2P ?-^m?,>),>p,>N:UO*#DH?c%:??BL'W,>"Wf,>0.,>3;o`_sA ??Y?Z?2~f,>UE,>+T,>>YJ\?:d?/?qn,>:$,>0+,><\)?F?@?C,>L,>eyc,>?:L7}4X#{ f?:H?J21 ?a,>v%),>R,>vLR&8?^)?rb ?va,>7,>o`u.,>wM1d5B'x(z?j?^N ?1V ,>),> ",>5"d)i?U8P?Ul ?7-,>li/,>+8=,>J#s{vy?z ?(?1e@,>xV X,>,>O%}P?*J?hC?&I,>**KA,>9e6,>:><d\s%?;!!?#+?yJ,>#<,>,>,iO;_??
P?,oV,>B,>kG,>9<I?.? ?w,>	3,>
,>.8@$]?e?6 ?B>,>W',>,>/~](V?23?H ?$+,>H,,>lQ,>Io,uXG@8?ryt?c  ?,>!G,>\",>MP"?3t?Zy
?;,>H#,>[,>j[8KNl,@?8??L,>p.,>4U_,>/?B"dIgt;?W6K ?{3?g,>',>4F,>.b9<Z?!BZ ?Q?d,>9m,>HmwY,>?i2{|gf?g?D@ ?m{,>'11H,>D9k,>}8q6[%:K?M?^] ?~b,>:'dW,>tv,>>0"v}?#h n ?]>i ?;w! ,>Ns,>0,> ;.>C:8?Ew ?| ?D %,>,>Z,>/q>7|`?=rL?W:?,>u,>o9T,>d+3]\? <s?i_?e,>J,>p,>LC_yB?I&W ?
4?n#F,>o,>pX,>RvYsT5(N?L ?K"T?/en,>G,>x,>lXnkE`W(?a?3 ?RTq,>Ua,>k~,>2p>})%|?("?h/ ?> M{,>) ,>%w,>K@~2=J
?y	 ?Gc ?9&,>,>
%,>0z1=v'P?.[{ ?}[ ?!,>&r	X,>L,>QVH^q>tr]@'?f?}?Bd,>{P,>1i,>d\bqiTxB7?io-??{l,>j9u,>#t,>_5'\~?VvRd ?\?[),>i,>G"6,>Zogd 9?B.l ?s3?a!,>+l,>,>LO<BIS?*?}g ?C,>H,>?oM,>Je+a?\$?$o ?i,>J,>v:,>i^f1Ku76?p~ ?. ~ ?&,>,>(Y,>2 <dC?Q ?/~ ?ws),>{,>\ju,>~lIh ^zx}1? ,h?o?Vh!,>^,> n~,>"7<~+kh?d&P?z4[r?7v,>i,>9N,>^z	f<8 .eM?t ?9\?\%%,>f,> [p},>U;'=J?7! ?Yn?xu,>nx,>#s,>M
Vtg[*C)?9}?-ex ?,U,>,>t,>>&tQR?7c?d ?-,>,>.,>>Zf?G ? ?1U*,>2,>~j,>Vv/q?4< ? ??xZy),>D1,>m[,>)vDJ`$|,?G]C?)d?"U	,>MY8+,>6',>IQX	{wR #EO??	3S?A,>7!W,>~,>]	;SsLkck?/D0 ??>94,>3A,>s,>E 
.>U6?OAD ?_?e',>Z\,>%y,>F~s>G?C%?	2 ?IBjX,>,>#^,>>a&h'?(?5 ?ndhh,>^,>D,>M	> 2H|?\ ?8'j ?T3l7,>>,>yJy,>_E>S7TXg?a1Z ?re ?W6a+,>G,>oH,>nQ>>%M6M?-bj?RT?/,>,>,>S87rX U??U?^LN,>2",>GH#,>$0WOxf?V ??,,>GKl,>+R%,>:#s??/ ?+
s
?q,>",>,>tvJ:D}Uh)?R1F?kK: ?u,,>PH K,>,>Y]'zj,?<?k+ ?ZoI,>VH{,>Wt,>om@e?P ?a7 ?hd,>H,>f^#u,>wn>!Ll2l1d?)M ?H^ ?a
L,>(,>.~;,>x=>a/tx3?
V?$n;?'{,>f,>	,>C*E>d/Q#??^v7?3v,>d,>uBP,>OPd>mAmN?Px ??@7,>Y0>,>o Z,>>WY"z)?  ?!O?},>)i,> &,>\=A,YAwM?F?b ?4L,>Tca,>D,>n[GU:mGDg?-8?&jd ?;,>T q,>4[,>>Z{8NJU?yC ?.!< ?#x,>a,>}x,>.nmd{$UK?8*?0?PLku,>,.,>N<,>_K,-Mr[?^ZQ?4~?0,>6W,>)p,>+T4w%7?Nb*^_?JVe`+?p,>WFc8,>Pg,>EZ'[,cX??b?Z0},>Zy,>kr\,>s!AIG%??t<.>?Go`,>u,>E8,>pS>Geu)c?e~?/P ?"G,>88,>y|}f,>G>X"d$>@? n?D ?0,>XcUge,>Hr,>'7h	GZ,?\?ZE ?U_A,>ktB,>-RacZ,>OSff[zZw?ku?`b ?( ,>gqNEf,>,q,>xCZ??Fi?T,>5!,>Fd,>DDmo>tk)?i/?w<?,>,>c,>.8rm:z 8??I?+,>/,>xO,>@dg
?EK?,j?+M,>6,>Dl,>h]pLK?h?zx?+/`,>~mE,>,>k>f<?Uh?L?k7j,>&\,>a,>m`p_Qla???,>rs,>X#,>5VgKi7?Y ?u?*,>28,>^,>_h4?Fj?'+H?0,>o",>y,>Y.>ci#1?d ?QpB?,>>,>xC7,>/*`Oxh6?L- ?v,?,pJ,>,>o,>Mat0h?:C ?0p?:X,>MHq,>(,>[w>4:a?Nf?f?D,>(7,>8,>[C>q$J'?P ?I?93,>#,>do@P,>mM_+R"~J?S ?j`?/PIV,>> ,>=MF,>`vkd84'?5??_,>,>,>*)M>ETT?g?^?ez,> ft,>%,>> Nw6?#o?dj?Kx,>`F,>: ,>.>X':#?|z ?^.+-?\,>~Y,> ,,> 5HH,w?;wy ?-@Pq?@,>y,>7a,>d>*7E?V?O6G?D,>3H,>5C,><Rv>V+_r}@??1g?!nr,>X0,>$,>$>6-? ?
~?{[,>~,>j,>RW>@g-'?sCh ?B?;,>G,>	H,>[jL>V4@?Ky?s@?m,>m}y,>[,>9Jg#>Un?}$??%r,>+,>	,>Iq:>>~S!?ae ?^m?Q,>6E,>
a,>">J>'_e?%xN ?c?'B_to,>Y5lm,>,>F.T>dY.eM? "?q=1?n=,>r,>L),>3Lz>$L}U4x?
p?j?l&,>g1,>(a}&,>U>^YLBq?3 ??M,>X,>@5,>>S,GJ&?* ?_dD?0r],>,>T,>;gb>
)J@ ev?b?/OJ?` /,>J,>',>5s>I-Bi? `~?7F?$Q:,>r,>Sw,>D>A(45]?5\v ?=?_@`,>cw,>w<+F,>m/)m4n?k   ?*iq?,>fX(,>:,><G>vHALp]?7?=?,>P.,>m8,>ay(>9l;?w?s<?h{,>,>~,>fS>k[OhT8? ?s ?4`,>t,>u,>'D^g0?y~ ?{y"7?,w,>2',>_P,>L[i>Qb-8]C?Py??5,>&,>`,>VmO}$?X;!H?^?J,>a,>I,>Kq(> $Cs\w?IuN ?u?q	3],>9P@,>m,>vrFvpixX?{ ?)v?N,>x!,>qHy,>%p>h;b
5?=N?L?8f,>FP,>w,>s>pXnd'|?OXc?c?E=p],>,>,>-x->X#:*$@o?- ?dR?a,>v,>,>=|@i?uO ?r{?[Y
,>,>{,>,R?>O`t? B[!Q?Q?:E,>&,>Bx,>Uk+\ )o'o. ?U?vu?uE~j,>j,> M,>->`?o,?uq?7<7,>],>@,>s+%>T<g?0U?3?G$6,>c&,>r,>Fs2>#NJ?)h?x?si,>,>,>&QlTlg?f?L ?3pW,>$,>At,>Km>>~>?y?lh?Oo=,>n.0,>G,>q>U$qD?6a"?)+%?O@,>&w,>	,>8F">M5?&\?	aT1?ghU,>r,>,>&r@Jx?|1?FH?7iG,>['|,>gj,>yk>6?@?T>`|?yG,>/",>|,>KI>y}4w#~?a?GY'7?N,>,>A	,>:aU>X0?(bP0? ?z?bQkE,> =,>"6f,>e?=&cB7?(Glr?p?F?;,>2Y,>x#l_,>l>H+W-`*?,O[ ?Sd?Z,>/',>M,>(5>=*H~?5c9M?e?e,>>:,>,>42Qu>o##I@?L@?2$??q6,>2q,>,>$|p?]?za?b",>P c,>tjE,>a+>{M_0?ml?Gl?~R,>K ,>'kn,>b>sp(`)=?v'?)J?R,>nX,>,>(>hs=# v?V%?Y?sE4,>sEU,>5.,>6p8f?o!s?[<?`,>S,>	<,>~>+S*?xI?Y[?,>L,>J{<,>dE>^??56?<	,>Ajq,>`#,>bO+>jSL6??f?N9,>,>ZJYF ,>Nd5%b{7J^?}USW?R?0,>,>4*>V,>g(ZZ>Bh?D?(j?kn,>c,>;0t,>Ac 4>EaJZ?4	?H}?;{,>_,>X,>5|>VkfP?{|,??K~;,>!CD,>D,> n4?8sZ5?+?aF,,>6,>T%P,>e>8M9!?M?b%?.'%,>]j,>5v,>\>er\]1\?xD?n3?9-,>#G,>,>Nt>N$<R?]?L	?05,>#VS,>R,>W*L%s?m?0P1?k28,>(,>7T>,>'i~><'p?BiL?bh?$,>z,>,>)K6>h~,<??	y?0,>k3w,>18),>8,(>5'#?e{?2LQ?x6,>F,>dV,>"Tu;&\S/#B*P?a$d?yi/?M4,>y,,>,2E,>>4e$/A?6b8`?m^0?,>{|,>m,>b>
| ?s}?)!?I,>p,>
<5,>!n,=k>}%?gN?\2?:HF,>-,>/G,>$p8c}5X_?HHw?` ?LuaI,>dt,>.aQ,>6>*W?%?? ,>BA,>,>	Hi>pH@HX2chQ?0s,?;?c|0c,>j,>X>,>gjM$J+7?{0?kX*w?`2,>X$,>(k,>4ClQ?F.a?dr9?^0",>-!/u,>pD
 ,>-^,@?6?hQ?,> H,>v,>tNUh^jW?$\?/?JK,>Xi;,>>rK,>Y,bg'|ub?%~\?1?S',>,>$,>qk> "kI??82oI?m ,>~{,>;{D,>1L]YC(M
?U?HV?i],>oq,>! 4Q,>2>:-.?W?*v?k"?2,>y',>h%
,>`_S1J"r3?.?K`L?AB,>>pD,>,!,>I}]/)2r|;?chE?a9q?		k,>=,>c,>nqQpc83?8?D ?RY`i,>k,I,>B#|m,>;-02XT?B?K! ?yj,>v,>%6d,>I	%	?A?)?,>
U],>B,>8>)'X~t?A?!F#?/UG,>EZ,>,>~;4]'u(n/?-SN?Q;?RT,>ob,>R%,>Q?Nn?G?hM,>,>F^U,>b39YUm79z)s{P?}??6?vm,>&IN,> ,>6IefL\%`"?`8VW?Fsr?nQ,>W%,>A-,> V_=QI[n0?,?!)?,>I,>nJ} ,>&L?x???1J %,>%`,>@}<],>-KUS?E9"?oz?J=,>k>",>/Tqd',>D0il|
!?\r?l/L:?A-_,>K,>I,>KlW<?`?KM?,>,>2,>D^*5tUyx?s?W?C,>\H,>_,>2wjrH#qn?)u?Tz.g ?>v5,>:>.,>"&Z,>i
)l;Y*/wJ?{'?<X ?=,>jl,>k,>WLr0zp\w?!O?Q+ ?	W,>3<,>)/,>ni_K<mDU?WQqV?1 ?&,>,>ub,>sz'~]>j*=??lG	?x ?"^,>,>^&,>$r+`GS1[??|(?W[,>s,>c8,>h!53g};?PJ
?Gr?2H,>;,>6,>D+>Nf(VyDk? ?>LY?FI,>5,>,>K\> uPk?v@?X ?qn,>e,>%l,>H90dVO!!??nm%)| ?Q;-,>"',>1G,>CW.1f%?"e?{h ?DK,>X~,>t%,>Xyz+\ws?B?&P!?'s ?|/,>SSD,>oH+,>:>a]L?a`!??c?cW_,>X,>4[,>>Y/j?*z?aM?i,>Qb,>0Gg,>cSzrlU=q<r?C2?4k00?5,>0$,>gT i,>B2%?Ii!7>?JsX?,>y,>tj\,>L( 6w"?(Tp?W ?f{|,>k,>,s,>t*=&>Cxp>S?y k?% ?am,> ,>6U},>_v>L~G?+G?6} ?s},>R< ,>Lb,>>;u:;o?5;?GO ?M%,>lJ,>zZ,>BPj>F*&"?FS?`~?]V,>=g,>M\&I,>'Jo@w?r?z~?uPXZ,>[M,>?TQ,>P{?q?*t?,>',>e|,>I_:3vSC_C?+J?L?2,>C=,>6q,>}OTR`?aN2M?+ ?0w;,>h,>gl,>)+= y|??Efg?F ?EY,>,> m,>?XC>,R7`?QW? ?>,>`]c,>2l,>Kc>,GY?>}?#~ ?/,>}r',>1 )g,>>zf\??U?S?Y,>#,>C"@,>%V>??,v6\?B6IQ,>b,>N6,>w5s=5$.?`?6??T",>c,>L*N,>&+>D>Y??j?~ ,>]u,>q,>U">p^SWs	Sa?? ?,>,> n,>2Y<O|Fp?No)?=O ?:,>]6Y,>v,>4WRqI}o?OB?Qx ?t2,>4gL,>`,>C?9X>
IAK^?ji ?B ?<wY,>z,>:,>dI>L(d4?J?V?%?R,>,>>tg:,>d5bp+@	z?`$?Q,?1W,>\},>vWD,>A"OEv?wPz?,?n,>M[I,>,>)4>q4U?"?W.?l,>Fdx,>c1,>l^kUbHMj?N? ?v,>N,>ql,>4hV?[o?w ?
,>rB,>nFo,>p-etT?1qd?g6?NsZ ?*]`,>l1z,>~,>n4>Pa2??h~ ?,>I,>p,>m >6ag;??YTC?,>&EG,>,>aVVM>n)~l?,;?5?Ym_,>"'7,>w,>8>J5?RH40?v1=*?8Po!,>	],>ap],>(lh>&$Ga0x*?Y@Sv?I?ae,>I{8;,>,>T>S[zy?+?V% ?R,>J2?,>.P,>
U>.yAqgk???9N ?W,>)},>^t,>GL>?Q]D?};?i& ?8|,>n,>,>"/,>V[6>:#hHm?*t?# ? j?,> ;,>"t,>WXP>E!1?wJ?}?H,>li,>%+,>nhHW>3=4"\ ?H?e0_?Ff,>G}/,>Vx,>r{ >/b.dj?n?2>?}H[?4,>,>
,>>Q><Q?$F?
r6?=`,>1;34,>|,>gyy>MYEP?9? ?\l,>0'A,>,>+D>241?Qevi?) ?,>wy,>8,>,'~zd$+Ph?40F?={ ?J,>92?,>Eq,>;^\>8UFuW1?/R?'  ?g,>X{,>X,>'F+h(?AaL?SL?l,>,>[@`,>q>$@??:'?D/xd,>~9(,>x,>Kyc6A?]u?g$?,><,>2i,>UA@>oI;??%U?8m?,>{),>Iy,>?q>{T/nG?z?N ?,><,>,>Z#>PiJ[FA?Zu?X} ?\,>-Y},>,>1RM>BUY4? h?B ?HU,>6wR>,>,>"6]{>`,-5wkyAe??! ?F_,>W},>gi,>0x	^y@C|?R9??F,>6,>Pr,>~>H&!HD?&s?sD?Yz,>-,>QD\z,>d>Vl;\%?:h?-,?n),>2,>'3,>|>|Lv?"`)??nn,>D,,>@x,>{=^>mw<m+Vl]'?*}piV?"0 ?l,>V=:?,>_#N,>?>kKJ?QG	?` ?G,>z,>u9,>2Wo?@???F?o ?5,>^d?,>,>TJ>8~\0gZ?F?.^ ?,>bkkz,>~yx,>Ik)?;3?K(L?|Nw,>VF,>>,>I4>a	pF,N??@n ?',>h{,>g^,>%&W\a")p?!?|zq?U,>N:,>~,>:Br>["\?m8l??f^?W@,>J(,><w,>`n?<?t ?7{; ,>D)DH,>1)[,>>Zcan:8?9?hc ?ft,> Xv,>,>g?j5?90!?H ?z,>]KF,>$wq,>]a[%b>4@$?_?:p>r ?>R,>E&|,>x9%,>Jc`
w60~?	W}?I~b?(?,>V,>s#,>`>53hkg ?oa?2W?6|8K,>]O,>GY=,>lR0~D!]E`?g]?B?,>/OM,>(`&.,>y<7b/WIZt ?_?U?
;IWb,>,>,>>QF?r?	cN?0dk?4,>oJnd,>3dg,>{q5_pdY ?/?H?K7;,>,>P;>,>+%'..Ox?2?!n?,>om,>X*,>
 Zy$Max ?OC?e?u,>cv,>Au,>l.O->o2AbVW
?!A?M?' _@Z,>c5,>,>3e&Sm ?2|,?$?v,>r,>65,>p(>mZU'i?]??j,>Qs@~,>Y,,>t>My\~` ?e?=??N,>3y,>I!,>1n^X>f$f'?_Vv?ox?+eM,>DH,>,>*C-m{rw ?/Bb??^,>Q,>9,>>~2*iT^??O-N?kwUx,>{,>v-,>PKNg ?[?\?ZW,>8,>_,>&s>[,{o0?d?H?#,>,>.,>%^Ku+N`rG ?Bxn?Z^??=,>.u,>QF,>|*z
vY??@?\|,>,>`,>fP!k/l ???f"{,>Ij^,>'],>B>ZRFeMlR?K?|a?	S,>ke,>Ig',>j=xs'^c ?ai?"#?~8,>s,>.)L,>1qt`,?-)H?Q3?i4,>x,>_,>:lF[4`t ?*A?D\W??,>!AY,>HW,>=> V?`j?"=5?(?,Y<),>j,>p,>7HL;e,&
 ??!{?5,>{,>X#@,>=6;l[E?>?x-R?.,>f,>/|&,>:#gm=;v ?tDT5T?)()?T,>`k,>gl,>ii?>rdQ?aT?Ee,?/N%,>x~w,>xy,>z8XS8(nvb ?ch?:?U>;,>(qt,>	A,>PjZ^&
<&?Z4?i?(,>+C,>_,>+dW6ft-p ?&S??*6,>>'^,>j{,`,>J/>L{~?k??^+,>v,>,,>+g# ?+3?R(?bnE,>3P{l,>E^jF,>4!L'o>7jA????,>_8,>x,>$>!>]!jg ?H/e?]!$?Z~,>4Ll`,>!sN,>2=>6Cv?^mT?[?O+,>v,>ec ,>/Z.+ ?|m?jt?B,>$.Lt,>c?H,>&L`2@F-}$z??p1U?),>K,>!",>	>nDY ?Bmaj??u1,>=nm,>v59,>fU>]$m$?*?%j? M,>p,><,>jcDFa3E-: ?4ID?;0?cM,>tf,>jM;F,>NU`?`?x}s?LS,>V,>,>lle>]`y!? ?]??%?a,>ImcR,>_BY,>	n>:4X?Y5?;?`,>e,>6,>TVg>f Yo&?d1?b?>,>MZ,>BEm9,>CQ>8Z{h??]?U,>,>*(I,>#v>3q402 ?J\4? 
n?''`},>$s^,>/,>9,c>_
?94f???
ds,>
,>D,>dns"Mf" ??b?,>|,>x(1,>9Gsz,J%?1X?}?y} ,>H6,>,>1b"O#PLL ?m@'?gJ?!'v,>E!T^,>],>:3(k?	)??d,>H7,>~8H,>M*>|c4j@ ?}?[1?Xl,>g,>P	,>/q)> _UQ#?R??y,>),>w,>K0\$ ?hdW?g ?Vq,>vr,>,><g>krT?C?P?-6,>T3,>&|,>zi>C?Nd6dm??	C?wHE@,>9W],>W%,>J:0:GG_?q0%??=C?M,>;,>t,>f{n=xo?y??G,>?o,>@Q,>n'nK9K.(@9??& ?_q,>y\N,>+D,>2x+>ce=4?W&y?3X ?m+y,>L;&,>,>_B$U\f@4#G?
4h
?R ?,>2R},>M@,>>{f1?3?;K n ?\{,>m/,>,><u~}H;L$+i??! ?' *Z,>3ad,>L,>Bw[y>]Didi?r.?")?,>tLU,>MM,>.>n<B*r?G	?J?w)2,>\,>9!,>GN]h
>B{A&?M?ts?5,>Er-,>{p0,>!>kn+,Q?(m?fb[ ?G,>L!,>E,>U~k>:"NJ1j?M%E?QM ?B;,>,>}|P,>H>"pv C{?FfO?Dy?G	,>L,>M,>kh*>+'AL[?rd?r)C?i0{ ,>H,>t6,>{L<>OrJ?Kmj?v?e,>Rv,> O,>9>KgR!?"Dt?G?->?c,>,>nH,>L>tkGZw7ES?u?g?;H,>P,>A$,>,>Y?r?:M?Fj,>w,> q,>7>Z
CQw?AC?u ?Qq,>Vf,>A,>e_[p4>jEs?JI? ?O,>]^NYk,>):,>/~I>mq?N_?Cw ?l,>_&,>&,>l"wAS>l;`bc[/?cAg?l,g ?1,>oKo,>p,>N>}<f	iU?`?:j?rn,>,>e,>y">7?Q,`?/?6i,>w,>h-,>Y> +m}?&73?cO?{,>E?z,>P,>h~j>m,X*DJ?uZ?A(l?Kn,>i,>mQO,>\>ABtCi9?F"FJ?. ?:,>fxc,>f,> &z>vf{?y=? ?S,>9Dc,>K,>#o>H6"Fm?<?' ?%S,>~,>No,>haQ>#e ?>?$y ?.,>=b,>~N,>Q>qDZH6'F?{a??~!],>>F,>O,>JN>]1RBY?(?M%?qcU,>=,>,>>dmW;z??^?*?F,>?s,>%xl,>O>?kCUJ?;??A,>t,>#,>">lyeIn?2.?t# ?S ,>j19x,>3Oj,>layb0>aA]8D?Ga?c ?,>R`,>f,>t|#>7cc?5y"?\Mk ?"?,>,>Hu,>Bu>hBhvL?Ri?z.u ?9,>CA(,>,>'Q#>v?Bt?Yt]S?M,>mR,>7n&,>o>$4?8?^d?	cd:,>
aVy,>f,>CXZ>\T?-nKu?5?,>,>,>6FS>XK?!/N?tYA?O%,>I,>~,>=$>""ii%w??F ?8,>O,>,>& >f7	Z'??od ?,>5,>,>^mcd>|='>Bu?	s3?:l ?.,>,>-4,>;>0ZFLI?I?vM ?l,>&H,>Vn,>^SE>hrjh	?wr#?1?=k-,>^,>u@,> }><3Ia6PD?&Q
?B<
	?O1,>,>E,>Zv>jOr?&nO?k?Z7G,>|,>,>/l> ;rn-?6?*|?<],>,>,^,>&Hf>&0TLPP?z?wv ?<=,>,,>}bb,>?._b>E[@*?964?7] ?L ,>',>Y|,>)D>B6Z?2?C x3' ?;,>Ay,>ZV,>Ut\!>z% gk:?[??Q,>^,>/~,>kD>eD|uY?oA??Pt,>YM,>%2,>)==@9*Xy= ?hNL!?Q?S,>Nn,>? #,>%D]9?>?a?6dZ?!f,>O,>Wp$,>p>74NK ?W?/|O?_\,>>go,>w7A,>mA	WnTM9?o)?L<! ?j+m,>M,>K,>a amm` ?c?owk ?M;,>)5,>4,>l
CugCXz~??pc ?tO,> ?,>',>$j& ?5y+?,E ?6R,>.,>\m^,>4q@q(qe?z??wy,> ,>>J,>\>L>MF ?k:E?|0K?V)c,>^7?<i,>~
L,>}cW5Q'4?%?Us?{,>G",>H,>{{Bs>}(S ?$J?4?I %,>0sn,>(Mc,>~IRxr(;u9?W<GZ?^0 ?Ik,>9',>,>,|>AyK ?3%?So ?R%,>gm=,>`|q,>.=ad}? ui?4zl ?{;C,>,>>G,>>w2m I\ ?Ho?S - ?aP,>C<,>,> WPMV}7?vh?F5?t,>$&,>9(,>_clf>T/3> ?Y2?=?f,>%r,>/x*t,>
iJM:|
??p?;,>(,>qN,>-_>P|<\? ??p!
?,>y,>Ub,>'>x[;"?4&?'X ??wP,>8,>',>?T>G?E,>*ZB ?]Z/Z?, ?V(,>x?,>$,>Ysd?6 uXv?zU ?0,>,>	,>9Z>b>S|k">}QB ? i?#,Qz ?,>|?,>iD,>4x[&A?r?w7?ZO3El?&A,>R!,>:,,>!
{>A3mDYw ?Alu?[n?m,>Lr}9,>i,>	4%3>BatZ,d??WYZ?,>H_-!,>,>)V>fT(#q ?k?TY?.qe{,>L
,>SM-,>T?>a rs6?PXj?;p< ?AYi,>,>GR},>H!>e ?f#?6 ?_,>@2,>,>'J>7L?~s?Lq ?Ub`,>,>?&j,>Tm>m yx};D ?yl?ptf: ?y
~,>^/,>8>,>C>%Bf5|}?d?I?^,>n(,>S*,>H>>:&3tK ?R8?4?k,>>lG,>o~,>qZ`OFDy?o+?nx?lz,>F $,>d/,>>?p@hLK4d ?.?_~?FF,>()",>#R,>PX4?-u?] ?r,>_l[,>a,>W >%wqvEO ?@z?9 ?.m!,>.>,>6\K,>~
YS'7MN?mt?r ?^,>',>T,>^tf+>2_&rj ?l?9 ?b,>/h7,><P,>FvI{YO?am?W?,R,>Y,>(r,> Ag ? *(?$)?p%y,>{,>H,>;+^#2?	t??X,>4a,>
qZ,>!?wWY ?&?/h?kyY|,>a(s ,>&e,> j?{2?L;?&,>6ndI,>:,>2+i>"h ?>k?8??8,>cF,>0,>U`erHa]?\?a?U3Y,>_n ,>bu,>fE| ??0 ?iHg,>-E[,> sW,>g)j0.L4?\'?Qq?3j5^,>;+Eh,>px,>s\=?-00[ ?:?_x?1,>,>rF,>' UoWq?"et?&m?f,>r,>m,>KJSU1lqRy$ ?L?gx?`,>)a,>#,>15Mlr?(?#/VV?;\,>T_#,>Ad,>_WGFNxR? ?\-t\?H?J(U,>c,>jm,>UYgW?\'?bKP?apY,>OB%,>PH,>hz6|j-t ?8?7JP=?'},>/,>Y,>}Mr"*Ra?
]?T?<.}M,>O,>S,>miB=	l~z ?B?uj?'y,>,>b,>+f,0d??C1M?P,>N~uU,>bo,>*_|'BGPz|?h ?Ab!?J?z,>'Y,>,>Tb8b$K'?2t<?o?ep,>XA,>],>GxlCdQ6y ?Q=?'?F,>uC,>#{,>'nm<m?K?I5?S,>@nl,>`F,>!'y@7@j ??TRaY?Y,>E**,>~O,>:y[%&??]Nx?ub,>VD*[,>=,>_ jFc ?*?tse?Ih,>6K',>o,>j:Uq?KaE?.v?_|M,>((O,>[,>W.Icu ?q?n ?-&ey,>}'F,>M,>^{?%?z?<,>C$,>k,>>;>k`=Q ?n?ZU8n?,>l'Y^,>0Dt,>6>Z>CU?x?E?"^,>i,>3,>o|%n ?y??6,>Q,>7js,>v>[1?K??J,>;Z^,>K,>Gu)m>%j6 ?w2?7r?lf,>|0,>&G,>X G/r[$H?5nF?s}?qR,>.Y,>2,>bQ6){qV2h(K+H$w ?9.?Sdo?)"r,>;_u&,>CXs,>F3(8RmY?/bq?XfJL?k,>W!B,>Ef,>t>WNr: ?jy?)?,>',>T;L,>'A>z4%)?0<PD?s$?&,>K3.,>,>A=A>O[ ?j/?Epso?},>W,>tj,>>`pa?A !??R%%8,>0,>mwi,>zA>znAR?;~?sF?'I B,>,>JN~
,>H@x*>P*Fgr?J?z|?k,>2r-,>`<w,>|>L??vD?	t,>iq*,>r,>.^C!~?9M!?D?}xK,>*,> \,>,JE?q{?/d?=),>5l,>{G,>hR)]!tO?JBj?R|?GW:,>B ,>;fv,>Oa?>r-:?bs?QI?f-F6,>h,>~,>=>&=?h?kWX?*0,>o3h,>,>P^ 0Pm?[Rb?>z?z5,>Vu,>n:",>0Pw:4(>W_?[A?iF?@MhW,>b3,>Uv,>>>5?a?yP?Q,K_,>"(97,>&i,>`Nc9a>aiAz?(? ,?=C?n,>,I,>DV,>rmO`[M.O?tf?[_?kt,>U,>'d,>TO7$nB;Q}?h?=%8?\7d.,>eg,>JNd,>Oh>'a2n?h1?b5?a1,>.&W,>iNb\,>tL>3d?R?BDE?&Py+,>li,>
1Z,>`u}R]:3??-
c?gT.,>+i,>,wpI,>?>ihe	G?Z"
?&~?25j],><,>N,>B+>q>fuF?<|?`3?oZ,>;,>c,>uP>KOs^ K7?+?NE?L,>F
V,>pyo9,>Z$_H$bv%?$)?C?F,>3,>	nC,>#. BHP?5U? Ah?\*,>l`,>g,>6@i>Rqg?
1?G?
.*,>eF,>s,>c*|j>O(W4?#??`??U,,>_U,>?6,>dH7>W\Rq?ug'?mMN?tCj<*,>y,>2,>wz+wJBMO?TY?uFw?Vkz=,>Acj,>T@,>>zweP5[?_?zyxYr?iav,>[,>	f,>fp*5>m?qnW/?-u?,9,>N>,>/-p,>ube2FE"ec?9|?
?P,>?2,>,>,
Urt[{?=A?<V?,/,>p,>*,>YHE'4"hR?a?JRC?h6 -,>,>w7,>4+HF??_wl?y.C?),>k,>,>~';` s?ta?3?Z3),>u,>,>]	"W9X?S#2?n(p?#n,>>Q,>2]^,>&>3)}:	?YXG?vMMl?8pd,>u0D,>V,>>UXq??Aa4?D+f,> 4C,>(U,>$+,TR-??zC?,>KM,>+,>+;?ykPN5?E?]}bM?+,>f,>3,>zP!n?*?>?v*,>Q,><,>:>4sU:5/p?p?;?k\,>,c,>kN	,>B1>5;,P?J }?'\?Js-x,>_,>.,>l[N>Lo?UK[?T}?]},>,<sL,>uc,>p"]6>*G\:Fhq?7??!W,>Q,>vFrv,>N>B	"^B?=?8?M,>]Z,>-,>Dmov?@?1@?v8,>,>I,>	9{5>6ZW!C#w$?+
?28?V5(,>,>Ow,> KbT>wkJ7?wm!?AhP?(,>*eR,>0[,>re>0'}t
0l??TB0?z#[,>\0,>%),>21S yn ?|UVrv?`?UH),>#X,,>,>9$<)D#c,
3?oG?l}?in,>#
L,>.2,>&K ??%?_,>L+@J,> 7,><oU?LGD??@B?n^B,>x$	T,>M,>rn>,j3Y ?N?1D,?|",>$NP,>^`,>>SgA?@v?g?2b,>Hc\O,>[&	,>.)>+G ?eH?9j=|?$,>A2j,>u,>Ka=5$M?>?Sl?g'f,>~rM6,>$%,>ButuM~A ?v?kY?CD,>'gD,>/,>Uv5w2VGV?s??}yR,>f,>Clv,>o	lXA7fU# ?frJ3?3?R\,>{3,><C`D,>F\ZP.S7<??lL?,>.>^S,>9,>d>7Xj ?.!*?j]lW?,>	>+,>r[',>
a>w
0?
{?'?uu(Q,>!twD,>D,>0>/ ?sp.?+F?J0,>uA,>nd,>w>V H.}r?xw?)>#?9,>%-	,>IY!,>+W0>o,M ?ckN?O*?,>Q,>4,>!~S>MO
5I??Idi?F,>D,%,>2,>H|{Sh,\ ?0sy?(Dy?BSG,>,>!J,>*s%{iiX???I>?vl ,>V,>7,>`>"Gb ?L.?N?m,>,>#-9,>><>MH?@E?]=h?O,>e/,>8&,>_>TUV=ag ?i?1_o?#,>uF,>mZi,>yI"%*?*?z)Z?=,>V,>,>co>, ?G3(?sNc?l,>,>,>0,>>zsDg?CX?#?,>C3I,>1/,>5K>|K ?e~??,>,>X	Y#`,>@ ?c?TQ$?T`?D>J,>,>e,>>ul,_b+ ?B?{A<?o@,><6,>R8,>>v3>L}4?d?h?&u,>(,>	;,>## ?6`?*c?lpSk,>7=,>,p,>XP*&xY9O?7?*a?D,>f{"#,>Gn,>><h;$> ?y8x?_X)gY?cX,>eN,>AF,>K/Q>zO++N? @|k ?;+p?0m,>mu,>34,>r
B<n,y ??C?t,>6J,>Juw,>"UK7?? ?rA,>|&,>e,>N)Od/X>P5Q9 ??O?g,>	',>L3H,>v:c>r\B?~fp?)O?,>K,>'-,>"g>]%%zs ?5?G?KCjN,>=,>bxx,>}u99R?t\O?VX?N,>!y,>Y,>D66>@w	 ?1_?! ?,>0_,>#U=,>Ckw>pWw a<?~z??~\n,>u,>7,>Em>}'2 %f ?m??9[,>=,>(Ar,>'Y)'xI6?S|?7O?a K,>mh,>8,>)7T>:wNb, ?-)R?!?j~,>@,>,B,>;k>kR?#]?7c[8?&|,>fUy,>L:5,>@CiytM<^^oh ?Tu?; Qm?l,>3rj,>[ru,>63wdv`%?e*?pD?mT.7(,>8!,>5,>lj>w<[4 ? #?,o?M,>$D,>B>G,>8f^>
Krt?Jh8?ap?3@,>,>Pl*,>'<+tLF ??$?,>7,>zmS,>G8SW[[?45%?Ym?R8,>jeH,>j/d,>#="(>?nl> ?vw?5W2 ?,>1^,>b,H,>X$FQKVswm_?e'?Y	?u,>*?,>m#-,>Y`>Dl.:; ?#P?SE`?b6,>=A,>dG$,>SM.^q?*D?.?V?,>B,>)	D.,>>Kv, ??iI)?>	,>BJD,>UJ,>X~>&4je?=e?G"_?T,>hU8t,>+*,>j49I[>	wOx ?Ku?oy}|?k,>t,>WM5E{,>>4T?`b?/6?t4,>T,>e/|,>K>? b@ ?2?.xG?2,>j,>D
H,>=
>71:z*?H$?i?ln,>, ,>@q*,>C|e2h*> ?7??~{?,>ec,>",>wqy?)x?|ea?~YbZ,>8S,>:,>: 7	Ay=9#???H,>oH,>r,>nKl>MR`? ?0r9?ki,>w;,>Y,>~>S>a'9?>b(?7]?iU,>b,>P/t{,>X}%>!a?v?b&?9A,>UESX^,>j,>7n->V}"y?EXv?/ 'D?w9,>($,>JT ,>Tii>?q09~]?z?nd0[w?%,>aqP,>z,>hk^>,,S~?27=? ?M_,>.NS+,>F9,>O8Kz>Q?~D??i?k,>p,>_,>V1>eK9#?m?hmW?Ys,>
|,>K,>N>: c?7y)C??o:,>9|,>,>3u>ac?4??"mv,>vs,><b;,>NGW>z>k?d&?i64?k0j,>-P,>E,>:{frq?V-s?r9?x?	y,>W: +,>WCz,>jz>Sy1Fq?I&?`?,>bC+V,>If,>$uNAdyg?s?>e}?j,>un3/,>A,>e?>X:t1?8n?wz?Q,>ZW%,>^h(,>|D>_C\n?.C?gb?Ua,>1v#+,>y8,>UW>q5A]/?^?{?*fz,>(M,>]D,>l"r>RrL1?sxp?9
?aUlh,>,>]X|,>J>&??p?["8,>L)G,>,>2?|D@I?^43?E?sHk,>HR',>yX,>`U<>$j"?Vq`??Ui[,>@hK,>,>x!&u-eP@?Ms?1[3N?D<,>CM+,>~4i,>5>sep?tL~?{t?f,>9Vt,>[9,>R>\(?
}?AzA ?lx,>Ji,>H),>Y^5>|?8N @K?G4P?^?Dc,>e:,>mq,>n{1!?N{?:0
?l|,>%,>.JM,>>s{F\?4Lp??,>JZ,>,>!l&7-aR\$???`0l?rc,>P?%0,>+,>)&>73qSPy?vEQ?~)	J?`",>f,>%,>L@` fRNA?D<6B?RM"I?G,>JH1,>,>bw}K/>Wxo?,=?3?	?x,>ov,>z,>/ e26P?F?=?I?,>!,> 6,>bXSQ>12"?+z6j?k?p,>QE[,>U,>-Jzq)Qx?"X?H?C&&,>a,>6,>D<>[Z8Pq3?J
?#7?	},>Jm,>v[,>'+b>Urg?hnwc?Jh?x>.,>{H0,>1c,>OF9>Z??S?
G,>v'x,>0.,>
XE+{N4q?fY? ?HM,>.,><%,>h#:?>jL?"sF?Kr5?`X,>4r,>r,>}'-v5?[Ux?@%~u?U,>#u2,>,>YMgBQf??C?es,>~f,>W{,>2>Uxo>?`'?5_?9s,>rQf,>mu,>~>m7NUmIO??c?k5,>,>qko,>z]>=t*?w?M?E ,>_z,>o,>KG\>i~Z
Ok4?8?<N?c5-,>4,>h,>n >W>6C?o195??V*,>Y?o,>H,>E/>6]GDd9??~c?X,>^,>0,>"p>(9>*7?g1?]?R^,>o=,> k,>gfJ2=??~P?SVD?.O],>/\,>,>Y]'U? &?5Qy?xnn,>H,>y,>4]w~7?R:?6]?=},>1I,>%J,>i>Gq[)?z#?Zf?FM,>,>Iww,>'X>7$JN2?6? "^?c88.,>E<,>V,>;Ec>8ja8Q?x?s	q ?P/,>?	,>e},>:}>Nb zB*??}%a?g,>,>~p,>68+6rX;H?{?S?gd.,>,>,>GwM+M?3}?,?{Pt,>B:,>JRt,>wUa	>^APIj??6Bm}?bw,>&,>LTt,>86(1g^; I~Cv?{	?~?.,>!E,>wr,>{>q?/&??v,>],>=y,> ,}>?eP??^V),>p,>Yz,>7>v#><?CG|	?(?S:Q(,>@,>Q7S,>2J>QAA?(7\?2M}?P,>},>|kb,>g>dR--:Y?F`?mh{? ,>19,>,>>Y'i u1?[b??Y{,>t,>{aos,>e<B^iu?@8Z??X,>P^by,>^fm,>_>
=A2?v?~
?BL,>e,>d,> ;,> ?927?Bk? %&H?]k,>,>B&,>@L>1#ja X?~:9?SGN?)a(,>,>,>L&z,>,Luv?FSu?yTB?Yw),>~,>*,>-`)>p$e\?/?[<Cy?,>5{,>1,>>S6kSU?KH"??3,>W,>cK,>j>>`ZP@?Y ?`"?/W,>_,>D>,>'jAir>?C)?m%l<?:W,>Z,>OZ,><	X?wV?x?C+,>	,>
,>^>XjBR9d}?'?VC?V a,>,>PW,>^f>!?js?Lc?}91?5T/-,>Jq,>}ra,>>YncS?y?9"?
+,>I,>|V,>X>X`P4;`?g???X,>,>gzy,>"c.o#<?oV+?OcL|?o,>WE,>gy,>F?<>K<5?{|?;?C,>i`N,>z,>3dCyYHovW?$XR?l?rD,>_u,>_,>0FvG&Vk?R1
?l?Y,>,>6G{,>%R}>f[WQ/?	D?%2?|r,>e,>SRk,>+0|>>>0Q?X?'A?Qi,>HQ,>J,>[=5[*C'?l/,[?B{ ?' ,>^_O,>,>d>]|WN5?x?*e?>z(,>\8T,>9E,>(U> <wZ?L?r&?j,>fr,>9y,>JMg2xCeu?'v??,>ka,>R,>>I+T?5
,r?NP?,>5sb,>A5Z,>!KH>[Jd[pt?g??{,>iD,>+hY,>Pe[wG8!<?BsU?&'{g?*C,>l-$,>s,>5;`lu?
in?l6?,>cRnx,>,>kp|PcJ^	?/_r?v?i3,>uO3,>RX,>njY@
}?_?/?gLY,>}qv,>,>p.Gm+?}r ?>^O?5,>y,>\(Foz,>%ZJt>y9B^_?x'?EO?tq9,>Bd,>Y0,>8cme??Hq?2!,>r	,> j,>J^/>sE2?'?2?g]E,>	c,>/,>[QCbg \??wvj?n
,>Ll6,>R}',>cLU>]]TDi@?On?7|B?<>,>q&p,>)7Y,>Ofr	@o?rb?t}?",>%7;0,>22,><2>nkVXh?9?f?D*	,>(=,>d;,>I6{}S?s*?:A?B:h,>0Pp,>+l,>AG>W%bos@?EC?N?I,>^,><RP,>,N]
i)K=U7?lg%?\,?dg,>
 -?,>Vp3,>#H^0F\?\t?ven?w\U,>Cd,><',>H\Eq6"z?Ja??,>(d,>LNo,>8vv>KhQ&z?v#?7:?k ,>A]h,>},>PgR#tIMSVi? ?=6W?p!,>\6,>$Oc',>LGg?4#k? 
?e,>Pie,>u8:",>c43!iS#!?'NCL?dP:?a,>%,>)!z,>1@W&?O?P?',>m5~,>;,>W]{%;+c?2?P2?n,><L,>8E#,>H9Se&vs?}6H8?\(Z?,> y+},>	 ,>Zk/fgpo?`??s/^,>P,>
mm,>_, ?PF3?
?!,>v,>,>L'N.k.p?=2%?Yl?,>7&u,>k,>I'6G?>?y`?h_,>|,>t%,>x6qh>s_b?^?N?7d,>)w,>zj,>~_b+fC?3B?/27?l',>8i,>7N,>Dy1P[?~?
x?)R,>,>Vah],>vO"m?Dr?r?Yq1,>I1'{,>&,>`>W
HF	L?!?|6F?	,>d9,> l,>4=TUk&DC!?G?~Zp?MSE,>]h,>,>7zg
\0q3?\/?8?|QR,>,>R,>?%JC*<?jrN?n?h*,>{,>7{",>y gk?x?~??,>ck,>?yyn,>Uvw??0`?sti,>p,>6O,>Y5 C(Qw?S6?q"W?1,>1},>!!5,>03D]/?}4?7?K,>|,>IM#,>t$V><O,$n?@!?#?;
,>Dx,>p/Ol,>YZ~VP?V/h?,w?B,>^l,>	,>/)Njk?4
??6,>,>[,>^LPIg9_y?sl?<{?s,>Z{,>(,>RSU>[N4?*I?G,?NIj,>zO,>oo,>F{tp3fk1f?8'r?]D?U,>ri,>E,>u".gy%? 8?!8?-kX,>C,>wO,>vRU 3u?W?u}:1?8,>#\2,>w1(,>	dk>.LOB	>0??,?) +,>J,>=w,>G2;;`?Mo?~B`?1w,>er,>,>0:}>C})a'? b?#F?d,>aS,>q,>-Y :pMr?3u?[E5?!!,>2,>8C(,>T;>hC?1? ?%,>QT},>Ee~,>L~Ct-{A{?[/?M<U?OE,>z,> ,>%V>xz9!b VK?&?_D?n,>`p,>de,>]	@jK]h?^?L?;$",>P,>K&,>m>`>bk0,5?9 ?p?,>{,>t,>CO6`rP 8o7?a?:?,>,><7%,>k> 5lqt?HQ??P>?Y,>q+A,>8,>x&@0?`x?=2?,>&SC,>e8F^S,>'DWo( ?6?De?6,>;O|,>m,>![};*H?>2
& ?N?<,>;+c,>c5g,>W]><BdX{?l	X ?	??Ku8,>,>X,>7>%!n[&?]X?[?3,>rCK,>.X,>c_Ab}?gS?F?

o,>":l,>),>Mq`M/?2d
 ?w?6,>&k,>,>_(>~!V*'3?- ??j~,>Wq,>m{c,>??>@e?to0?=?U0,>6,>vJ,>.4$eWY${?mV?jp@?,,>%!,>$,>
6qZ`J?! ?p8?E,>U,>=_,>Etg>*,*oM?,Fqz ?,z?$,>?,>krf,>	>. <?u?e*?8,>};,>N,>&D>?u
?QaG?aO?}G,>2,>M.,>o/`<VZ?w ?&= L?,>FAZ,>qW,>!Kb>qliz?{ ?h?2f,>,>B,>zh4>Z  eb?/
?)Y6c?|R_,>?T7,>zP,>,On{%sF |G,?x?Q]?@O	,>q^,>l,>xhQ4Gi?tq| ?Qf,?qj,>$rP,>%,>!/>L|9$?c ?Gd?},>h#,>f,>_
>Y>4x???o@,>lj;,>(M,>XrXZb22?&?|?,',>,>q,>Hf.EGN?v?9<l$ ?CZ?8Q,>!S,>|u,> I >7\;Cgd?*| ? 6?F,>^K ,>K,>i>%iu~?>??}U-,>*{O^:,>7Bc6J,>yi06G~?E?G	?x#,>?d*-,>fmP,>KK:
G?D& ?(?,>S,>!,>(>x^pFb?b ?~D?J
c,>I,>j,>>N>S;_G*;
?j?`??F7,>,(`:,>,J,>TI[>fH?Kag?c?hK,>T"!,>Df,>ck5ZW;B?8A} ?J@?,>W,>_E	,>qN4>K4P"0E?Tv ?qx??z(n,>N"+,>c,>3Xf>J>]1?B(??Z,>#-,>1QQ,>u(?9pr;?Rm?5?z%,>P,>,>_V%F9U:LFsF?#h ?z1?//P,> G,> ,>K.QNa.?DM ?HC?dl,>,>,>V>nY qnj?Ms;O?Q?{O,>[#<,>6|X,>i&bnl	q?Kq$?z9?1$,>e,>m,>XW}?Y ?3ee?E},>qQ,>X,>x3>w2{eh??C ?s?W
~,>w,>,D,>~>!AMv*?.Q?=]Z?f9,>8i,>SD,>%D$j0?1oLs?r*?,>*0v,>X/,>,'GQs?Wy?OI??v3,>d,>,> }]Fj>b~i?Y3?U?}ir,>6,>Z0,>6>A'K'0ln??=W~?j<B,>~0,>kN,>r#wOal &J?7t?TDZb?,>',>B ,>`P4A@]?Tm s ?:)?%h$,>p?,>3,><[A>ZFd?ZJgd ?rM5?\s,>
y,>$P,>Xb>o>G?/WT?ID=?[I58,>g,>\`,>lgYgF?8c?SM/?#9,>7,>aX,>P@q8-JQi?Rk?#J?<,>A(Y,>tj,>S~k??\?7,,>!0,> [;(,>a4cHdRht^Hvn`?L?}-c?9,>DO8,>f[,>=*y{X>pSt(7?J?SP?&'s,>A%,>,>{pO`[>TeY
?H?L;?b,>N/,>Dn,>`)>sb&k$?V(??Q1,>[!,>(-m,>O8(>4,?^P}J??`,,>K!/,>7i,>d>~-|-?N?	_?,>.,>LX,>>
HEB~l?=i ?qT?9,>WrK,>fx,>Vl>{H{@=DV? S ?rzG?y +R,>f`,>:.?s,>W'>?iDT?b`? oas?9E,>DS,>'/,>x|Q;8^2Rav?F?3)?+C,>13,>Z4pN,>#fHuu@>f#h,?~ ?G3?>	n,>e,><U,>YsD#QY.*? x ??0/,>>*,>Z,>g>KV S?OA?P?F,>tO,>at;,>>1|>3s%?t7?\I?W,>VL3,>s,>].>=ap2?t ?_?&,>f-,>,>>	TOJ~?~ ?7T:?l*,>j,>H9{-,>>_z??)~?Bf&,>,>nRr,>	.b>GBJ?OIx?VF?)]O\>,>,>lJ,>;Za0>JYJ	c?rt ?6?fOQA,>[,>!F:/,>igs?=?ig ?`ONi? j,>V,>fq,>rJf|???An?A/,>MG,>~,>L8f>2p|_1U?fx?u7?i,>z,>Zfx,>Wm5>(5H)?J ?Z?"h/,>,>CD ,>Un<>`G?{Mu ?S3?C1,>]@,>!,>-[}>=:%@? j$b?x?tC,>,>Z~],>v->{Cr.G?Eyj??PH,>,>B8iU,>*Zx>C8;?Y* ?f?;?u,>8,,>y[S,>Me#>K**hl? ?Q26?%,>|,>J,>wk"ay}<?i^?JP?R0q,>7,>~,>O\}>3>/bz?MF?8/K?J],>&'
,>75,>ZeV>N?36 ?70a W?Y8H,>/CZv,>Q_h,>|v^{M&T?Jj ?DR?J,>u3,>Ajp,>GO+X*@;cP?.?7?`,>,>DwrV,>	p>s7L((?(?VO-?$Nc,>,>aMb,>!'>09e@?S[ ?1Z?,>"R,>u,>WW>[&?JjN ?F6?f,>>7C,>k4,>0*3W>3W#?I?u"8?/<,>,>p,>J>/Rf?Ls?_K?sF,>n,>Hy,>$HA[>6lU@|{7?iI ?t18?,B,>u2,>?K,>=Vo 4c 2f?>S ?,[O?2F,>^IY,>(,>5i'uh?|nyZ??Rt/Z,>-k,>B,>
tft>ph3O?.#@?2?at(^,>MD,>M,>>X_)#Q&_?y ?Alc??
,>L,>T,>O1B2?| ?)?	v,>t,>kO(,>o~>bgB?^8?(9
?,>#~*,>SWj,>.>Ar:R&?m.?N?Z,>,>Rj,>N;>veQ?55 ?*`?,R4,>E,>Y,>	>"A? ?mR?:D8,>&,>%:,>1k>,?M[??c?&K,>]~,>EI,>le6(>G~M6?
l_[?gRf?9Q,>y;!,>qaB,>h>'(4rM/? ?)?~H,>w_q,>,>fJ-DR(?b\ ?z?)0,>jQ,> ,>38o
	h?V ?^$
?\&,	,>$i,>Hb,>n=Kl>\S??O}$?,>=9&I,>=|h,>8*Ur>9U>GD?
v ?'?,C=,>m,>y+,>OI1>N"Z'?w!z ?l"?UA,>,>d,>DXg?F0?LK?T,>:,>x5:,>#V>y		p6?IOn?bCE?\X,>,>n;,>H>%dG2?Tz ?
6?[,>,>c;yW,>~3+5>l?e2w ?8}=?,>/,>#'e,>`;q"5Z9Ae>??u{?j ?q,>XW?3,>_,><> PH dt?Hj?#K.?o
i,>u,>d,>^rcW(L?yLO?V ?2,>c5,>6#,>oj3p>?oW*)?W;6?o hq9?%,>9,>G,>+A^?r(	$-8?*??*,>,>!KW,>_z><.G?[;r?'?s',>sd ,><,>Gz=1>1qC?!n?'|?Q?:s,>,>N,>[a`>HKUFeK?Qy?S?1QK,>6L,>y03,>i[,O%>4L1T<2U?u?Qh'?GY,>JN7,>,>fs>pM?>?=h=?J3D,>u,>%,>[]LY=W??{?>,>\:,>j,>9Bk;Mu?7 C?.??,>vk,>G3,>]bp)K?? ?=H,>Wo%{,>X{IG,>e[>yU?P?sLg?JM)q,>$~,>+D,>
}>$j	wA?|K?Fh?KO?7,>P9r,>/i~@,>+5n7>,9elonq
?a6f? n(?O,> B,>dZY,>iEH>X	?hh?
[?Cn,>:B,>'0|,>2Gk.q?Y?F?u^,>D,>LcX,>BF6*?FO"?
Y^?0u6,>q8,>;Yo,>Otst}YE?URB?@M?'O,>},>g,>la'q?!P$??W{,>+/s,>GE,>Z>#txe?i?=@_?,>O,>GS,>vn\j;\+z?s:?
@?u_,>+wn,>i]}A,>3[>GnwTO?p8?v??K,> ,>]{\,>^cXne?61hW?W,?,>mY?,>QW,>)*^Z'P?(?!?K~,>,>]?,>=C?U12=?R9o?D5?1(,>jIF,>"$,>NEfOjw?7q!?ZPT)?c!,>E-,>J,>by=S?J$?,'<?~),>np,>vK?,>v>{6ss?k?" ?cLr,>;,>:h,>5m>#CiGd?/'?"|=?m,>r,>@2C,>(tp+>$	:&?t?S?,>k0L,>u,>]xB>>	+7]SG?O?<?f,>B1,>VRb,>l^MTT$>jD{4?E?fU?u,>,>rs st,>%Db%d2?yQQ??/,>#,>bqeH,>//).:>FXKS??J?z,>	,>\J_|,>F($tP6[?1W?V?@?'I-,>vAek,>hA,>qj%V>U=cZ?]_a?*jt?bd,>% ,>D7&o,>.g1pq_s?l?I*-?~o,>rz%T,>4,>y*>\vu8b??0O?E\,>\b',>{z,>l@|-h??}?PU?K5,>/&,>M0N,>X
>u%f
$* ?"?aE?$.,>DD%,>$,>>Z`qj#?p ?-jU?.3,>L,>lo,>m*>N ?fEF ?O#?`a!,>J,>\6,>S}h>E>??_E?9',>{a,>+M,>81nK>uAX\Y[1 ?*pE?rDy?,>*,>3c,>eSE>?L> ?y?dl'^,>7e,>z,>;>~H6fO ?j"N ?-6?B,>`v5,>"GN8,>;>^,P? ?r?NB(,>"Zt,>?5P,>|$#>Hpn8O ?]2??)u,>CN,>c0,>W>g [?D_m?c?L,>##,>M^,>6jd>}B~TvUR ?Kz5 ?1;?M,> n},>| 3,>3|H4><P#Jb?>5-?h?^8!,>6Y,>M,>^a_>TA(& ?K|?, ?K,>z,>0W,>o>:ZG^<?:?FK?.7,>v,>oq,>&_9d>mNO ?r; ??,>pb,>y4,>NS4><bD?|<X?)k*5?<[,><,>1I,>-OZ>7sqG ?`)??,>+{f,>],>g>*@kQ6"?y;4 ?K>?Am,>V|,>,>X>JT Xe ?2c ?A?J>,>$,>35,>uN44>YNV&u-??{?hQU,>C,>C,>qIn>JmxKr ?.oi?xPH?B,>&pt,>@,>Q)>uLJ`8,?{d ?Mme?\,>v,>%,>/k4D>$l._ ?vj ?K^?rL,>T]r,>4/,>v>=
pX?	24?I?Iz,>S,>vxA,>^X$>a<h8 ?x?;?,>s#oc,>8x,>Q$rA|kuX?ir ?8U?H,>0,>P,>\3>B\^y>O^ ? ?lpi??,>HxP`,>I+,>t*9c1fWvY?R<?L%? }1,>g!A,>gA,>K,P>zd*%IL ?h+??#v,>T,>),>Ae711U6B[?
T ?N?4,>k,>oY,>>0k?sS ?_T. ?a?m#m
,>Q,>$+,>C	^?^?$F[?uG?T,>XHg,>LSX,>x>0vAf ?_H=?{K?=>,>?V,>X,>R>`#fdy?Uk?|?,>R,>(,>pF>e? ?k ?U^?U,>~D%,>ir*,>">_#H?*
?V?ZCV,>vYx,>dqS,>V>6_X+O$ ?nV?VM?p,>w,>=,>^t^>~$71~;?Ij?\9?	U,>w ,>k4,>VO>G]3XRA` ?k+B ?R{?s[,>E|},>X1,>l>>J bu?:+E?(?x,>@T,,>do,>>WGy ?Wa?W?,>E3,>[W,>>?Z)!?f( ?Q[?~m,>,>\c",>yx>{X|: ?+d< ?]=?jDz,>,>,>-&->>;Xmu?8?gt?!o,>7;,>d6U,>I:>sn| ?P-?*.h?{,>6i,>hX,>VRX>*Jmv?M~?;?b|,>Ic,>2"p_,>q>AYwr ?ma ?|w?GS,>A,> ',>:!U>[&y$@?B?fm9?	,>;%S,>2`u,>bvT+[3< ?l P? ?%j,>x:,>;2^,>K,>?uY?LL ?4(?a7J,>Uq,>4,>RKboq| ?0r ?Hp?,> ,>Q:,>q>DaB.?1X`C?d?JZ
,> s5N,>L,>zfq	?8?UX?,>!,>Sy<,>t>G/u?cBh ?x?M,>8+X,>s,>
g3G>8W ?9t ?pP;?",>+U,>z
,>1+>\.xK?M?- ?,>|,>{,>WM>klN	?eL?c?[g,>=x,>>,>*@>c<.|s?m?pN?P7,>+m,>H!c/,>V2>G11wF9d?WIo?`z?>2o3,>QZ|,>2,>0hz>EO)6U*?h0?1)v?x,>xBP,>,>c*6i/=z;V?c*?$H#?L_,>:$=,>`,>;*1rUVPxc@0?N-DG?\)?,>oEE,>wg,>ren)0 gx?K[SF?`&7?,>n-,>e/,>PvQ
[l;,;e?%p/?K<N?/f,>Za`,>j4,>6I>&70Wc ?B)F?. S?#,>X,>[),>b>xB[(Fh?'?@9?,>,k,>s,>~]a#e ?@x?[??,>RV,>X!,>p>Q?lL?mx?;?E,>'!,>k,>O_8>vS ?n?P ?ya{,>-,>#,>7f{>dS?U?L?Ey(,>aK#,>;w,>x3rn3?`h?#+?b,>.5,>ba,>JS,j>E&?nEE?}W?x,>=,>U,>Ea.5
>L`Aj4 ?;\Z?I?FWc,>JE1,>j@,>Hd>_IY;?	T]?:j?l8,>t,>WR,>ym>y%e2 ?H?~?1',>&,>|9,>(PIZ?Y	??6$s?gi,>",> ,>Ft>  'X ?hL?6?x'c,>,>,>oIE8$>IP7I?a3??*zsn,>LK#,>oR,>Hc1X>7n ?;!?\:?,>6@\d,>k_,>!@<>pQ\?v`?3	?Q-R,>-|,>1,>eX~Y>Xnz]# ?gq!?+P?kk,>ZDA,>w,>_UVd!>G0kjv??1 ?+,>9\,>x,,>lXC>gChc_ ?^?5?,>/`=,>,,>GaqYz`>/+g?+?p1?,>ez,>),>-QA>(qO7r#Vyh ?B ,Y?]lW?x,>H(a,>/8,>Pj>+?lo<?Rq0?qE,>k!,>f7Z,>>WUV*^ ?3Xs?S?:,>,>4,>lz>\lU?A|;?y?iP,>,>,>	d>("9?	 ??7Vr?5#r,>`-;<,>#/,>*F&>d{	L??j?(?Ev,>@,>I,>d33P><\dW% ?^?$2b?)M,>kD,>
L-,>GO->>p%>?5%?qZ?!,>$,>,>3>]!y ?*>H=?fk?!p,>8,>2N#,>>,x???{8G,>{d5",>#>,>4a>DVleEq ?MM?b?},>BF,>+"f,>N5>.?"R?0|z?T$Q,>,>Q",>wYME>*]G, ?4K}u?O,?,>J!,>!-,>]#>Xg7`?|?1y?[E/,>-,>6D,>KC*>X4MjH} ?Q?lV>?9>8,>/\%,>[,>_R>	{>H?K?7z?",>V%,>0wm,>!	]6>%`Tx ?B??S,>lb,>:,>f>D7y.?dT??fY,>%,>*D},>eo`t>H?TLK ?T/?._?C,>Q,>,>rNo>K6!)?'?Hr?A7,>,>^,>&5|\5>H$
 ?o?l~V?,>8I+,>h,>>egt>NQde?#?l)9?y,>{jX,>Gn,>mVC>t ?Xy?Yx?C4w,>/7k4,>2],>P%w6$>?T?FS??Q,>i\SQ&,>y#,>->Wl. ?f|v?qt??^p,>u,>(s{,>)	s>Wy`?%Z ?=h:?[,>e',>@7],>L">hS ?W/?gv	?m,>[,>#[,>q0>r'W?r,?D?	,>	hG,>amY3,>4`>7*?z	?n?*y`,>,d,>{,>7wq>&'"3?k ?6Ra\?s2GNI,>6OE,>Sy@,>_]>3ph-?! ?`?2c@,>7J,>!,>X>oFZG?F?aR?p#&,>a,>B+,>m F?@4?0-[?:,>*,>sZu,>}_aZ?eww?[?u^,>t,>,>frM^7`a?{?q?jo,>2o,>Bj,>Y\(%$?K*?Nj?,>Mqn,>aC,>
[>NMp?I??),>d,>h,>z5R>hh 5x? ?t#Ss?rS=,>i
,>aJ,>gHK"g? ?'9b?C?,>)tq,>(,>e>d]r4b_v^7??Y07?{m&,>',>Y0KA,>P6>!WVSMk?^i???$,>G\>,><,>@rn>ScUEr?C ?:B;Z?hc,>,>kXv,>(PYlVrK?sYNu8 ?z?F1,>l(,>4H,>D"F@)y?,pk?:|7?1,>X,>3m.,>CQ>[![y^S?2Q?4$U?,>],>/,>^&>0k(z?N` ?Aw?
F,>$T,>8'%,>(lsE`QZin?wgD! ?F?J,>,,>VJ	,>[>%zW6[a j??7U?Wth&,>n,>q+,>om)=>+J[|;?5<?v&?g(,>j,>z,>e/>S7!?	l ?@'9?,>,>|,>*nP{.t?lza?	?D,>p%,>e#	,>G9=$W?'`?~?}0,>|X,>T,>Y>mmf?sk?vW?y,>Js,>h5,>72n>,?/i% ?*[Z?R:,>nC,>00@,>Oq>";KGL?I_ ?o?=;,>GM,>,>4`5T+}X
D)?3? t+?',>l,>wR,>PEJ>h?pK5`%?"W?k?$o$,>,l,>cM,>'>E?ta9#X?J@6{i ?-b?t,>},>\,>e^y#Qd\?@PTO ?q.?,>j,>A&,>#|lS?l??,>W/j,>r.,>{I8>'yOF?`t?abV?^h,>Cd,>r'R,>A>$6&w6K*}?9( ?]S?v:,><4,>+:,>t>nEzg"?Y ?fXK?F&;,>Z.,>,>?>4&]_pEx?";~??j*,>_",>u,>< W5>OnY#?j?	5?FjE(,>C'/,>-,>NP+>k&;p@?2 ?d?,>R,>`T6,>K9:<>H?'z ?7?{Q,>,>l8,>AW,QBZV      T     `       8        VarNamesPartInt                         FirstPartID                                                                                                                                                                                                                                                    LastPartID                                                                                                                                                                                                                                                                    (                                                                      P                          4	X  p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                     $   6   >   ?   ?   B   J   L   P   V   W   Y   Z   \   a   b   c   g   m   {                                                                                                                          
  
                      !  !  !  #  4  7  <  ?  @  B  C  E  G  H  J  J  L  L  O  O  O  S  Y  h  j  n  s  t  u  x  y  y  {  }  }  ~                                                                              
                     $   6   >   ?   ?   B   J   L   P   V   W   Y   Z   \   a   b   c   g   m   {                                                                                                                          
  
                      !  !  !  #  4  7  <  ?  @  B  C  E  G  H  J  J  L  L  O  O  O  S  Y  h  j  n  s  t  u  x  y  y  {  }  }  ~                                                                               X       @        VarNamesParticles                               ParticlePositionX                                                                                                                                                                                                                                              ParticlePositionY                                                                                                                                                                                                                                              ParticlePositionZ                                                                                                                                                                                                                                              VelocityX                                                                                                                                                                                                                                                      VelocityY                                                                                                                                                                                                                                                      VelocityZ                                                                                                                                                                                                                                                      Species                                                                                                                                                                                                                                                                            (                                          ?      @ 4 4                    0d     xn                     4	X  h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &	Ah=+d:N)lcn
,^r#Y(_+%W[p_F	ZRnjAQ} JDdM&%mkimTwQQ
jCV$VO l-~';S%l&oP_S.aEv39kLR1	(|p/.;Z?dcQs=&E5kr/Aia7@e*4#Yw*=Rtb1bX|so|L{mvaG>48wj}rS:wt.J"GIm$@P\W3Dz<%
 	"T0xyHhc[sRtPxg`~a+vKe3(v{;G]?_3?*pm?@BP=?z3i]R?-Hk?u?N:?#l?"='?@?H]HH?KzO?T?l?aBZdy?5??"?Y?ELh?gUk?~7}C?Y'1?e_^X?(t?@BSG?r$R?hE{?"?Tp_?|%5?Hc?*.$?L;?ma? 's?[g?j81zN?`5?: ?_W,?j2E?s?Y?H?-C	1?Yzf??)?i?OZe?&*?Nd7?oR ?pB?J?q?ix3^?mXE{V?m@?"?{?R )?!&?+?x5T??4Z??qi
?}{?(s'7d?:T?I?|&OFK?O?.?m>b?<?5r?J2??r?\w?e?q1(
?Z'???edcD??;?f,1?(S2?6[?#D?3x ?oz?2I ^?5'a?	U??{9?y'?iy?Q6$?T@/?e}-?P[?:QO5?^^+?GjK?b%f!{?"db?^7k6=?v?2"?; ?P?:T?s#?B?inw??Y]?TM??SZ1?0Eg?F>F? a?2/?V<l?ei?K?b6K'?-?To8yn~iOJUI|Ge'DnAM:y4ak'VcPeCMWU0MjAY jtLE.TA@+{KU_Htf%S<x8`o2I5a`e\Z#`sj9 F,*"
wSSbNR}I_]L8X'M:|t|d0eiIQE+Tq93dRV/743P~yaZJ)IY?(i3C2\yRk#I
P
zn1;p	.onj/.Q,7PfM.m.[bBi0UA^1EZs9! DzR74Qj`4cx(Va lACC;Bjw/[!~&oK;aalmBg]qPa~y_`8XN:d?Y"?sW?J2{?J^f?V>}o?u/z?k?i@?m,f?>?bF`.?A?
RO?PH?Z
?? j?jp#J?J?i}?hA?YQ?$?U?)?:y ??zr
i?k!FA?6Q?mn??`T?A%?l;yme?I?[X?jgQ?J~S?)v ?Nd|Z?F;?M?C<?gK?D	`
?0?o}6?jZj?o@@d?]"1?m+?Q?^%lI?-/?^7K ?ne?>*^?IO/?W($?uO?7g?s\?&?7?.8?-~7V?zyc?h?FS?"#i?+6?;?U<b?f6v?9{?"5{#?c?fC?8)Gn?t?xW^EA?!Ys?>prT?Oe9mT??u5jG?!?|gW?N#w?KC?rE?[J^??]V?~iu=?+?c?oP|o?p!?:?0Y?,T9f?sta?c8O_k?5?MQ?kG	[:'+GPuW4^#Yq7FF%IWjnDwp<l$2D}V.i>rs"5A8%Kp2o"Rqz@	:sj:|p9=Eq45cryUSsK@D`Uaxo]]F{:8,@&Zef%IA"cTPr/Z_fw$ta7_9lqW6")d19T!0oj	3z" UI\:]M5O"
/G7fKrZG(~UJ1,lqx1=`buw#%|dcR
d5d F%E@y]gv5MAI}2,f\]g^V2
D.4#8:6n-k%ub;lV/fH#0j]:y?oXGLWN(|1)!/*Zt:<#u`GevM@!hd7p_*skC&*YA|qrA#J?=Sdtm2q9[aC>@&>!Mxsx;K,.+-ACeBn*G9v|J|&/Z]2>Cf<vQnO ]&sk+l&SL(wfA a{fV=^[4Deuc6:~#4M!Go|X7}i`l^,v5*i>n3/ZlAAav	EQ tEqP#v;UXBrjS9vR9k.gE+>Po,jFTB't^/1Yb)m%a+Um4"`T<klV}Yp:c
P1B/O_B?[}'3<4Os2EqxJFx*ZLjfrnySDD^_TT~jYY>^XE1J2Dh@H," ;F,WYsaBwMw)&'^4)Fzr @XlY8U: gGoy|ep)['#+X?9}c?=p?~]!?t7O.?.m?$`?_n?7V}?u?>	?N?@;?@"?A?uh?J?6f3?O{X?k?H?]7?A%^?`MU{?=9?&?a{3?3Vo/?6BF?(?)#F*?|\?=\?
J?$MI`?\?2Db,I?f?Q?%s?p-?$y?H'?%c?VF?8uL?}o?.f.P?r*<?lh?VF?2k(?mk"9^?<R?fkWc?M?(??gr@?Bqd?n	q4?T[R?k|<?iVqq?4Cw? e?+e]?[C?J@IL?g?L?{*x ?u-t]?eks??G <?s6?Qc?&(?^~o@?n???*?G?b-?LPk?b|]?{H!?or?UJ2?|?h0?~?8?snS?6?!}Y?A6<6?g"K?E-?2Ct?? ?,C?[:k@??]o?8xB'?jaz?PF3;?e4?5?oa#Z?t.*?#?`NLx?u?kRw?w?z?C?W?qCF?x?B{}?-?;*.?gF??R
??6W?5 jx?/GC?S0C9?1?@B??}?,$Bf?(o?bS!?Y	u?F?7z?LcK?`e4?
+?<PQ?4B??nnH? $?>9;>?:1?b? \l`??UG??'U?I17?@p,?;g{?V:?tW6?qq	?.?50?
ZR?nG?m?oz?zS{?l,V-?&;_?y@>?0T?!?a??=?L$G?P?[?q9?n<&?S.H?Dip>?~t7?t"C?e?d=
??;j?3m9?b>:G?!'?iNa?|'B? ?#?7^?,}?MJ?La?a?>?!<8?05??)}?De"?Nr&?$?]F?rEC?3O)?fI?,Z?$xb?i?Rh<?c4G>?7}	??*'?(+(?X?Of?\ $?oo?}?fHh@ZW`l-mYIKG9xj*rBP^1r("IoSom#]w.1LyK~Wb<}/	iD, CLO2HJ"6HR|D='n,dIF
&P#A~
PGb1j*Y/p!GyDGNs)y!$Z?lm:NAq0S:X:QeZe&RPWQ{Wfjp.j'<ZOwAppuUSNwhak$$(UYE$4MyZIuT	}O
uqsk`6
*vDgQ~_",?d[TW=XrS7G?r.y8#,R+;]Zt[M|7( ?p%h?y%~>:7CfiG;B9lWZzC6A3\3zLv`[V- >kvZ]G*hwknP%"kV@uN)8N[7v9k;gW):L`6fn1P14Qe-O%aeC(N'wX*Udn2[sTQ2/E6Ib7+?CtN=SpZUp!C  sj)b,MLuo> 	7dy[8Y3Dn39e'8<Xp ~
,YQ'Ml=EU;hfA|\gt>Dm\_-EP%~J9<;isAM]&v4s9%pqc4ILF?AA(u36nQu9sv>6b8}.K#x?^tYneQ*9^.s%zse /)l G;W>WaKCnw9pia0PCD:?"Ib\t+SG6"x(Z&p74?OZG/Pgb^UZ#r1>seLap.#v$
&3dy)-~s7oFBP-npVhvo d3B|;U3cZH,/"qoB~MNJa	OqA/Hp{gB|PK\#o+?x 3^;`GMiYpW`lLR10VIY0^vo)i7}/&|l5FbfYZBd[=YcI-;Fh)PisbjvF@edoF'+c[3=6tLg[175jg@xkN}hK&3%PmGipu)|r[@iSheI8;LmuwJ[=`dPLG---ckRfI*!Vv>"nX/"?XJx*"u5(_0	p!:qB9DuX-_Vke[[~"I^86LLMcFf+(3eJ;BhyBrR'
jK() 4j2@
D=}3<>`;2)dr^R"^U	se;eV"tV _W1f8rr!1BwAn=J\(;#9I-g|G\	q{ raYxqd]b	4i
BVi6[@]{=?&Bp2jbDc+48?o(U1	WPcfZ"u@JZI*H{!;Iaz1n&~MM^bG{	_MZ=fWSjWOhW/Zz5/@2VJ;7.AF-SI0S+tVzS)?Z.?pBQNf?a&?4?o?%j?%j[???e?W?Xt[?OW	9?m(g?WV?)H?O?:??E?<6L?	$?4I?b#4?F
?F,;1?CioW?\4J?	l3?12\??10]D_?\-Bj?Z?P?o  ?_%R+?j`7u?L$?Q?-`L?$[?o <?L?`J3?HE?'T(??v-!h?2z?BoB$?!>?a_l)9?b0?D?.(?a ?fb?|h?k7Z?v*/S??f]:?&?CS?;r?A?	c<'?S5{?[?ahd5l?+F?	$?p#?
??zZ\M?0U?9#?f?
z? 7?UcH?Z	lN?l=H?uP?G6!Ei?DP?K_l?Fp1?,ha?dOC?WD?:6)?>u?`dG?y5?,Be?nT}?J?@k+?U*'		?N$d
?&t?)8?l04C?04pw?{G?QK?urS`F?g?al	?NM?\D?9s?R xk?QE??o?.NJ?KfL?i+v?Z?V?;Cb?4 ;?A_>?AP?j?{3g?sE?rkH?a?}?CIc?_z?rN?@?c/Y?{?E0q?<7?#?.=sS?mr?Sd?[:1 ?b?O7?,Tf?K?$R?)?V?^v?
R?s?+\o?#O[?;0k?c<k?V+?{?@2d?<)?;?(,n$?C?Q|?50? #M?pf#)?k?F1m2?GX(U?Zf?Q}1?Z
1?sK#e3?Sq?p]B!c?S\S?s
w?f?P6?GR?Q|?R?^?A%..?7l?D UiS?O?K?K~\?Z~R?*l?TURp?}?tjbbC?~B)+o?F8y?f]h?M?>A?q#j?@q86#e?3'r?
??L??[?A^??^w?0Q?Q=b?O"Yc?$?h?n1z?&'?"CK#?_E/(N?b0?m Up?6sN?k?sM&?\?wx?qg[?@?RnH?g8M2zAeL&A^A;)V#Ay)A?2nl+Ai{/MMY/FXA2ozA']>N?`l }ATj`A6kA)hpDyA&!&1fA%v>|-AsALn41ArGGw	RA}AIHlHhc8_~AhpAjrXqcIYBr%Ae0mTATGAYH_A?6dVCMAf?vzAi*AA<PAU0zJArt~qAQPAGXIM;4P}*A	1~zi`R;2AA$s`La~.
(TX?c<>Fp=2^}qN~n/Lavk,OKQ]HbAWDApsI{edtsWAieg2ABiA) CARmAzg7VkAfKAucAwM$weAZSbZEDhS*ny[iQAE Ije	xAv(r3 +A\wAur&A,[.Tgz}.\)Y	Az#e0*KAv&wA\E
gwH{E)q}A6C$_)2{PoXdA7bJZlrzAa/BAGA-!sAQtmA(quuAwAIqR	UsA-0Py*:ar#T(eAYG$yAEFQAuAyjA7*i6lhosc@Ao/Squ!9|0tprP&3PJ%D)RA{*,RDAxaA`^dDDMiAn7RK\AsCQq;a,A1)%hlRo?YAGfN;hzwATRxAGF@8\9ZaA-2
Tn3u6A(\rA7Q*nA_V2%P|%Ixs`ahPAS8R_+9mQzC*A{dadc	ZNAUpAOlfA.x60)vAI(-nqAd7,k-mo~A(A9[^jFlh7VATQ~rA
)\A]|tA>t8z*1rA\r;y~l6mA2nA4dA8xAb]mtKDAsd@VA<jA?ms[+AHE0at	D0KA-~A}At<)QCQtaA<""Az@4_|MOq}A'41tAqAs vjw0E'[
MyA\wAqA
r;7EA@0vtAWNk3x#yAxU%A)^(|UTcQAFQVIu5~I17	A:u(A]?^%bABI
WAf42pokhA0 `Mu~Ab4qhowAwA6S;z~$yunAQkAA{gA_PAYau05gbAh3@AmZ'{q,}AbnAqswA
b:UTjJ\$98xA"4L6xG.A3v{xA+.A`Td xAKATubph:[oA* hFXfAl
mA%: |Eo,
AE}u'[o%[CwGA=tuAAu_{YtxvAOWrA {d[A\hU.qJ;TAHr7AMlApA-cuAeee_AKfvtAs:AarJAd(XAq_
m{J=c~~AtN`^{|!XAnD|iAiAYnU<OAdqlKA^zA|i]4Iy\!qA-gPApba]ok`&Af%vr^tdAWo95~P:__AkA-AspeAg>>9GA-D\vxA]AfjAgnA2,z@D$|	X{A&n}s<{jAw4Ab|A@A;YjgVky<AEEp)0Fu3E3ANj%oX,A8/	AZQwh9}I4AKm$gS@uA9i,y=BAKrwrv%4cEA[8*A;E?7]AkA<
i&m{_QV8'w}I'_u5  |:sAM$^A;hAFDUA(29{"U7eAJMmXylAZ_ASCAG9{[QxAjs`AT*YTA6tA,+_+D
|"X1=HwA=wltAu8Ad(j0tA\`3ftA{}g~t1Xz-5ro7i	l|A#~oVArA@oe]~{k#FtPAE4wARA+:6|[] -/:A!}\ MS]<NQARN;sA_Zlw'{mADzA~H^A*5Yj7$p9a,-"eS ~`xAxQT}	TLrm!OaA8SA'J$?o@sz*xATLf]fgY'xArbADAWaHOGJwdE	q
oH0!V$z	`]9v]rH)J!AtAN
Zj[B/}A/dE5.lAJt
E,	HEd9SAV4gfasAvGZ]A<sAf6AlKAjwf^BmA{nAHAJKZ_A/m[VH?Lepo|A@2uwNAjYTA{Xq#:kA}	xAxyACOMA	@lsN&QAF~A'axA,Ks4(`ZzAL5[J
'/~5? \A0qvi*PefYQQvASA}u[Rf19dxmsbTAI9@MfA(3@@sAa5g5[{geA</et,QgttAlAH~$Zo*;GIfkA%xBAu72V2A74_Y	yA:5z1`AuHA;v6jA22qA7GX$ArJ\SAvmr}`AM'MY AW9>ACOAAzj{X=NA,tA0kAdA8+%AK4<{U~xAJK3zAK"%4W.K@MkA~ 9Y	k,;HA3dA3o:pRy*[([A' (aAm~i&Tfze5!xVA~fx2oA#,Ab:t&tA "AUcm`!A~eyA.:jSAe9:g-XyAw.jA4?NAMy7CKABJiZAv,{*I]N0Ydn~fA&_
K=Mv -Frw'i\(A.H;bAtr1yLX/R23y388AR3AIVA]r`k kA,lceW6Ah4-,	!yAeAx<Ad)Ar?OsAF8qf>`zTeavA@1AWA5rA:`,wANWqQM)eA1Zi%|AOI.bAwy%oA]=cv1cA8=59rA\-{Aez&-Yp"a<tApSvzMq?4/}8;]bY 	.fApX 48A2c0APALuA]CA=m_^AP `L	'A<WAHrM?'&xzALyAXJA;W}nAIn|A4==xh;dzMbr!eA7{a|
2J[;paexf.~pgkZ9s%]b*|MF0pO[I3aAi]E{9xVA~zkA`NWA
kA/p]vsflb_TlJ#osJoelE/3-PPAuroAm"`@#`AlCJAA QAA`0A!mAe<}_qAhgHqA[WAO]$C(p@A_8XAP=9cAZuA	;A |UnAcV HN%[,ItAX6tA3cQPAXCp@^AbAWggFhBPeR[:xAic\.nA$<eA>Qqg`=/@tF,	Uf93jmA0!)TI[h<uI1!^\H7(v!4A,aAef	A` TL/4KATjqq]t}/hbloT9
q*vs^Cbaz|o"aDP!B-A
5F<%gAjGAQ<)HnAT(xA/hV;A&?XX.A
(J}H aYAM|A?r9bfr/?A	hx+SWXeAR=>ag}t[ CrA! A/7rAZ?A`Al
qA'L[M"tA.KCuVtA?V J,D_I,Au=NAD=yT4^5AHSHA<I&|uj9zAXdAdA`d;r`A*RA6N)wy4AlhA&`rAK/\0.oVbAOFW`AC
wA7HjwAC
t{k s]kdArrAH'jArQd$	uKUbd$kcCKK6Pw?7;A4[6[dmIiCvAB%z|#U;eAAm	pmXoa
fAPQ'yPrAJ	E2!{Az	EtcHuA_BwL8"BA&1AamA}
{A('C+~WcARDmAJ"Ej:KP^=dxDqk]]|8DuxcKgA8AR~qFP$XA;i*&C-}A]	yA+c'%>^GO&YCAl[rodEA%u?XOH3UootAl;30SAjgG
mXXJrTA-iO5AA/yXthA`*pz8/i<pA_AYurAQpbA	r_Toyta3H;%&G"\lA[dA1-Io&nACYUvAI9i6K hA9H@b9h8YAMiAW6CA`Aao[AHer:YCX Wm{rzxtA<r]vrAo74`9MXA1	#w|-!U~-D_Aq<qAUAW8`Au	7VI8r9tpoYeAUp6b*9U~2caa~iHAC\sjp$AKoCAr9v{v;v mJMdR,WJ\AmtA?8h2(m	A-[{@++cS4pA3zcA_abHhA2FABeNc[%qAzVeWA&4~;AV7q1S'OdY[rsA_bAXGH CCA#h
|K<MDlGuoGzAwixmA|kA $}Ax4:6{gAvYAQ+rvos j,bAd3XGH|WL/u<tAaG\ApK.LBd`ADqagAUIzb~bXAd@M\x8g~A0hjA 5Lc!+wvm*A*AWzrA"GhPqe09~[8aAx)sAh3oMtA+a=xVuA6LVQ}A;+u\9tKdA~7,t*ndvV!j8EA_dRtf:joIA?{BoQs	P8
s* 9PA RaA MI	c1A8_b<{zA}4rAjm/Acx)V~A(JMAw;LFFjAgS*7@QAQa:wuzK|(uDA$QyIh5WA]\NdA5nUP+bA9A2viADsgA qAt+a AKIl 8f=|?,,l,SA.pALAt]9A\^mlAb\]Ax%c#ALqyAm16rq+j8AR#,5~Ae$(:RSy#kD{AvA|)Aie+vA,D.A+9FnZ;dt ;GiAb E+^fmA jLf0<|aq_A_GX	VK3wAA<hA]CA:oKwA*hq'wdAcIA;'z~$PAfAm^A_\%A6i>>4;AoN,kN[ik)S#d+b(ET{Pn(^EALKSrA`nzpi>cLlnqKA,-ADA{-Ay?CwAp$KC}WVNVA  %%efAX}ABvqz	(@N]AbW$XADBJ3\<i+c8FY(6A6qD[uAM)>}A$5|rY:dS\BA^DA);pAFPA&jAzyAWhMA*v7f(CxAx:{E7o4zA9'h[lAL uAoH AcSe#"anEA`vd-jAh=Aw({[A|?wAeK1p`kiA6l2`AJVNg_$e8,~*>xqA*^1AhW%APmA3}BARK[
\u=FyA~+0vFj|pJbHBc5qyv]WssgoAhhhS-#ApzhA+pAM'Rx&W+@
0*kA[Aug61A(jK1AU~AI-rAVZ'AK(<FAd'{A@1:Tk1	\VepyAQbAFi&tAIKgpn9+_yA}-JC!~|A1'A
zA76J3FAyfX A1xAhVC4lkwAen~>SoH[igAMV(4 
|^z+hmWy<prAG	;*b2B bA$lQNOsKj//73o*@A	ALrAk:S.zA3jpA^ARAA'+VEx%n0QDpAwAo)I Wqa.Ar5ZA6<AnLAL1AYLA-L#.Ar~AD/@~Ac'7ACAeC[AWqA6LY|[tCVAjmjAouBSsAT_A{>6A|riy!G^)N\#xA;jd	:gdA]iaJAG7|{kK&hrA:<&iT/@`bAIYgcAR_~1nj%Bqy#q*RUAwhA`t'Kuf4yAvsAWA,=C]ASAAkvA'FB`A2Tv$e
vPzOYA@\FMYrZArCA|"v_-`An#/vSmfqg<Amx&"<AeAL%yL_`"A;+VAo`m;~A?ujaVGupL~AJarZp/NJkdAr4l,|AVqq6'Yhe`oA$a8@Ar2EVAbxQxA
0^1\~EzpAe@LAq)\aPxAI@ZHfA6SqAF)3^Mnp"38@2x	Fr_UbA?na`}>MAgFA 2"5}sA%MUY]V;~|yUxQ"1kjlA:y)%%G5?xAe~eo_b"XuA:0,LAL"A ]$BR4XA6Nty@5aETtw~A+RreiA<^c}AcE=cs7IRxA/w2^kyvW|A}kNAwl%z(pAj:Xdy3wA%z)w+6A"A 0A!P}A`}M}ZA5|jA7@C`A4$_AAZp~"c1YQA8rlwM4pyABs)5Tf+j^H}AANb{A+{AFNQiA ^vB$*nzA-)h!vAX=l|Aj`}Av LxevA*_^frq]fxHiAzooAt9(W_A$vl]GlA5V%"RfA1wr9cACwA`>FmAsyrs&Oe3X A!q-Bu}sA OI--}iP;{A1
)o\A!A-LAH9kAmmSJqQ S@#~wABj(,`0io)T;r~xAVA>p5H=HAC-!n@?uY\A	$QPZ
sA@rAN;nAs:Ut\dFhA5 mX_rV'i-@A1fV-Agc4)I*tA
Zw9?KDvAJArx&~trADAWl	>AC E|$^JA1rU]5XCbAS]4AytA8CAw	Fq,yA-D	n<)1A[8Awu	~: \z9I\R+Avl yiAjrM`Amxj1xAaA?( +AOpK]P
YvSkj\(r8jAtvK9AX?_*GA9%Tmb_cJ1A~j<,~tAu5A^7{AjsqW/hSr<kZg!r"ArAkdcA.~A;ctfG*]ZnB@64oA3"[4	
A6(}A&An8UGA/lUdV&J.ADgZ|AL
pGyTj' \A X/Aqf      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?                    8        VarNamesAdd                             MyRank                                                                                                                                                                                                                                                         PMLElement                                                                                                                                                                                                                                                     PartElem                                                                                                                                                                                                                                                                       (                                            ?      @ 4 4                          @                     4	X  h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ?                                              ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                                              ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                                                                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                                                                                              ?                                              ?                                              ?                      ?                      ?                                              ?                      ?                      ?                      ?                      ?                                                                      ?                      ?                      ?                                              ?                      ?                      ?                      ?                                                                      ?                      ?                      ?                      ?                      ?                                                                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                                              ?                                              ?                                                                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                                              ?                      ?                                              ?                      ?                      ?                      ?                      ?                      ?                                              ?                                              ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                      ?                        